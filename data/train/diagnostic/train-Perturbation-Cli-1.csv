[REPLACE]  private  ArrayList  tokens  =  new  ArrayList  (  )  ;	[BUGGY]  private  ArrayList  tokens    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  GnuParser  
[REPLACE]  tokens  .  clear  (  )  ;	[BUGGY]  tokens  .  ArrayList  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  init  (  )  {  [ATTENTION]  tokens  .  ArrayList  (  )    ;  }    [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  boolean  false  true  
[REPLACE]  init  (  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  boolean  eatTheRest  =  false;	[BUGGY]  boolean  eatTheRest  =  true  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    [ATTENTION]  boolean  eatTheRest  =  true  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  currentOption  =  null;	[BUGGY]  Option  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  [ATTENTION]  Option  currentOption  =  false  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (   "-- "  .  equals  (  arguments[i]  )  )  {	[BUGGY]  else  if  (   "- "  .  equals  (  arguments[i]  )  )[CE]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  [ATTENTION]  else  if  (   "- "  .  equals  (  arguments[i]  )  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {	[BUGGY]  if  (   "- "  .  equals  (  arguments[i]  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  [ATTENTION]  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  [ATTENTION]      else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {[FE]  String  index  out  of  range:  2  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]        if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (specialOption  !  =  null  )  {[CE]  cannot  find  symbol  specialOption  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  specialOption  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;    options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [NO-ERROR]  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  i  ,  i  )    )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  i  ,  i  )    )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  1  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  1  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  null  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )    )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  0  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  0  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  option;	[BUGGY]  currentOption  =  null  ;    ;  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]  currentOption  =  null  ;    ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  option;	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "toast ")  )  ;  assertTrue(   "Confirm  size  of  extra  args "  ,  cl.getArgList().size()  =  =  3)  ;  assertTrue(   "Confirm  UnrecognizedOptionException  caught "  ,  caught  )  ;  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  Confirm  size  of  extra  args  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "toast ")  )  ;  assertTrue(   "Confirm  size  of  extra  args "  ,  cl.getArgList().size()  =  =  3)  ;  assertTrue(   "Confirm  UnrecognizedOptionException  caught "  ,  caught  )  ;  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  3  )  )  ;  [FE]  AssertionFailedError    expected:<[prop]erty>  but  was:<[]erty>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  3  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  [FE]  Unexpected  exception:Missing  argument  for  option:D  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  0  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -2  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (option  =  =  null  )  {[FE]  Unexpected  exception:  Unrecognized  option:  -e  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -2  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  *  2  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  *  2  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2L  )  )  ;  [CE]  no  suitable  method  found  for  substring(long)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2L  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  null  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  null  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )    tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    tokens  .  add  (  arguments[i]  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  0  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  5  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  5  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  option;	[BUGGY]  currentOption  =  null  ;    ;  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]  currentOption  =  null  ;    ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )  ;  [FE]  String  index  out  of  range:  -1  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  specialOption  )  {[CE]  cannot  find  symbol  specialOption  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  specialOption  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  false  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  false  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )    tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  specialOption  =  =  null  )  {[FE]  Confirm  -c  is  set  assertTrue(   "Confirm  -c  is  set "  ,  cl.hasOption( "c ")  )  ;  assertTrue(   "Confirm  3  extra  args:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  3)  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  current      )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  current  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  specialOption  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  specialOption  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;    options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (option  =  =  null  )  {[FE]  Unexpected  exception:  Unrecognized  option:  -e  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  4  )  )  ;  [FE]  AssertionFailedError    expected:<[pr]operty>  but  was:<[]operty>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  4  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;    tokens  .  add  (  arguments[i]  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  i  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  i  )    )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  3  )  )  ;  [FE]  AssertionFailedError    expected:<p[rop]erty>  but  was:<p[]erty>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  3  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  )  )  ;  [FE]  AssertionFailedError    expected:<[]property>  but  was:<[-D]property>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  specialOption  =  =  null  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  specialOption  =  =  null  )  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  specialOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (specialOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  option;	[BUGGY]  currentOption  =  null  ;    ;  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]  currentOption  =  null  ;    ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )  ;  [FE]  String  index  out  of  range:  -1  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (   "- "  )  ;	[BUGGY]  tokens  .  toArray  (   "- "  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  tokens  .  toArray  (   "- "  )    ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  false  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {      Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  specialOption  !  =  null  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  stopAtNonOption  )  {                  eatTheRest  =  true  ;                  tokens  .  add  (  arguments[i]  )  ;              }else  {                  tokens  .  add  (  arguments[i]  )  ;              }              }else  {          currentOption  =  option  ;          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {                  if  (  currentOption  .  hasArg  (  )  )  {                      tokens  .  add  (  arguments[i]  )  ;                      currentOption  =  null  ;                  }else                      if  (  currentOption  .  hasArgs  (  )  )  {                          tokens  .  add  (  arguments[i]  )  ;                      }else                          if  (  stopAtNonOption  )  {                              eatTheRest  =  true  ;                              tokens  .  add  (   "-- "  )  ;                              tokens  .  add  (  arguments[i]  )  ;                          }else  {                              tokens  .  add  (  arguments[i]  )  ;                          }                                                    }else                  if  (  currentOption  !  =  null  )  {                      tokens  .  add  (  arguments[i]  )  ;                  }else                      if  (  stopAtNonOption  )  {                          eatTheRest  =  true  ;                          tokens  .  add  (   "-- "  )  ;                          tokens  .  add  (  arguments[i]  )  ;                      }else  {                          tokens  .  add  (  arguments[i]  )  ;                      }                                            }  }else  {      tokens  .  add  (  arguments[i]  )  ;  }[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  =  =  null  )    if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )    ;  if  (  option  =  =  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}else  {  currentOption  =  option  ;  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  currentOption  =  null  ;  }else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }  }else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}  }else  {  tokens  .  add  (  arguments[i]  )    ;  }{    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (true  )  &&  (  option  !  =  null  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  true  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  0  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  0  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  -  4  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  -  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;    tokens  .  add  (  arguments[i]  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  null  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [FE]  AssertionFailedError    expected:<[]property>  but  was:<[-D]property>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    tokens  .  add  (  arguments[i]  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  i  ,  i  )    )  ;  [FE]  AssertionFailedError    expected:<[property]>  but  was:<[]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  i  ,  i  )    )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  3  )  )  ;  [FE]  AssertionFailedError    expected:<[p]roperty>  but  was:<[]roperty>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  3  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  4  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  4  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  option;	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  specialOption  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  false  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (true  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  true  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  specialOption  =  =  true  )  &&  currentOption  .  hasArg  (  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  specialOption  =  =  true  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (specialOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  i  )    )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  i  )    )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  5  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  5  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  0  ,  2  )  )  ;  [FE]  /  by  zero  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  1  )  )  ;  [FE]  AssertionFailedError    expected:<[]property>  but  was:<[D]property>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  1  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  option  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  option  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  0  )  )  ;  [FE]  AssertionFailedError    expected:<[]property>  but  was:<[-D]property>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  0  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  false  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  false  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  true  (  )  )  {[CE]  ')'  expected  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  specialOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  specialOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  tokens  .  add  (   "-- "  )  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )    ;    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )    tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  0  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]  else  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  null  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]        if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  %  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  %  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  true  (  )  )  {[CE]  ')'  expected  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  specialOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  4  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  4  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (option  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  false  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )    ;    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;    }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  stopAtNonOption  )  &&  (  option  !  =  null  )  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  stopAtNonOption  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  specialOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  specialOption  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  +  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  +  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  true  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]        if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  this  )  &&  currentOption  .  hasArg  (  )  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  this  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>>  1  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>>  1  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  this  )  &&  (  option  !  =  this  )  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  this  )  &&  (  option  !  =  this  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;    }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  4  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  specialOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  specialOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (specialOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  specialOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  specialOption  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -2  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  true  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  this  )  &&  (  option  !  =  this  )  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  this  )  &&  (  option  !  =  this  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  null  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]    }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  4  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (specialOption  =  =  null  )  {[FE]  Confirm  -c  is  set  assertTrue(   "Confirm  -c  is  set "  ,  cl.hasOption( "c ")  )  ;  assertTrue(   "Confirm  3  extra  args:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  3)  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  *  2  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  specialOption  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  1  )  )  ;  [FE]  AssertionFailedError    expected:<[]property>  but  was:<[D]property>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  1  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  0  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  0  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )    )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  *  0  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  null  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (specialOption  !  =  null  )  {[CE]  cannot  find  symbol  specialOption  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  specialOption  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (    (  option  !  =  null  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (    (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2L  )  )  ;  [CE]  no  suitable  method  found  for  substring(long)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2L  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  -  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  -  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  option  =  =  null  )  {[FE]  Unexpected  exception:  Unrecognized  option:  -e  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  4  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  4  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  2  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>  0  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (    (  option  !  =  null  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (    (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {      Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  specialOption  !  =  null  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  stopAtNonOption  )  {                  eatTheRest  =  true  ;                  tokens  .  add  (  arguments[i]  )  ;              }else  {                  tokens  .  add  (  arguments[i]  )  ;              }              }else  {          currentOption  =  option  ;          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {                  if  (  currentOption  .  hasArg  (  )  )  {                      tokens  .  add  (  arguments[i]  )  ;                      currentOption  =  null  ;                  }else                      if  (  currentOption  .  hasArgs  (  )  )  {                          tokens  .  add  (  arguments[i]  )  ;                      }else                          if  (  stopAtNonOption  )  {                              eatTheRest  =  true  ;                              tokens  .  add  (   "-- "  )  ;                              tokens  .  add  (  arguments[i]  )  ;                          }else  {                              tokens  .  add  (  arguments[i]  )  ;                          }                                                    }else                  if  (  currentOption  !  =  null  )  {                      tokens  .  add  (  arguments[i]  )  ;                  }else                      if  (  stopAtNonOption  )  {                          eatTheRest  =  true  ;                          tokens  .  add  (   "-- "  )  ;                          tokens  .  add  (  arguments[i]  )  ;                      }else  {                          tokens  .  add  (  arguments[i]  )  ;                      }                                            }  }else  {      tokens  .  add  (  arguments[i]  )  ;  }[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )    if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )    ;  if  (  option  =  =  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}else  {  currentOption  =  option  ;  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  currentOption  =  null  ;  }else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }  }else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}  }else  {  tokens  .  add  (  arguments[i]  )    ;  }{  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  /  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  /  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  specialOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  specialOption  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  eatTheRest  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  i++  ;  i  <  arguments  .  length  -  4  ;  i++  )  {[FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  if  (  eatTheRest  )  {  [ATTENTION]  for  (  i++  ;  i  <  arguments  .  length  -  4  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  arguments  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  arguments  .  length  (  )    ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (   "-- "  .  equals  (  arguments[i]  )  )  {	[BUGGY]  else  if  (   "- "  .  equals  (  arguments[i]  )  )[CE]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  [ATTENTION]  else  if  (   "- "  .  equals  (  arguments[i]  )  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {	[BUGGY]  else  if  (   "- "  .  equals  (  arguments[i]  )  )[CE]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  [ATTENTION]  else  if  (   "- "  .  equals  (  arguments[i]  )  )    tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {[FE]  String  index  out  of  range:  2  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  +  4  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  +  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2L  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2L  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (    (  option  !  =  null  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (    (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  3  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  specialOption  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  true  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]        if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  false  )  &&  (  option  !  =  false  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  false  )  &&  (  option  !  =  false  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  4  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  option  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  option  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  +  4  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -2  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  +  4  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  >>  2  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  >>  2  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  5  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  5  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  0  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  option  =  =  null  )  {[FE]  Unexpected  exception:  Unrecognized  option:  -e  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )    ;    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (    (  option  !  =  null  )  )  {[FE]  Unexpected  exception:Unrecognized  option:  -b  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (    (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  null  )  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  null  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  null  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]      }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>>  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  >>>  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  true  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  true  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]      currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  specialOption  )  {[FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  specialOption  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )    )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  option;	[BUGGY]  currentOption  =  null  ;    ;  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]  currentOption  =  null  ;    ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  [ATTENTION]      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  0  ,  2  )  )  ;  [FE]  /  by  zero  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  0  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (   "- "  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (   "- "  )  ;	[BUGGY]  [FE]  org.apache.commons.cli.MissingArgumentException:  Missing  argument  for  option:b  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )[CE]  not  a  statement  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )    Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  option  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  option  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (  currentOption  =  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  currentOption  =  =  this  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  +  4  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  +  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  (  currentOption  =  =  true  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  (  currentOption  =  =  true  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(GnuParser)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  3  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  +  3  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  true  (  )  )  {[CE]  ')'  expected  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  else  if  (specialOption  =  =  null  )  {[FE]  Confirm  -c  is  set  assertTrue(   "Confirm  -c  is  set "  ,  cl.hasOption( "c ")  )  ;  assertTrue(   "Confirm  3  extra  args:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  3)  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  else  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (specialOption  !  =  null  )  {[CE]  cannot  find  symbol  specialOption  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  specialOption  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  5  )  )  ;  [FE]  AssertionFailedError    expected:<p[rop]erty>  but  was:<p[]erty>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  5  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  0  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  0  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  i  )    )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  3  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  3  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>>  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>>  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  2  <<  0  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  2  <<  0  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  eatTheRest  )  {      for  (  i++  ;  i  <  (  arguments  .  length  )  ;  i++  )  {          tokens  .  add  (  arguments[i]  )  ;      }  }[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    if  (  eatTheRest  )  {  for  (  i++  ;  i  <  (  arguments  .  length  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )    ;  }  }{  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Missing  argument  for  option:buildfile  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  option;	[BUGGY]  [FE]  exec  option  not  found  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  [ATTENTION]      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  option  ;    ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  currentOption  =  option  ;    ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  currentOption  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  [ATTENTION]  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  specialOption  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (   "-- "  )  ;	[BUGGY]  [FE]  Confirm  -b  is  not  set  assertTrue(   "Confirm  -c  is  set "  ,  cl.hasOption( "c ")  )  ;  assertTrue(   "Confirm  -b  is  not  set "  ,  !  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  2  extra  args:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  2)  ;  [CONTEXT]  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]    }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {	[BUGGY]  if  (   "- "  .  equals  (  arguments[i]  )  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  [ATTENTION]  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }	[BUGGY]  [FE]  String  index  out  of  range:  2  assertTrue(   "Confirm  -a  is  set "  ,  cl.hasOption( "a ")  )  ;  assertTrue(   "Confirm  -b  is  set "  ,  cl.hasOption( "b ")  )  ;  assertTrue(   "Confirm  arg  of  -b "  ,  cl.getOptionValue( "b ").equals( "- ")  )  ;  assertTrue(   "Confirm  1  extra  arg:   "  +  cl.getArgList().size()  ,  cl.getArgList().size()  =  =  1)  ;  assertTrue(   "Confirm  value  of  extra  arg:   "  +  cl.getArgList().get(0)  ,  cl.getArgList().get(0).equals( "- ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  [ATTENTION]      else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  [ATTENTION]        if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  this  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  this  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  <<  1  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  )  ;  [NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  )    ;    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -3  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]    }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  false  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  false  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  -  4  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  2  -  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -2  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  4  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  null  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {      Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  specialOption  !  =  null  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  stopAtNonOption  )  {                  eatTheRest  =  true  ;                  tokens  .  add  (  arguments[i]  )  ;              }else  {                  tokens  .  add  (  arguments[i]  )  ;              }              }else  {          currentOption  =  option  ;          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {                  if  (  currentOption  .  hasArg  (  )  )  {                      tokens  .  add  (  arguments[i]  )  ;                      currentOption  =  null  ;                  }else                      if  (  currentOption  .  hasArgs  (  )  )  {                          tokens  .  add  (  arguments[i]  )  ;                      }else                          if  (  stopAtNonOption  )  {                              eatTheRest  =  true  ;                              tokens  .  add  (   "-- "  )  ;                              tokens  .  add  (  arguments[i]  )  ;                          }else  {                              tokens  .  add  (  arguments[i]  )  ;                          }                                                    }else                  if  (  currentOption  !  =  null  )  {                      tokens  .  add  (  arguments[i]  )  ;                  }else                      if  (  stopAtNonOption  )  {                          eatTheRest  =  true  ;                          tokens  .  add  (   "-- "  )  ;                          tokens  .  add  (  arguments[i]  )  ;                      }else  {                          tokens  .  add  (  arguments[i]  )  ;                      }                                            }  }else  {      tokens  .  add  (  arguments[i]  )  ;  }[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  =  =  null  )    if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )    ;  if  (  option  =  =  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}else  {  currentOption  =  option  ;  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  currentOption  =  null  ;  }else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }  }else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}  }else  {  tokens  .  add  (  arguments[i]  )    ;  }{    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  -  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  0  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  currentOption  !  =  null  )  {  [ATTENTION]  tokens  .  toArray  (  0  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (option  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  option  =  =  true  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  /  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  true  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  true  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]      else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  true  )  &&  (  option  !  =  true  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  true  )  &&  (  option  !  =  true  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  3  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  3  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  >>>  2  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (option  !  =  null  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      [ATTENTION]  if  (  option  !  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  >>  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )    )  {[NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )    )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  *  2  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  equals  (  1  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  equals  (  1  )  )    ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  else  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  0  +  0  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  specialOption  !  =  null  )  {  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  0  +  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (    (  option  !  =  false  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (    (  option  !  =  false  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  this  )  )  {[CE]  incomparable  types:  Option  and  GnuParser  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  this  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  specialOption  .  hasArgs  (  )  )  {[NO-ERROR]  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  false  )  &&  currentOption  .  hasArg  (  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  false  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  0  ,  2  )  )  ;  [FE]  /  by  zero  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  /  0  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {      Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  specialOption  !  =  null  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  stopAtNonOption  )  {                  eatTheRest  =  true  ;                  tokens  .  add  (  arguments[i]  )  ;              }else  {                  tokens  .  add  (  arguments[i]  )  ;              }              }else  {          currentOption  =  option  ;          Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;          if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {              tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;              tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;          }else              if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {                  if  (  currentOption  .  hasArg  (  )  )  {                      tokens  .  add  (  arguments[i]  )  ;                      currentOption  =  null  ;                  }else                      if  (  currentOption  .  hasArgs  (  )  )  {                          tokens  .  add  (  arguments[i]  )  ;                      }else                          if  (  stopAtNonOption  )  {                              eatTheRest  =  true  ;                              tokens  .  add  (   "-- "  )  ;                              tokens  .  add  (  arguments[i]  )  ;                          }else  {                              tokens  .  add  (  arguments[i]  )  ;                          }                                                    }else                  if  (  currentOption  !  =  null  )  {                      tokens  .  add  (  arguments[i]  )  ;                  }else                      if  (  stopAtNonOption  )  {                          eatTheRest  =  true  ;                          tokens  .  add  (   "-- "  )  ;                          tokens  .  add  (  arguments[i]  )  ;                      }else  {                          tokens  .  add  (  arguments[i]  )  ;                      }                                            }  }else  {      tokens  .  add  (  arguments[i]  )  ;  }[CE]  'else'  without  'if'  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )    if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )    ;  if  (  option  =  =  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}else  {  currentOption  =  option  ;  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )    ;  }else  if  (  (  currentOption  !  =  null  )  &&  (  currentOption  .  hasArg  (  )  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  currentOption  =  null  ;  }else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }  }else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )    ;  }else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )    ;  tokens  .  add  (  arguments[i]  )    ;  }else  {  tokens  .  add  (  arguments[i]  )    ;  }}  }else  {  tokens  .  add  (  arguments[i]  )    ;  }{  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  .  substring  (  1  ,  2  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  .  substring  (  1  ,  2  )  )    ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;	[BUGGY]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  4  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  [ATTENTION]  tokens  .  add  (  arguments[i]  .  substring  (  2  -  4  )  )    ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  true  )  &&  currentOption  .  hasArg  (  )  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  (  currentOption  =  =  true  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  %  2  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )  ;  [FE]  String  index  out  of  range:  -3  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  -  3  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  specialOption  !=  null  )  {	[BUGGY]  if  (  specialOption  =  =  null  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  specialOption  =  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  AssertionFailedError    expected:<[property1]>  but  was:<[-Dproperty]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  [FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]    }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {	[BUGGY]  if  (  (  specialOption  !  =  null  )  )  {[FE]  AssertionFailedError    expected:<[]>  but  was:<[value]>  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    [ATTENTION]  if  (  (  specialOption  !  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  specialOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  if  (  specialOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )    tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  else  if  (  currentOption  !=  null  )  {	[BUGGY]  if  (  currentOption  =  =  false  )  {[CE]  incomparable  types:  Option  and  boolean  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  [ATTENTION]  if  (  currentOption  =  =  false  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  if  (  eatTheRest  )  {	[BUGGY]  if  (  true  )  {[FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  [ATTENTION]  if  (  true  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  i++  ;  i  <  arguments  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  if  (  eatTheRest  )  {  [ATTENTION]  for  (  i++  ;  i  <  arguments  .  length  (  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  for  (  i++;  i  <  arguments  .  length;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  eatTheRest  )  {  [ATTENTION]      }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  i++  ;  i  <  arguments  .  length  -  2  ;  i++  )  {[FE]  null  assertTrue(  cmd.hasOption( "exec_opt1 ")  )  ;  assertTrue(  cmd.hasOption( "exec_opt2 ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  [ATTENTION]  for  (  i++  ;  i  <  arguments  .  length  -  2  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  tokens  .  add  (  arguments[i]  )  ;	[BUGGY]  tokens  .  toArray  (  arguments[i]  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  [ATTENTION]  tokens  .  toArray  (  arguments[i]  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[ADD]  eatTheRest  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0L  ,  2  )  )    ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ;	[BUGGY]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )  ;  [NO-ERROR]  [CONTEXT]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      [ATTENTION]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  2  ,  2  )  )    ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  i++  ;  i  <  arguments  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  [ATTENTION]  for  (  i++  ;  i  <  arguments  .  length  (  )    ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  arguments  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {[NO-ERROR]  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {  }  )  ;	[BUGGY]  return  (  String[]  )  tokens  .  ArrayList  (  new  String[]  {  }  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  init  (  )  ;    boolean  eatTheRest  =  false  ;  Option  currentOption  =  null  ;    for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  if  (   "-- "  .  equals  (  arguments[i]  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arguments[i]  .  startsWith  (   "- "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ;      if  (  option  =  =  null  )  {    Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  specialOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  {  currentOption  =  option  ;      Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;    if  (  (  specialOption  !  =  null  )  &&  (  option  =  =  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0  ,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  }  else  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  else  if  (  currentOption  !  =  null  )  {  tokens  .  add  (  arguments[i]  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  arguments[i]  )  ;  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  else  {  tokens  .  add  (  arguments[i]  )  ;  }  if  (  eatTheRest  )  {  for  (  i++  ;  i  <  arguments  .  length  ;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  }  }  }  [ATTENTION]  return  (  String[]  )  tokens  .  ArrayList  (  new  String[]  {}  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  option  specialOption  [TYPE]  String[]  arguments  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  int  i  
[REPLACE]  private  static  String  longopt;	[BUGGY]  private  String  longopt  ;  [CE]  non-static  variable  longopt  cannot  be  referenced  from  a  static  context  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  String  argName;	[BUGGY]  private  static  boolean  argName  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  boolean  required;	[BUGGY]  private  boolean  required  ;  [CE]  non-static  variable  required  cannot  be  referenced  from  a  static  context  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  int  numberOfArgs  =  Option  .  UNINITIALIZED;	[BUGGY]  private  static  int  numberOfArgs  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  boolean  optionalArg;	[BUGGY]  private  boolean  optionalArg  ;  [CE]  non-static  variable  optionalArg  cannot  be  referenced  from  a  static  context  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  char  valuesep;	[BUGGY]  private  static  String  valuesep  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  private  static  OptionBuilder  instance  =  new  OptionBuilder  (  )  ;	[BUGGY]  private  static  OptionBuilder  instance    =  null  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  OptionBuilder  
[REPLACE]  description  =  null;	[BUGGY]  description  =  false  ;  [CE]  incompatible  types  [CONTEXT]  private  static  void  reset  (  )  {  [ATTENTION]  description  =  false  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[ADD]  description  =  null;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  static  void  reset  (  )  {  [ATTENTION]  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  argName  =   "arg ";	[BUGGY]  argName    =    argName  ;  [FE]  expected:<usage:  dir  assertEquals( "usage:  dir "+eol+ "  -d  <arg>    dir "+eol  ,  bytes.toString())  ;  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  [ATTENTION]  argName  =  argName  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  longopt  =  null;	[BUGGY]  longopt  =  true  ;  [CE]  incompatible  types  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  [ATTENTION]  longopt  =  true  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  type  =  null;	[BUGGY]  type  =  true  ;  [FE]  Expected:  <null>  but  was:  true  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  [ATTENTION]  type  =  true  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;  [FE]  null  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  [ATTENTION]  required  =  true  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  numberOfArgs  =  Option  .  UNINITIALIZED;	[BUGGY]  numberOfArgs    =  null  ;  [CE]  incompatible  types  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  [ATTENTION]  numberOfArgs  =  null  ;      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[ADD]  numberOfArgs  =  Option  .  UNINITIALIZED;	[BUGGY]  [FE]  assertTrue(  cmd.hasOption(   "verbose "  )  )  ;  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  [ATTENTION]      optionalArg  =  false  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  optionalArg  =  false;	[BUGGY]  optionalArg  =  true  ;  [FE]  assertTrue(  exp  !  =  null  )  ;  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      [ATTENTION]  optionalArg  =  true  ;  valuesep  =    (  char  )  0  ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  valuesep  =  (  char  )  0;	[BUGGY]  OptionBuilder  .  required  =  newRequired  ;    ;  [CE]  cannot  find  symbol  newRequired  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;      optionalArg  =  false  ;  [ATTENTION]  OptionBuilder  .  required  =  newRequired  ;    ;  }    [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  longopt  =  newLongopt;	[BUGGY]  OptionBuilder  .  longopt  =    description  ;  [FE]  must  specify  longopt  assertTrue(  line.hasOption(   "block-size "  )  )  ;  assertEquals(  line.getOptionValue(   "block-size "  )  ,   "10 "  )  ;  [CONTEXT]  public  static  OptionBuilder  withLongOpt  (  String  newLongopt  )  {  [ATTENTION]  OptionBuilder  .  longopt  =  description  ;    return  instance  ;  }    [METHOD]  withLongOpt  [TYPE]  OptionBuilder  [PARAMETER]  String  newLongopt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withLongOpt  (  String  newLongopt  )  {  OptionBuilder  .  longopt  =  newLongopt  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withLongOpt  [TYPE]  OptionBuilder  [PARAMETER]  String  newLongopt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  1;	[BUGGY]  OptionBuilder  .  numberOfArgs  =  1  <<  0  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasArg  (  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  1  <<  0  ;    return  instance  ;  }    [METHOD]  hasArg  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasArg  (  )  {  OptionBuilder  .  numberOfArgs  =  1  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasArg  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  (  hasArg  ==  true  )  ?  1  :  Option  .  UNINITIALIZED;	[BUGGY]  OptionBuilder  .  numberOfArgs  =    (  hasArg  !  =    true  )  ?  1  :  Option  .  UNINITIALIZED  ;  [FE]  Missing  argument  for  option:c  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue( "a "))  ;  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue('a'))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject( "a "))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject('a'))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject( "b "))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject('b'))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption( "c "))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption('c'))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption( "d "))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption('d'))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject( "e "))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject('e'))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject( "f "))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject('f'))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject( "n "))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject('n'))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject( "t "))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject('t'))  ;  //      assertEquals( "number  flag  t "  ,  new  java.util.Date(1023400137276L)  ,  line.getOptionObject('z'))  ;  [CONTEXT]  public  static  OptionBuilder  hasArg  (  boolean  hasArg  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  (  hasArg!  =  true  )  ?  1  :  Option  .  UNINITIALIZED  ;    return  instance  ;  }    [METHOD]  hasArg  [TYPE]  OptionBuilder  [PARAMETER]  boolean  hasArg  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[ADD]  OptionBuilder  .  numberOfArgs  =  (  hasArg  ==  true  )  ?  1  :  Option  .  UNINITIALIZED;	[BUGGY]  [FE]  AssertionFailedError    flag  a  expected:<foo>  but  was:<null>  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue( "a "))  ;  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue('a'))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject( "a "))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject('a'))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject( "b "))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject('b'))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption( "c "))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption('c'))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption( "d "))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption('d'))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject( "e "))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject('e'))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject( "f "))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject('f'))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject( "n "))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject('n'))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject( "t "))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject('t'))  ;  //      assertEquals( "number  flag  t "  ,  new  java.util.Date(1023400137276L)  ,  line.getOptionObject('z'))  ;  [CONTEXT]  public  static  OptionBuilder  hasArg  (  boolean  hasArg  )  {  [ATTENTION]    return  instance  ;  }    [METHOD]  hasArg  [TYPE]  OptionBuilder  [PARAMETER]  boolean  hasArg  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasArg  (  boolean  hasArg  )  {  OptionBuilder  .  numberOfArgs  =    (  hasArg  =  =  true  )  ?  1  :  Option  .  UNINITIALIZED  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasArg  [TYPE]  OptionBuilder  [PARAMETER]  boolean  hasArg  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  argName  =  name;	[BUGGY]  OptionBuilder  .  argName  =    newLongopt  ;  [CE]  cannot  find  symbol  newLongopt  [CONTEXT]  public  static  OptionBuilder  withArgName  (  String  name  )  {  [ATTENTION]  OptionBuilder  .  argName  =  newLongopt  ;    return  instance  ;  }    [METHOD]  withArgName  [TYPE]  OptionBuilder  [PARAMETER]  String  name  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[ADD]  OptionBuilder  .  argName  =  name;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  withArgName  (  String  name  )  {  [ATTENTION]    return  instance  ;  }    [METHOD]  withArgName  [TYPE]  OptionBuilder  [PARAMETER]  String  name  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withArgName  (  String  name  )  {  OptionBuilder  .  argName  =  name  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withArgName  [TYPE]  OptionBuilder  [PARAMETER]  String  name  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  required  =  true;	[BUGGY]  OptionBuilder  .  required  =  false  ;  [FE]  null  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  public  static  OptionBuilder  isRequired  (  )  {  [ATTENTION]  OptionBuilder  .  required  =  false  ;    return  instance  ;  }    [METHOD]  isRequired  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  isRequired  (  )  {  OptionBuilder  .  required  =  true  ;    [ATTENTION]  return  option  ;  }    [METHOD]  isRequired  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  valuesep  =  sep;	[BUGGY]  OptionBuilder  .  valuesep  =  '  =  '  ;    ;  [FE]  AssertionFailedError    expected:<file1[:file2:file3]>  but  was:<file1[]>  assertEquals(  values[0]  ,   "JAVA_HOME "  )  ;  assertEquals(  values[1]  ,   "/opt/java "  )  ;  assertEquals(  values[0]  ,   "file1 "  )  ;  assertEquals(  values[1]  ,   "file2 "  )  ;  assertEquals(  values[2]  ,   "file3 "  )  ;  assertEquals(  opt.getValue(  0  )  ,   "JAVA_HOME "  )  ;  assertEquals(  opt.getValue(  1  )  ,   "/opt/java "  )  ;  assertEquals(  opt.getValue(  0  )  ,   "file1 "  )  ;  assertEquals(  opt.getValue(  1  )  ,   "file2 "  )  ;  assertEquals(  opt.getValue(  2  )  ,   "file3 "  )  ;  [CONTEXT]  public  static  OptionBuilder  withValueSeparator  (  char  sep  )  {  [ATTENTION]  OptionBuilder  .  valuesep  =  '  =  '  ;    ;    return  instance  ;  }    [METHOD]  withValueSeparator  [TYPE]  OptionBuilder  [PARAMETER]  char  sep  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withValueSeparator  (  char  sep  )  {  OptionBuilder  .  valuesep  =  sep  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withValueSeparator  [TYPE]  OptionBuilder  [PARAMETER]  char  sep  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  valuesep  =  '=';	[BUGGY]  OptionBuilder  .  valuesep  =  sep  ;    ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  public  static  OptionBuilder  withValueSeparator  (  )  {  [ATTENTION]  OptionBuilder  .  valuesep  =  sep  ;    ;    return  instance  ;  }    [METHOD]  withValueSeparator  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[ADD]  OptionBuilder  .  valuesep  =  '=';	[BUGGY]  [FE]  AssertionFailedError    expected:<property[]>  but  was:<property[  =  value]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  OptionBuilder  withValueSeparator  (  )  {  [ATTENTION]    return  instance  ;  }    [METHOD]  withValueSeparator  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withValueSeparator  (  )  {  OptionBuilder  .  valuesep  =  '  =  '  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withValueSeparator  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  required  =  newRequired;	[BUGGY]  OptionBuilder  .  required  =  true  ;    ;  [FE]  d  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue( "a "))  ;  assertEquals( "flag  a "  ,   "foo "  ,  line.getOptionValue('a'))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject( "a "))  ;  assertEquals( "string  flag  a "  ,   "foo "  ,  line.getOptionObject('a'))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject( "b "))  ;  assertEquals( "object  flag  b "  ,  new  java.util.Vector()  ,  line.getOptionObject('b'))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption( "c "))  ;  assertEquals( "boolean  true  flag  c "  ,  true  ,  line.hasOption('c'))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption( "d "))  ;  assertEquals( "boolean  false  flag  d "  ,  false  ,  line.hasOption('d'))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject( "e "))  ;  assertEquals( "file  flag  e "  ,  new  java.io.File( "build.xml ")  ,  line.getOptionObject('e'))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject( "f "))  ;  assertEquals( "class  flag  f "  ,  java.util.Calendar.class  ,  line.getOptionObject('f'))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject( "n "))  ;  assertEquals( "number  flag  n "  ,  new  Float(4.5)  ,  line.getOptionObject('n'))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject( "t "))  ;  assertEquals( "url  flag  t "  ,  new  java.net.URL( "http://jakarta.apache.org/ ")  ,  line.getOptionObject('t'))  ;  //      assertEquals( "number  flag  t "  ,  new  java.util.Date(1023400137276L)  ,  line.getOptionObject('z'))  ;  [CONTEXT]  public  static  OptionBuilder  isRequired  (  boolean  newRequired  )  {  [ATTENTION]  OptionBuilder  .  required  =  true  ;    ;    return  instance  ;  }    [METHOD]  isRequired  [TYPE]  OptionBuilder  [PARAMETER]  boolean  newRequired  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  isRequired  (  boolean  newRequired  )  {  OptionBuilder  .  required  =  newRequired  ;    [ATTENTION]  return  option  ;  }    [METHOD]  isRequired  [TYPE]  OptionBuilder  [PARAMETER]  boolean  newRequired  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES;	[BUGGY]  OptionBuilder  .  numberOfArgs    =    OptionBuilder  .  numberOfArgs  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  OptionBuilder  hasArgs  (  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  OptionBuilder  .  numberOfArgs  ;    return  instance  ;  }    [METHOD]  hasArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasArgs  (  )  {  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  num;	[BUGGY]  OptionBuilder  .  numberOfArgs  =  numArgs  ;    ;  [CE]  cannot  find  symbol  numArgs  [CONTEXT]  public  static  OptionBuilder  hasArgs  (  int  num  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  numArgs  ;    ;    return  instance  ;  }    [METHOD]  hasArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  num  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[ADD]  OptionBuilder  .  numberOfArgs  =  num;	[BUGGY]  [FE]  AssertionFailedError    expected:<2>  but  was:<-1>  assertEquals(  2  ,  opt.getArgs()  )  ;  [CONTEXT]  public  static  OptionBuilder  hasArgs  (  int  num  )  {  [ATTENTION]    return  instance  ;  }    [METHOD]  hasArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  num  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasArgs  (  int  num  )  {  OptionBuilder  .  numberOfArgs  =  num  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  num  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  1;	[BUGGY]  OptionBuilder  .  numberOfArgs  =  1  <<  3  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArg  (  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  1  <<  3  ;  OptionBuilder  .  optionalArg  =  true  ;    return  instance  ;  }    [METHOD]  hasOptionalArg  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  OptionBuilder  .  optionalArg  =  true;	[BUGGY]  OptionBuilder  .  optionalArg  =  false  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArg  (  )  {  OptionBuilder  .  numberOfArgs  =  1  ;  [ATTENTION]  OptionBuilder  .  optionalArg  =  false  ;    return  instance  ;  }    [METHOD]  hasOptionalArg  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasOptionalArg  (  )  {  OptionBuilder  .  numberOfArgs  =  1  ;  OptionBuilder  .  optionalArg  =  true  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasOptionalArg  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES;	[BUGGY]  OptionBuilder  .  numberOfArgs  ;  [CE]  not  a  statement  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  ;  OptionBuilder  .  optionalArg  =  true  ;    return  instance  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  OptionBuilder  .  optionalArg  =  true;	[BUGGY]  OptionBuilder  .  optionalArg  =  false  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  )  {  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES  ;  [ATTENTION]  OptionBuilder  .  optionalArg  =  false  ;    return  instance  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[ADD]  OptionBuilder  .  optionalArg  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  )  {  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES  ;  [ATTENTION]    return  instance  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  )  {  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES  ;  OptionBuilder  .  optionalArg  =  true  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numberOfArgs  
[REPLACE]  OptionBuilder  .  numberOfArgs  =  numArgs;	[BUGGY]  OptionBuilder  .  numberOfArgs  =  num  ;    ;  [CE]  cannot  find  symbol  num  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  int  numArgs  )  {  [ATTENTION]  OptionBuilder  .  numberOfArgs  =  num  ;    ;  OptionBuilder  .  optionalArg  =  true  ;    return  instance  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  numArgs  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  OptionBuilder  .  optionalArg  =  true;	[BUGGY]  OptionBuilder  .  optionalArg  =  false  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  int  numArgs  )  {  OptionBuilder  .  numberOfArgs  =  numArgs  ;  [ATTENTION]  OptionBuilder  .  optionalArg  =  false  ;    return  instance  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  numArgs  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [NO-ERROR]  [CONTEXT]  public  static  OptionBuilder  hasOptionalArgs  (  int  numArgs  )  {  OptionBuilder  .  numberOfArgs  =  numArgs  ;  OptionBuilder  .  optionalArg  =  true  ;    [ATTENTION]  return  option  ;  }    [METHOD]  hasOptionalArgs  [TYPE]  OptionBuilder  [PARAMETER]  int  numArgs  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  OptionBuilder  .  type  =  newType;	[BUGGY]  OptionBuilder  .  type  =    null  ;  [FE]  null  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  public  static  OptionBuilder  withType  (  Object  newType  )  {  [ATTENTION]  OptionBuilder  .  type  =  null  ;    return  instance  ;  }    [METHOD]  withType  [TYPE]  OptionBuilder  [PARAMETER]  Object  newType  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withType  (  Object  newType  )  {  OptionBuilder  .  type  =  newType  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withType  [TYPE]  OptionBuilder  [PARAMETER]  Object  newType  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  OptionBuilder  .  description  =  newDescription;	[BUGGY]  OptionBuilder  .  description  =    newLongopt  ;  [CE]  cannot  find  symbol  newLongopt  [CONTEXT]  public  static  OptionBuilder  withDescription  (  String  newDescription  )  {  [ATTENTION]  OptionBuilder  .  description  =  newLongopt  ;    return  instance  ;  }    [METHOD]  withDescription  [TYPE]  OptionBuilder  [PARAMETER]  String  newDescription  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  instance;	[BUGGY]  return  option  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  OptionBuilder  withDescription  (  String  newDescription  )  {  OptionBuilder  .  description  =  newDescription  ;    [ATTENTION]  return  option  ;  }    [METHOD]  withDescription  [TYPE]  OptionBuilder  [PARAMETER]  String  newDescription  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  create  (  String  .  valueOf  (  opt  )  )  ;	[BUGGY]  return  create  (  null  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  -Dproperty  =  value  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  create  (  char  opt  )  throws  IllegalArgumentException  {  [ATTENTION]  return  create  (  null  )    ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  char  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  if  (  longopt  ==  null  )  {	[BUGGY]  if  (  longopt  !  =  newLongopt  )  {[CE]  cannot  find  symbol  newLongopt  [CONTEXT]  public  static  Option  create  (  )  throws  IllegalArgumentException  {  [ATTENTION]  if  (  longopt  !  =  newLongopt  )  {  throw  new  IllegalArgumentException  (   "must  specify  longopt "  )  ;  }  return  create  (  null  )  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  static  Option  create  (  )  throws  IllegalArgumentException  {  if  (  longopt  =  =  null  )  {  [ATTENTION]  return  ;  }  return  create  (  null  )  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  Option  create  (  )  throws  IllegalArgumentException  {  if  (  longopt  =  =  null  )  {  [ATTENTION]  }  return  create  (  null  )  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  create  (  null  )  ;	[BUGGY]  return  create  (  false  )  ;  [CE]  no  suitable  method  found  for  create(boolean)  [CONTEXT]  public  static  Option  create  (  )  throws  IllegalArgumentException  {  if  (  longopt  =  =  null  )  {  throw  new  IllegalArgumentException  (   "must  specify  longopt "  )  ;  }  [ATTENTION]  return  create  (  false  )    ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  Option  option  =  new  Option  (  opt,  description  )  ;	[BUGGY]  Option  newLongoption  =  new  Option  (  opt  ,  description  )  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    [ATTENTION]  Option  newLongoption  =  new  Option  (  opt  ,  description  )    ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[ADD]  Option  option  =  new  Option  (  opt,  description  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    [ATTENTION]      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setLongOpt  (  longopt  )  ;	[BUGGY]  option  .  setArgName  (  longopt  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  --block-size  assertTrue(  line.hasOption(   "block-size "  )  )  ;  assertEquals(  line.getOptionValue(   "block-size "  )  ,   "10 "  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      [ATTENTION]  option  .  setArgName  (  longopt  )    ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setRequired  (  required  )  ;	[BUGGY]  option  .  setOptionalArg  (  required  )  ;  [FE]  null  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  [ATTENTION]  option  .  setOptionalArg  (  required  )    ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setOptionalArg  (  optionalArg  )  ;	[BUGGY]  option  .  setRequired  (  optionalArg  )  ;  [FE]  Unexpected  Exception:  Missing  argument  for  option:a  assertEquals(  cmd.getOptionValue(  'b'  )  ,   "value "  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  [ATTENTION]  option  .  setRequired  (  optionalArg  )    ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setArgs  (  numberOfArgs  )  ;	[BUGGY]  option  .  setRequired  (  numberOfArgs  )  ;  [CE]  method  setRequired  in  class  Option  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  [ATTENTION]  option  .  setRequired  (  numberOfArgs  )    ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setType  (  type  )  ;	[BUGGY]  option  .  setArgs  (  num  )    ;  [CE]  cannot  find  symbol  num  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  [ATTENTION]  option  .  setArgs  (  num  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[ADD]  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;	[BUGGY]  option  .  setValueSeparator  (  valuesep  )  ;  [FE]  null  assertEquals(   "s "  ,  simple.getOpt()  )  ;  assertEquals(   "simple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  simple  option "  ,  simple.getDescription()  )  ;  assertEquals(  simple.getType().getClass()  ,  Float.class  )  ;  assertTrue(  simple.hasArg()  )  ;  assertTrue(  simple.isRequired()  )  ;  assertTrue(  simple.hasArgs()  )  ;  assertEquals(   "d "  ,  simple.getOpt()  )  ;  assertEquals(   "dimple  option "  ,  simple.getLongOpt()  )  ;  assertEquals(   "this  is  a  dimple  option "  ,  simple.getDescription()  )  ;  assertNull(  simple.getType()  )  ;  assertTrue(  !simple.isRequired()  )  ;  assertTrue(  !simple.hasArgs()  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  [ATTENTION]  option  .  setValueSeparator  (  valuesep  )    ;    option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setValueSeparator  (  valuesep  )  ;	[BUGGY]  option  .  setRequired  (  valuesep  )  ;  [CE]  method  setRequired  in  class  Option  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  [ATTENTION]  option  .  setRequired  (  valuesep  )    ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[ADD]  option  .  setValueSeparator  (  valuesep  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<property[]>  but  was:<property[  =  value]>  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  [ATTENTION]  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  option  .  setArgName  (  argName  )  ;	[BUGGY]  option  .  setLongOpt  (  argName  )  ;  [FE]  Unexpected  exception:Unrecognized  option:  --block-size  assertTrue(  line.hasOption(   "block-size "  )  )  ;  assertEquals(  line.getOptionValue(   "block-size "  )  ,   "10 "  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  [ATTENTION]  option  .  setLongOpt  (  argName  )    ;      OptionBuilder  .  reset  (  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  OptionBuilder  .  reset  (  )  ;	[BUGGY]  OptionBuilder  .  create  (  opt  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      [ATTENTION]  OptionBuilder  .  create  (  opt  )  ;      return  option  ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  return  option;	[BUGGY]  return  create  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {    Option  option  =  new  Option  (  opt  ,  description  )  ;      option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;      OptionBuilder  .  reset  (  )  ;      [ATTENTION]  return  create  (  null  )    ;  }    [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder    [TYPE]  boolean  false  hasArg  newRequired  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  opt  sep  valuesep  [TYPE]  Object  newType  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  name  newDescription  newLongopt  opt  [TYPE]  int  num  numArgs  numberOfArgs  
[REPLACE]  if  (  str  .  startsWith  (   "-- "  )  )  {	[BUGGY]  if  (  str  .  endsWith  (   "\ " "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  [ATTENTION]  if  (  str  .  endsWith  (   "\ " "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  else  if  (  str  .  startsWith  (   "- "  )  )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[ADD]  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2,  str  .  length  (  )  )  ;  }	[BUGGY]  [CE]  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  [ATTENTION]      else  if  (  str  .  startsWith  (   "- "  )  )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  else  if  (  str  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  if  (  str  .  endsWith  (  str  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  [ATTENTION]  else  if  (  str  .  endsWith  (  str  )    )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  str  .  substring  (  1,  str  .  length  (  )  )  ;	[BUGGY]  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  else  if  (  str  .  startsWith  (   "- "  )  )  {  [ATTENTION]  return  str  .  substring  (  2  ,  str  .  length  (  )  )    ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  str  .  substring  (  1,  str  .  length  (  )  )  ;	[BUGGY]  return  str  .  substring  (  0  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  else  if  (  str  .  startsWith  (   "- "  )  )  {  [ATTENTION]  return  str  .  substring  (  0  ,  str  .  length  (  )  )    ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  str  .  substring  (  2,  str  .  length  (  )  )  ;	[BUGGY]  return  str  .  substring  (  0  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  [ATTENTION]  return  str  .  substring  (  0  ,  str  .  length  (  )  )    ;  }  else  if  (  str  .  startsWith  (   "- "  )  )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  else  if  (  str  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  str  .  endsWith  (  str  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  [ATTENTION]  if  (  str  .  endsWith  (  str  )    )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  str;	[BUGGY]  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  if  (  str  .  startsWith  (   "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  else  if  (  str  .  startsWith  (   "- "  )  )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  [ATTENTION]  return  str  .  substring  (  1  ,  str  .  length  (  )  )    ;  }    [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  if  (  str  .  startsWith  (   "\ " "  )  )  {	[BUGGY]  if  (  str  .  endsWith  (   "\ " "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  [ATTENTION]  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  str  =  str  .  substring  (  1,  str  .  length  (  )  )  ;	[BUGGY]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  [ATTENTION]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  )    ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  str  =  str  .  substring  (  1,  str  .  length  (  )  )  ;	[BUGGY]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  [ATTENTION]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )    ;    ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  if  (  str  .  endsWith  (   "\ " "  )  )  {	[BUGGY]  if  (  str  .  startsWith  (   "-- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  [ATTENTION]  if  (  str  .  startsWith  (   "-- "  )  )  {  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ;	[BUGGY]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  *  0  .  5  -1  )  ;  [CE]  no  suitable  method  found  for  substring(int  ,  double)  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  [ATTENTION]  str  =  str  .  substring  (  0  ,  str  .  length  (  )  *0  .  5  -1  )    ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ;	[BUGGY]  str  =  str  .  substring  (  0  ,  str  .  size  (  )  -1  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  [ATTENTION]  str  =  str  .  substring  (  0  ,  str  .  size  (  )  -1  )    ;  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[ADD]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  [ATTENTION]  }  return  str  ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  str;	[BUGGY]  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  0  ,  str  .  length  (  )  -1  )  ;  }  [ATTENTION]  return  str  .  substring  (  1  ,  str  .  length  (  )  )    ;  }    [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  public  static  final  Class  STRING_VALUE  =  java  .  lang  .  String  .  class;	[BUGGY]  public  static  final  Class  STRING_VALUE  ;  [CE]  variable  STRING_VALUE  might  not  have  been  initialized  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  OBJECT_VALUE  =  java  .  lang  .  Object  .  class;	[BUGGY]  public  static  final  Class  OBJECT_VALUE    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  NUMBER_VALUE  =  java  .  lang  .  Number  .  class;	[BUGGY]  public  static  final  Class  NUMBER_VALUE    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  DATE_VALUE  =  java  .  util  .  Date  .  class;	[BUGGY]  public  static  final  Class  DATE_VALUE  ;  [CE]  variable  DATE_VALUE  might  not  have  been  initialized  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  CLASS_VALUE  =  java  .  lang  .  Class  .  class;	[BUGGY]  public  static  Class  CLASS_VALUE  =  java  .  lang  .  Class  .  class  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  EXISTING_FILE_VALUE  =  java  .  io  .  FileInputStream  .  class;	[BUGGY]  public  final  Class  EXISTING_FILE_VALUE  =  java  .  io  .  FileInputStream  .  class  ;  [CE]  non-static  variable  EXISTING_FILE_VALUE  cannot  be  referenced  from  a  static  context  [CONTEXT]  [ATTENTION]  publicfinal  Class  EXISTING_FILE_VALUE  =  java  .  io  .  FileInputStream  .  class  ;        [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  FILE_VALUE  =  java  .  io  .  File  .  class;	[BUGGY]  public  final  Class  FILE_VALUE  =  java  .  io  .  File  .  class  ;  [CE]  non-static  variable  FILE_VALUE  cannot  be  referenced  from  a  static  context  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  FILES_VALUE  =  java  .  io  .  File[]  .  class;	[BUGGY]  public  static  final  Class  FILES_VALUE    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  public  static  final  Class  URL_VALUE  =  java  .  net  .  URL  .  class;	[BUGGY]  public  static  final  Class  URL_VALUE  ;  [CE]  variable  URL_VALUE  might  not  have  been  initialized  [CONTEXT]      [CLASS]  PatternOptionBuilder  
[REPLACE]  if  (  ch  ==  '@'  )  {	[BUGGY]  if  (  ch  ||  '@'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  [ATTENTION]  if  (  ch||'@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  ':'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '%'  )  {	[BUGGY]  else  if  (  ch  !  =    '%'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '+'  )  {	[BUGGY]  else  if  (  ch  ||  '+'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  else  if  (  ch  ||  '<'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  else  if  (  ch  &&  '*'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch&&'*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '>'  )  {      return  FILE_VALUE  ;  }else      if  (  ch  =  =  '*'  )  {          return  FILES_VALUE  ;      }else          if  (  ch  =  =  '/'  )  {              return  URL_VALUE  ;          }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '*'  )    if  (  ch  =  =  '>'  )  {  return  FILE_VALUE  ;  }else  if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  if  (  ch  &&  '/'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  if  (  ch&&'/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  URL_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '/'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  URL_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  FILES_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '*'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  else  {[CE]  unreachable  statement  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  FILES_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  FILE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '>'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  if  (  ch  ||  '*'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  if  (  ch||'*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]      return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  if  (  ch  ||  '/'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  if  (  ch||'/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  FILE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  STRING_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '<'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  if  (  ch  ||  '>'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  if  (  ch||'>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  if  (  ch  &&  '*'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  if  (  ch&&'*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  else  if  (  ch  &&  '/'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  else  if  (  ch&&'/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  STRING_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  DATE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '#'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '*'  )  {      return  FILES_VALUE  ;  }else      if  (  ch  =  =  '/'  )  {          return  URL_VALUE  ;      }[CE]  unreachable  statement  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '/'  )    if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  if  (  ch  !  =    '/'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  if  (  ch!  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  else  if  (  ch  !  =    '/'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  DATE_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  CLASS_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  FILES_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '+'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  if  (  ch  !  =    '*'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  if  (  ch!  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  else  if  (  ch  &&  '<'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  else  if  (  ch&&'<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  else  if  (  ch  !  =    '*'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '/'  )  {	[BUGGY]  else  if  (  ch  ||  '/'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  CLASS_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  FILES_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  NUMBER_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '%'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '+'  )  {	[BUGGY]  if  (  ch  &&  '+'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  [ATTENTION]  if  (  ch&&'+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '+'  )  {      return  CLASS_VALUE  ;  }else      if  (  ch  =  =  '#'  )  {          return  DATE_VALUE  ;      }else          if  (  ch  =  =  '<'  )  {              return  EXISTING_FILE_VALUE  ;          }else              if  (  ch  =  =  '>'  )  {                  return  FILE_VALUE  ;              }else                  if  (  ch  =  =  '*'  )  {                      return  FILES_VALUE  ;                  }else                      if  (  ch  =  =  '/'  )  {                          return  URL_VALUE  ;                      }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '#'  )    if  (  ch  =  =  '+'  )  {  return  CLASS_VALUE  ;  }else  if  (  ch  =  =  '#'  )  {  return  DATE_VALUE  ;  }else  if  (  ch  =  =  '<'  )  {  return  EXISTING_FILE_VALUE  ;  }else  if  (  ch  =  =  '>'  )  {  return  FILE_VALUE  ;  }else  if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  if  (  ch  &&  '<'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  if  (  ch&&'<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  if  (  ch  !  =    '>'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  if  (  ch!  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '*'  )  {	[BUGGY]  else  if  (  ch  ||  '*'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  if  (  ch  ||  '<'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  if  (  ch||'<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  if  (  ch  &&  '>'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  if  (  ch&&'>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  else  if  (  ch  &&  '#'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  else  if  (  ch&&'#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  NUMBER_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  STRING_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  ':'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '%'  )  {	[BUGGY]  if  (  ch  ||  '%'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  [ATTENTION]  if  (  ch||'%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '+'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  else  if  (  ch  !  =    '#'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  else  if  (  ch  !  =    '<'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '*'  )  {      return  FILES_VALUE  ;  }else      if  (  ch  =  =  '/'  )  {          return  URL_VALUE  ;      }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '>'  )    if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  if  (  ch  !  =    '#'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  if  (  ch!  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '*'  )  {      return  FILES_VALUE  ;  }else      if  (  ch  =  =  '/'  )  {          return  URL_VALUE  ;      }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '<'  )    if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  else  if  (  ch  ||  '>'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  else  if  (  ch  !  =    '>'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch!  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  if  (  ch  ||  '#'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  if  (  ch||'#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  STRING_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  OBJECT_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  ch  =  =  '@'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  ':'  )  {	[BUGGY]  if  (  ch  ||  ':'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  [ATTENTION]  if  (  ch||':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '%'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  [ATTENTION]  else  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[ADD]  else  if  (  ch  ==  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  [ATTENTION]      else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  else  if  (  ch  ||  '#'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '>'  )  {	[BUGGY]  else  if  (  ch  &&  '>'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  [ATTENTION]  else  if  (  ch&&'>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '<'  )  {	[BUGGY]  if  (  ch  !  =    '<'  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  [ATTENTION]  if  (  ch!  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '%'  )  {	[BUGGY]  else  if  (  ch  ||  '%'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  [ATTENTION]  else  if  (  ch||'%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  else  if  (  ch  ==  '#'  )  {	[BUGGY]  if  (  ch  &&  '#'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  [ATTENTION]  if  (  ch&&'#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '#'  )  {      return  DATE_VALUE  ;  }else      if  (  ch  =  =  '<'  )  {          return  EXISTING_FILE_VALUE  ;      }else          if  (  ch  =  =  '>'  )  {              return  FILE_VALUE  ;          }else              if  (  ch  =  =  '*'  )  {                  return  FILES_VALUE  ;              }else                  if  (  ch  =  =  '/'  )  {                      return  URL_VALUE  ;                  }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  [ATTENTION]  else  if  (  ch  =  =  '+'  )    if  (  ch  =  =  '#'  )  {  return  DATE_VALUE  ;  }else  if  (  ch  =  =  '<'  )  {  return  EXISTING_FILE_VALUE  ;  }else  if  (  ch  =  =  '>'  )  {  return  FILE_VALUE  ;  }else  if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;      [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  PatternOptionBuilder  .  OBJECT_VALUE;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  return  null  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  ch  =  =  '@'  )  {  return  PatternOptionBuilder  .  OBJECT_VALUE  ;  }  else  if  (  ch  =  =  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE  ;  }  else  if  (  ch  =  =  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE  ;  }  else  if  (  ch  =  =  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }  else  if  (  ch  =  =  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE  ;  }  else  if  (  ch  =  =  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ;  }  else  if  (  ch  =  =  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE  ;  }  else  if  (  ch  =  =  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE  ;  }  else  if  (  ch  =  =  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  getValueClass  [TYPE]  Object  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  if  (  (  ch  !=  '@'  )  &&  (  ch  !=  ':'  )  &&  (  ch  !=  '%'  )  &&  (  ch  !=  '+'  )  &&  (  ch  !=  '#'  )  &&  (  ch  !=  '<'  )  &&  (  ch  !=  '>'  )  &&  (  ch  !=  '*'  )  &&  (  ch  !=  '/'  )  &&  (  ch  !=  '!'  )  )  {	[BUGGY]  if  (  (  ch  !  =  '@'  )  ||  (  ch  !  =  ':'  )  ||  (  ch  !  =  '%'  )  ||  (  ch  !  =  '+'  )  ||  (  ch  !  =  '#'  )  ||  (  ch  !  =  '<'  )  ||  (  ch  !  =  '>'  )  ||  (  ch  !  =  '*'  )  ||  (  ch  !  =  '/'  )  ||  (  ch  !  =  '!'  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  boolean  isValueCode  (  char  ch  )  {  [ATTENTION]  if  (  (  ch  !  =  '@'  )  ||  (  ch  !  =  ':'  )  ||  (  ch  !  =  '%'  )  ||  (  ch  !  =  '+'  )  ||  (  ch  !  =  '#'  )  ||  (  ch  !  =  '<'  )  ||  (  ch  !  =  '>'  )  ||  (  ch  !  =  '*'  )  ||  (  ch  !  =  '/'  )  ||  (  ch  !  =  '!'  )  )  {    return  false  ;  }  return  true  ;  }    [METHOD]  isValueCode  [TYPE]  boolean  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  boolean  isValueCode  (  char  ch  )  {  if  (  (  ch  !  =  '@'  )  &&  (  ch  !  =  ':'  )  &&  (  ch  !  =  '%'  )  &&  (  ch  !  =  '+'  )  &&  (  ch  !  =  '#'  )  &&  (  ch  !  =  '<'  )  &&  (  ch  !  =  '>'  )  &&  (  ch  !  =  '*'  )  &&  (  ch  !  =  '/'  )  &&  (  ch  !  =  '!'  )  )  {  [ATTENTION]  return  true  ;  }  return  true  ;  }    [METHOD]  isValueCode  [TYPE]  boolean  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  boolean  isValueCode  (  char  ch  )  {  if  (  (  ch  !  =  '@'  )  &&  (  ch  !  =  ':'  )  &&  (  ch  !  =  '%'  )  &&  (  ch  !  =  '+'  )  &&  (  ch  !  =  '#'  )  &&  (  ch  !  =  '<'  )  &&  (  ch  !  =  '>'  )  &&  (  ch  !  =  '*'  )  &&  (  ch  !  =  '/'  )  &&  (  ch  !  =  '!'  )  )  {  return  false  ;  }  [ATTENTION]  return  false  ;  }    [METHOD]  isValueCode  [TYPE]  boolean  [PARAMETER]  char  ch  [CLASS]  PatternOptionBuilder    [TYPE]  char  ch  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  boolean  false  true  
[REPLACE]  int  sz  =  pattern  .  length  (  )  ;	[BUGGY]  Options  options  =  new  Options  (  )  ;  [CE]  variable  options  is  already  defined  in  method  parsePattern(String)  [CONTEXT]  {  [ATTENTION]  Options  options  =  new  Options  (  )    ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  char  opt  =  '  ';	[BUGGY]  char  ch  =  '  '  ;  [CE]  variable  ch  is  already  defined  in  method  parsePattern(String)  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    [ATTENTION]  char  ch  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  char  ch  =  '  ';	[BUGGY]  char  opt  =  '  '  ;  [CE]  variable  opt  is  already  defined  in  method  parsePattern(String)  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  [ATTENTION]  char  opt  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  char  ch  =  '  ';	[BUGGY]  [CE]  cannot  find  symbol  ch  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  [ATTENTION]  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  boolean  required  =  false;	[BUGGY]  boolean  required  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  [ATTENTION]  boolean  required  =  true  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  Object  type  =  null;	[BUGGY]  Object  type  =  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  [ATTENTION]  Object  type  =  this  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  Options  options  =  new  Options  (  )  ;	[BUGGY]  int  sz  =  pattern  .  length  (  )  ;  [CE]  variable  sz  is  already  defined  in  method  parsePattern(String)  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    [ATTENTION]  int  sz  =  pattern  .  length  (  )    ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  !isValueCode  (  ch  )  )  {	[BUGGY]  if  (  isValueCode  (  ch  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        [ATTENTION]  if  (  isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REMOVE]  	[BUGGY]  if  (  ch  =  =  '+'  )  {      return  CLASS_VALUE  ;  }else      if  (  ch  =  =  '#'  )  {          return  DATE_VALUE  ;      }else          if  (  ch  =  =  '<'  )  {              return  EXISTING_FILE_VALUE  ;          }else              if  (  ch  =  =  '>'  )  {                  return  FILE_VALUE  ;              }else                  if  (  ch  =  =  '*'  )  {                      return  FILES_VALUE  ;                  }else                      if  (  ch  =  =  '/'  )  {                          return  URL_VALUE  ;                      }[CE]  'else'  without  'if'  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        [ATTENTION]  if  (  !isValueCode  (  ch  )  )    if  (  ch  =  =  '+'  )  {  return  CLASS_VALUE  ;  }else  if  (  ch  =  =  '#'  )  {  return  DATE_VALUE  ;  }else  if  (  ch  =  =  '<'  )  {  return  EXISTING_FILE_VALUE  ;  }else  if  (  ch  =  =  '>'  )  {  return  FILE_VALUE  ;  }else  if  (  ch  =  =  '*'  )  {  return  FILES_VALUE  ;  }else  if  (  ch  =  =  '/'  )  {  return  URL_VALUE  ;  }{  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;      [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  else  if  (  ch  ==  '!'  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  [ATTENTION]  else  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  getValueClass  (  ch  )  ;	[BUGGY]  type  =    getValueClass  (  null  )  ;  [CE]  method  getValueClass  in  class  PatternOptionBuilder  cannot  be  applied  to  given  types  ;  [CONTEXT]  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  [ATTENTION]  type  =  getValueClass  (  null  )    ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  true;	[BUGGY]  required  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  ch  =  =  '!'  )  {  [ATTENTION]  required  =  false  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  true;	[BUGGY]  required  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  [ATTENTION]  required  =  false  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  getValueClass  (  ch  )  ;	[BUGGY]  type  =    getValueClass  (  null  )  ;  [CE]  method  getValueClass  in  class  PatternOptionBuilder  cannot  be  applied  to  given  types  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  [ATTENTION]  type  =  getValueClass  (  null  )    ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  opt  !=  '  '  )  {	[BUGGY]  if  (  opt    =  =    '  '  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  [ATTENTION]  if  (  opt  =  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  required  =  true  ;    ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  required  =  false;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  this  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  '  ';	[BUGGY]  opt    =    opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  [ATTENTION]  opt  =  opt  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  required  =  true  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  false  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  ch;	[BUGGY]  opt  =    null  ;  [CE]  incompatible  types  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  [ATTENTION]  opt  =  null  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  opt  =  ch;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  [ATTENTION]  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  opt  !=  '  '  )  {	[BUGGY]  if  (  opt    =  =    '  '  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  [ATTENTION]  if  (  opt  =  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  required  =  true  ;  type  =  null  ;  opt  =  '  '  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  this  ;  opt  =  '  '  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  type  =  null;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  opt  =  '  '  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  '  ';	[BUGGY]  opt    =  null  ;  [CE]  incompatible  types  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  [ATTENTION]  opt  =  null  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  else  if  (  ch  ==  '!'  )  {	[BUGGY]  if  (  ch  =  =  ''  )  {[CE]  empty  character  literal  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  [ATTENTION]  if  (  ch  =  =  ''  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  for  (  int  i  =  0;  i  <  sz;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  !  =    sz  ;  i++  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i!  =  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  !isValueCode  (  ch  )  )  {	[BUGGY]  if  (  isValueCode  (  ch  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        [ATTENTION]  if  (  isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !=  '  '  )  {  OptionBuilder  .  hasArg  (  type  !=  null  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        [ATTENTION]      OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  else  if  (  ch  ==  '!'  )  {	[BUGGY]  if  (  ch  =  =  ''  )  {[CE]  empty  character  literal  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  [ATTENTION]  if  (  ch  =  =  ''  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  else  if  (  ch  ==  '!'  )  {  required  =  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  [ATTENTION]      else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  true;	[BUGGY]  required  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  [ATTENTION]  required  =  false  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  getValueClass  (  ch  )  ;	[BUGGY]  type  =    getValueClass  (  null  )  ;  [CE]  method  getValueClass  in  class  PatternOptionBuilder  cannot  be  applied  to  given  types  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  [ATTENTION]  type  =  getValueClass  (  null  )    ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  required  =  false;  type  =  null;	[BUGGY]  type  =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  type  =  null  ;    opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  type  =  null;  opt  =  '  ';	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]    }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  true  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  opt  !=  '  '  )  {	[BUGGY]  if  (  opt    =  =    '  '  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  [ATTENTION]  if  (  opt  =  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  true  ;  opt  =  '  '  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  ch  =  pattern  .  charAt  (  i  )  ;	[BUGGY]  ch  =    null  .  charAt  (  i  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  [ATTENTION]  ch  =  null  .  charAt  (  i  )    ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  required  =  true  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  this  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  '  ';	[BUGGY]  opt    =    opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  [ATTENTION]  opt  =  opt  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  ch;	[BUGGY]  opt  =    null  ;  [CE]  incompatible  types  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  [ATTENTION]  opt  =  null  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  required  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  [ATTENTION]  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[ADD]  type  =  getValueClass  (  ch  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  [ATTENTION]  }  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  ch  =  pattern  .  charAt  (  i  )  ;	[BUGGY]  ch  =    null  .  charAt  (  i  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  [ATTENTION]  ch  =  null  .  charAt  (  i  )    ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  required  =  false;	[BUGGY]  required  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  [ATTENTION]  required  =  true  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  type  =  null;	[BUGGY]  type  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  [ATTENTION]  type  =  false  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  '  ';	[BUGGY]  opt  ;  [CE]  not  a  statement  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  [ATTENTION]  opt  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  opt  =  ch;	[BUGGY]  opt  =    null  ;  [CE]  incompatible  types  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  [ATTENTION]  opt  =  null  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  for  (  int  i  =  0;  i  <  sz;  i++  )  {	[BUGGY]  for  (  int  i  =  0L  ;  i  <  sz  ;  i++  )  {[CE]  possible  loss  of  precision  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    [ATTENTION]  for  (  int  i  =  0L  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  if  (  opt  !=  '  '  )  {	[BUGGY]  if  (  opt    =  =    '  '  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  [ATTENTION]  if  (  opt  =  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  return  options  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  OptionBuilder  .  hasArg  (  type  !=  null  )  ;	[BUGGY]  OptionBuilder  .  hasArg  (  type  =  =  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  [ATTENTION]  OptionBuilder  .  hasArg  (  type  =  =  null  )    ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  OptionBuilder  .  isRequired  (  required  )  ;	[BUGGY]  OptionBuilder  .  isRequired  (  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  [ATTENTION]  OptionBuilder  .  isRequired  (  true  )    ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REMOVE]  	[BUGGY]  OptionBuilder  .  withType  (  type  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  [ATTENTION]  OptionBuilder  .  isRequired  (  required  )  ;    OptionBuilder  .  withType  (  type  )    ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;      [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  OptionBuilder  .  withType  (  type  )  ;	[BUGGY]  OptionBuilder  .  create  (  ch  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  [ATTENTION]  OptionBuilder  .  create  (  ch  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;	[BUGGY]  OptionBuilder  .  withType  (  type  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      [ATTENTION]  OptionBuilder  .  withType  (  type  )    ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;	[BUGGY]  options  .  addOption  (  OptionBuilder  .  hasArg  (  opt  )  )  ;  [CE]  no  suitable  method  found  for  hasArg(char)  [CONTEXT]  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      [ATTENTION]  options  .  addOption  (  OptionBuilder  .  hasArg  (  opt  )  )    ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  return  options;	[BUGGY]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  [CE]  incompatible  types  [CONTEXT]  {  int  sz  =  pattern  .  length  (  )  ;    char  opt  =  '  '  ;  char  ch  =  '  '  ;  boolean  required  =  false  ;  Object  type  =  null  ;    Options  options  =  new  Options  (  )  ;    for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  ch  =  pattern  .  charAt  (  i  )  ;        if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  required  =  false  ;  type  =  null  ;  opt  =  '  '  ;  }  opt  =  ch  ;  }  else  if  (  ch  =  =  '!'  )  {  required  =  true  ;  }  else  {  type  =  getValueClass  (  ch  )  ;  }  }  if  (  opt  !  =  '  '  )  {  OptionBuilder  .  hasArg  (  type  !  =  null  )  ;  OptionBuilder  .  isRequired  (  required  )  ;  OptionBuilder  .  withType  (  type  )  ;      options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ;  }  [ATTENTION]  return  PatternOptionBuilder  .  CLASS_VALUE  ;  }    [METHOD]  parsePattern  [TYPE]  Options  [PARAMETER]  String  pattern  [CLASS]  PatternOptionBuilder    [TYPE]  Options  options  [TYPE]  boolean  false  required  true  [TYPE]  char  ch  opt  [TYPE]  Class  CLASS_VALUE  DATE_VALUE  EXISTING_FILE_VALUE  FILES_VALUE  FILE_VALUE  NUMBER_VALUE  OBJECT_VALUE  STRING_VALUE  URL_VALUE  [TYPE]  Object  type  [TYPE]  String  pattern  [TYPE]  int  i  sz  
[REPLACE]  public  static  final  int  DEFAULT_WIDTH  =  74;	[BUGGY]  public  static  int  DEFAULT_WIDTH  =  74  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  int  DEFAULT_LEFT_PAD  =  1;	[BUGGY]  public  static  final  int  DEFAULT_LEFT_PAD    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  int  DEFAULT_DESC_PAD  =  3;	[BUGGY]  public  static  final  int  DEFAULT_DESC_PAD    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  String  DEFAULT_SYNTAX_PREFIX  =   "usage:   ";	[BUGGY]  public  static  final  String  DEFAULT_SYNTAX_PREFIX  ;  [CE]  variable  DEFAULT_SYNTAX_PREFIX  might  not  have  been  initialized  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  String  DEFAULT_OPT_PREFIX  =   "- ";	[BUGGY]  public  static  final  String  DEFAULT_OPT_PREFIX    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  String  DEFAULT_LONG_OPT_PREFIX  =   "-- ";	[BUGGY]  public  static  final  String  DEFAULT_LONG_OPT_PREFIX  ;  [CE]  variable  DEFAULT_LONG_OPT_PREFIX  might  not  have  been  initialized  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  public  static  final  String  DEFAULT_ARG_NAME  =   "arg ";	[BUGGY]  public  static    double  DEFAULT_ARG_NAME  =   "arg "  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  int  defaultWidth  =  DEFAULT_WIDTH;	[BUGGY]  private  int  defaultWidth  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  int  defaultLeftPad  =  DEFAULT_LEFT_PAD;	[BUGGY]  private  int  defaultLeftPad    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  int  defaultDescPad  =  DEFAULT_DESC_PAD;	[BUGGY]  private  int  defaultDescPad    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  String  defaultSyntaxPrefix  =  DEFAULT_SYNTAX_PREFIX;	[BUGGY]  private  String  defaultSyntaxPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  String  defaultNewLine  =  System  .  getProperty  (   "line  .  separator "  )  ;	[BUGGY]  private  String  defaultNewLine    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  String  defaultOptPrefix  =  DEFAULT_OPT_PREFIX;	[BUGGY]  private  String  defaultOptPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  String  defaultLongOptPrefix  =  DEFAULT_LONG_OPT_PREFIX;	[BUGGY]  private  String  defaultLongOptPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  private  String  defaultArgName  =  DEFAULT_ARG_NAME;	[BUGGY]  private  String  defaultArgName  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  HelpFormatter  OptionComparator  
[REPLACE]  this  .  defaultWidth  =  width;	[BUGGY]  this  .  defaultWidth  =    null  ;  [CE]  incompatible  types  [CONTEXT]  public  void  setWidth  (  int  width  )  {  [ATTENTION]  this  .  defaultWidth  =  null  ;  }    [METHOD]  setWidth  [TYPE]  void  [PARAMETER]  int  width  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[ADD]  this  .  defaultWidth  =  width;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setWidth  (  int  width  )  {  [ATTENTION]  }    [METHOD]  setWidth  [TYPE]  void  [PARAMETER]  int  width  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultWidth;	[BUGGY]  return  sb  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  int  getWidth  (  )  {  [ATTENTION]  return  sb  ;  }    [METHOD]  getWidth  [TYPE]  int  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultLeftPad  =  padding;	[BUGGY]  this  .  defaultDescPad  =  padding  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setLeftPadding  (  int  padding  )  {  [ATTENTION]  this  .  defaultDescPad  =  padding  ;    ;  }    [METHOD]  setLeftPadding  [TYPE]  void  [PARAMETER]  int  padding  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultLeftPad;	[BUGGY]  return  this  .  defaultDescPad  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  int  getLeftPadding  (  )  {  [ATTENTION]  return  this  .  defaultDescPad  ;  }    [METHOD]  getLeftPadding  [TYPE]  int  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultDescPad  =  padding;	[BUGGY]  this  .  defaultLeftPad  =  padding  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setDescPadding  (  int  padding  )  {  [ATTENTION]  this  .  defaultLeftPad  =  padding  ;    ;  }    [METHOD]  setDescPadding  [TYPE]  void  [PARAMETER]  int  padding  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[ADD]  this  .  defaultDescPad  =  padding;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setDescPadding  (  int  padding  )  {  [ATTENTION]  }    [METHOD]  setDescPadding  [TYPE]  void  [PARAMETER]  int  padding  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultDescPad;	[BUGGY]  return  this  .  defaultLeftPad  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  int  getDescPadding  (  )  {  [ATTENTION]  return  this  .  defaultLeftPad  ;  }    [METHOD]  getDescPadding  [TYPE]  int  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultSyntaxPrefix  =  prefix;	[BUGGY]  this  .  defaultLongOptPrefix  =  prefix  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setSyntaxPrefix  (  String  prefix  )  {  [ATTENTION]  this  .  defaultLongOptPrefix  =  prefix  ;    ;  }    [METHOD]  setSyntaxPrefix  [TYPE]  void  [PARAMETER]  String  prefix  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  prefix  [TYPE]  boolean  false  true  
[ADD]  this  .  defaultSyntaxPrefix  =  prefix;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setSyntaxPrefix  (  String  prefix  )  {  [ATTENTION]  }    [METHOD]  setSyntaxPrefix  [TYPE]  void  [PARAMETER]  String  prefix  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  prefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultSyntaxPrefix;	[BUGGY]  return  this  .  defaultOptPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  getSyntaxPrefix  (  )  {  [ATTENTION]  return  this  .  defaultOptPrefix  ;  }    [METHOD]  getSyntaxPrefix  [TYPE]  String  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  prefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultNewLine  =  newline;	[BUGGY]  this  .  defaultNewLine  =    prefix  ;  [CE]  cannot  find  symbol  prefix  [CONTEXT]  public  void  setNewLine  (  String  newline  )  {  [ATTENTION]  this  .  defaultNewLine  =  prefix  ;  }    [METHOD]  setNewLine  [TYPE]  void  [PARAMETER]  String  newline  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[ADD]  this  .  defaultNewLine  =  newline;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setNewLine  (  String  newline  )  {  [ATTENTION]  }    [METHOD]  setNewLine  [TYPE]  void  [PARAMETER]  String  newline  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultNewLine;	[BUGGY]  return  sb  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  String  getNewLine  (  )  {  [ATTENTION]  return  sb  ;  }    [METHOD]  getNewLine  [TYPE]  String  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultOptPrefix  =  prefix;	[BUGGY]  this  .  defaultLongOptPrefix  =  prefix  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setOptPrefix  (  String  prefix  )  {  [ATTENTION]  this  .  defaultLongOptPrefix  =  prefix  ;    ;  }    [METHOD]  setOptPrefix  [TYPE]  void  [PARAMETER]  String  prefix  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultOptPrefix;	[BUGGY]  return  this  .  defaultSyntaxPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  getOptPrefix  (  )  {  [ATTENTION]  return  this  .  defaultSyntaxPrefix  ;  }    [METHOD]  getOptPrefix  [TYPE]  String  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultLongOptPrefix  =  prefix;	[BUGGY]  this  .  defaultOptPrefix  =  prefix  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setLongOptPrefix  (  String  prefix  )  {  [ATTENTION]  this  .  defaultOptPrefix  =  prefix  ;    ;  }    [METHOD]  setLongOptPrefix  [TYPE]  void  [PARAMETER]  String  prefix  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultLongOptPrefix;	[BUGGY]  return  this  .  defaultOptPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  getLongOptPrefix  (  )  {  [ATTENTION]  return  this  .  defaultOptPrefix  ;  }    [METHOD]  getLongOptPrefix  [TYPE]  String  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  this  .  defaultArgName  =  name;	[BUGGY]  this  .  defaultArgName  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setArgName  (  String  name  )  {  [ATTENTION]  this  .  defaultArgName  =  null  ;  }    [METHOD]  setArgName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  false  true  
[ADD]  this  .  defaultArgName  =  name;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setArgName  (  String  name  )  {  [ATTENTION]  }    [METHOD]  setArgName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  return  this  .  defaultArgName;	[BUGGY]  return  sb  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  String  getArgName  (  )  {  [ATTENTION]  return  sb  ;  }    [METHOD]  getArgName  [TYPE]  String  [PARAMETER]  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  false  true  
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  false  )  ;	[BUGGY]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  false  ,  options  ,  false  ,  false  )  ;  [CE]  no  suitable  method  found  for  printHelp(int  ,  String  ,  boolean  ,  Options  ,  boolean  ,  boolean)  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  Options  options  )  {  [ATTENTION]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  false  ,  options  ,  false  ,  false  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  autoUsage  )  ;	[BUGGY]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  this  ,  options  ,  this  ,  autoUsage  )  ;  [CE]  no  suitable  method  found  for  printHelp(int  ,  String  ,  HelpFormatter  ,  Options  ,  HelpFormatter  ,  boolean)  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  Options  options  ,  boolean  autoUsage  )  {  [ATTENTION]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  this  ,  options  ,  this  ,  autoUsage  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  Options  options  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[ADD]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  autoUsage  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  Options  options  ,  boolean  autoUsage  )  {  [ATTENTION]  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  Options  options  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[REPLACE]  printHelp  (  cmdLineSyntax,  header,  options,  footer,  false  )  ;	[BUGGY]  printHelp  (  cmdLineSyntax  ,  header  ,  options  ,  footer  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  )  {  [ATTENTION]  printHelp  (  cmdLineSyntax  ,  header  ,  options  ,  footer  ,  true  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  String  header  Options  options  String  footer  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  header,  options,  footer,  autoUsage  )  ;	[BUGGY]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  newline  ,  options  ,  footer  ,  autoUsage  )  ;  [CE]  cannot  find  symbol  newline  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  [ATTENTION]  printHelp  (  defaultWidth  ,  cmdLineSyntax  ,  newline  ,  options  ,  footer  ,  autoUsage  )    ;    }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[ADD]  printHelp  (  defaultWidth,  cmdLineSyntax,  header,  options,  footer,  autoUsage  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  [ATTENTION]    }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[REPLACE]  printHelp  (  width,  cmdLineSyntax,  header,  options,  footer,  false  )  ;	[BUGGY]  printHelp  (  width  ,  cmdLineSyntax  ,  header  ,  options  ,  footer  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  )  {  [ATTENTION]  printHelp  (  width  ,  cmdLineSyntax  ,  header  ,  options  ,  footer  ,  true  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  
[REPLACE]  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ;	[BUGGY]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  [ATTENTION]  StringBuffer  sb  =  new  StringBuffer  (  len  )    ;    printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  header  ,  options  ,  defaultLeftPad  ,  defaultDescPad  ,  footer  ,  autoUsage  )  ;  pw  .  flush  (  )  ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  defaultLeftPad,  defaultDescPad,  footer,  autoUsage  )  ;	[BUGGY]  printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  defaultSyntaxPrefix  ,  options  ,  defaultLeftPad  ,  defaultDescPad  ,  footer  ,  autoUsage  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ;    [ATTENTION]  printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  defaultSyntaxPrefix  ,  options  ,  defaultLeftPad  ,  defaultDescPad  ,  footer  ,  autoUsage  )    ;    pw  .  flush  (  )  ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  defaultLeftPad,  defaultDescPad,  footer,  autoUsage  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ;    [ATTENTION]    pw  .  flush  (  )  ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  pw  .  flush  (  )  ;	[BUGGY]  optBuf  .  append  (  dpad  )  ;  [CE]  cannot  find  symbol  dpad  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ;    printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  header  ,  options  ,  defaultLeftPad  ,  defaultDescPad  ,  footer  ,  autoUsage  )  ;  [ATTENTION]  optBuf  .  append  (  dpad  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  pw  .  flush  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  String  footer  ,  boolean  autoUsage  )  {  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ;    printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  header  ,  options  ,  defaultLeftPad  ,  defaultDescPad  ,  footer  ,  autoUsage  )  ;  [ATTENTION]  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  int  width  String  cmdLineSyntax  String  header  Options  options  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  leftPad,  descPad,  footer,  false  )  ;	[BUGGY]  printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  header  ,  options  ,  leftPad  ,  descPad  ,  footer  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printHelp  (  PrintWriter  pw  ,  int  width  ,  String  cmdLineSyntax  ,  String  header  ,  Options  options  ,  int  leftPad  ,  int  descPad  ,  String  footer  )  {  [ATTENTION]  printHelp  (  pw  ,  width  ,  cmdLineSyntax  ,  header  ,  options  ,  leftPad  ,  descPad  ,  footer  ,  true  )    ;    }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  (  cmdLineSyntax  ==  null  )  ||  (  cmdLineSyntax  .  length  (  )  ==  0  )  )  {	[BUGGY]  if  (  (  cmdLineSyntax  =  =  false  )  ||  (  cmdLineSyntax  .  size  (  )    =  =  0  )  )  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  {  [ATTENTION]  if  (  (  cmdLineSyntax  =  =  false  )  ||  (  cmdLineSyntax  .  size  (  )  =  =  0  )  )  {  throw  new  IllegalArgumentException  (   "cmdLineSyntax  not  provided "  )  ;  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  return  ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  return  ;  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  autoUsage  )  {	[BUGGY]  if  (  group  !  =  null  )  {[CE]  cannot  find  symbol  group  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  throw  new  IllegalArgumentException  (   "cmdLineSyntax  not  provided "  )  ;  }  [ATTENTION]  if  (  group  !  =  null  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printUsage  (  pw,  width,  cmdLineSyntax  )  ;	[BUGGY]  printUsage  (  pw  ,  width  ,  prefix  )  ;  [CE]  cannot  find  symbol  prefix  [CONTEXT]  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  [ATTENTION]  printUsage  (  pw  ,  width  ,  prefix  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printUsage  (  pw,  width,  cmdLineSyntax,  options  )  ;	[BUGGY]  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  autoUsage  )  {  [ATTENTION]  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )    ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  (  header  !=  null  )  &&  (  header  .  trim  (  )    .  length  (  )  >  0  )  )  {	[BUGGY]  if  (  (  header  !  =  null  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  throw  new  IllegalArgumentException  (   "cmdLineSyntax  not  provided "  )  ;  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  [ATTENTION]  if  (  (  header  !  =  null  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  header  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  defaultNewLine  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  [ATTENTION]  printWrapped  (  pw  ,  width  ,  defaultNewLine  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printOptions  (  pw,  width,  options,  leftPad,  descPad  )  ;	[BUGGY]  renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  throw  new  IllegalArgumentException  (   "cmdLineSyntax  not  provided "  )  ;  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  [ATTENTION]  renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )    ;    if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  (  footer  !=  null  )  &&  (  footer  .  trim  (  )    .  length  (  )  >  0  )  )  {	[BUGGY]  if  (  (  footer  !  =  false  )  )  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  {  if  (  (  cmdLineSyntax  =  =  null  )  ||  (  cmdLineSyntax  .  length  (  )    =  =  0  )  )  {  throw  new  IllegalArgumentException  (   "cmdLineSyntax  not  provided "  )  ;  }  if  (  autoUsage  )  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  ,  options  )  ;  }  else  {  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  }  if  (  (  header  !  =  null  )  &&  (  header  .  trim  (  )  .  length  (  )  >  0  )  )  {  printWrapped  (  pw  ,  width  ,  header  )  ;  }  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;    [ATTENTION]  if  (  (  footer  !  =  false  )  )  {  printWrapped  (  pw  ,  width  ,  footer  )  ;  }  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  footer  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  0  ,  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  if  (  (  footer  !  =  null  )  &&  (  footer  .  trim  (  )  .  length  (  )  >  0  )  )  {  [ATTENTION]  printWrapped  (  pw  ,  width  ,  0  ,  text  )    ;  }    [METHOD]  printHelp  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  String  header  Options  options  int  leftPad  int  descPad  String  footer  boolean  autoUsage  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  autoUsage  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )    .  append  (  app  )    .  append  (   "   "  )  ;	[BUGGY]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  name  )  .  append  (   "   "  )  ;  [CE]  cannot  find  symbol  name  [CONTEXT]  {    [ATTENTION]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )    .  append  (  name  )    .  append  (   "   "  )    ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )    .  append  (  app  )    .  append  (   "   "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  buff  [CONTEXT]  {    [ATTENTION]      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  final  Collection  processedGroups  =  new  ArrayList  (  )  ;	[BUGGY]  List  prefixList  =  new  ArrayList  (  )  ;  [CE]  cannot  find  symbol  processedGroups  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      [ATTENTION]  List  prefixList  =  new  ArrayList  (  )    ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  Option  option;	[BUGGY]  Option  opt1  =    (  Option  )  o1  ;  [CE]  cannot  find  symbol  o1  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      [ATTENTION]  Option  opt1  =  (  Option  )  o1  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  group  !=  null  )  {	[BUGGY]  if  (  group  =  =  this  )  {[CE]  incomparable  types:  OptionGroup  and  HelpFormatter  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      [ATTENTION]  if  (  group  =  =  this  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ;	[BUGGY]  renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  [ATTENTION]  renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )    ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ;	[BUGGY]  appendOption  (  buff  ,  option  ,  option  .  getKey  (  )    )  ;  [CE]  method  appendOption  in  class  HelpFormatter  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  [ATTENTION]  appendOption  (  buff  ,  option  ,  option  .  getKey  (  )    )    ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  [ATTENTION]  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  {	[BUGGY]  if  (  group  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    [ATTENTION]  if  (  group  !  =  null  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  if  (  !processedGroups  .  contains  (  group  )  )  {  processedGroups  .  add  (  group  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  group  !  =  null  )  {    [ATTENTION]          appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  processedGroups  .  add  (  group  )  ;	[BUGGY]  processedGroups  .  iterator  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    [ATTENTION]  processedGroups  .  iterator  (  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  processedGroups  .  add  (  group  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    [ATTENTION]      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  appendOptionGroup  (  buff,  group  )  ;	[BUGGY]  if  (  option  .  getOpt  (  )  !  =  null  )  {[CE]  illegal  start  of  expression  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      [ATTENTION]  if  (  option  .  getOpt  (  )  !  =  null  )  {  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  {	[BUGGY]  if  (  !processedGroups  .  add  (  group  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    [ATTENTION]  if  (  !processedGroups  .  add  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  processedGroups  .  add  (  group  )  ;	[BUGGY]  processedGroups  .  contains  (  group  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !processedGroups  .  contains  (  group  )  )  {    [ATTENTION]  processedGroups  .  contains  (  group  )    ;      appendOptionGroup  (  buff  ,  group  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  appendOptionGroup  (  buff,  group  )  ;	[BUGGY]  if  (  option  .  getOpt  (  )  !  =  null  )  {[CE]  illegal  start  of  expression  [CONTEXT]  if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      [ATTENTION]  if  (  option  .  getOpt  (  )  !  =  null  )  {  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  i  .  hasNext  (  )  )  {	[BUGGY]  if  (  group  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  [ATTENTION]  if  (  group  !  =  null  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  [ATTENTION]      }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  buff  .  append  (   "   "  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  i  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  toString  (  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  add  (  )  ;  i  .  hasNext  (  )  ;  )  {[CE]  method  add  in  interface  Collection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      [ATTENTION]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  add  (  )    ;  i  .  hasNext  (  )    ;    )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  group  !=  null  )  {	[BUGGY]  if  (  group  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      [ATTENTION]  if  (  group  =  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ;	[BUGGY]  appendOption  (  buff  ,  option  ,  option  .  getKey  (  )  )  ;  [CE]  method  appendOption  in  class  HelpFormatter  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  [ATTENTION]  appendOption  (  buff  ,  option  ,  option  .  getKey  (  )  )    ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  {	[BUGGY]  if  (  processedGroups  .  contains  (  group  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    [ATTENTION]  if  (  processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  processedGroups  .  add  (  group  )  ;	[BUGGY]  processedGroups  .  contains  (  group  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    [ATTENTION]  processedGroups  .  contains  (  group  )    ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  {	[BUGGY]  if  (  processedGroups  .  contains  (  group  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    [ATTENTION]  if  (  processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  processedGroups  .  add  (  group  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !processedGroups  .  contains  (  group  )  )  {    [ATTENTION]      appendOptionGroup  (  buff  ,  group  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  appendOptionGroup  (  buff,  group  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      [ATTENTION]  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  i  .  hasNext  (  )  )  {	[BUGGY]  if  (  i  .  next  (  )    )  {[CE]  incompatible  types  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  [ATTENTION]  if  (  i  .  next  (  )    )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  [CE]  variable  option  might  not  have  been  initialized  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    [ATTENTION]      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;	[BUGGY]  OptionGroup  group  =  options  .  getOptions  (  )    ;  [CE]  incompatible  types  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      [ATTENTION]  OptionGroup  group  =  options  .  getOptions  (  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;	[BUGGY]  [CE]  cannot  find  symbol  group  [CONTEXT]  for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      [ATTENTION]      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  options  .  helpOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      [ATTENTION]  for  (  Iterator  i  =  options  .  helpOptions  (  )  .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  [CE]  invalid  method  declaration  ;  return  type  required  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      [ATTENTION]          OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;	[BUGGY]  OptionGroup  group  =  options  .  getOptions  (  )    ;  [CE]  incompatible  types  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      [ATTENTION]  OptionGroup  group  =  options  .  getOptions  (  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ;	[BUGGY]  printWrapped  (  pw  ,  padding  ,  buff  .  StringBuffer  (  )  .  indexOf  (  '  '  )    <  1  ,  buff  .  toString  (  )  )  ;  [CE]  cannot  find  symbol  padding  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      [ATTENTION]  printWrapped  (  pw  ,  padding  ,  buff  .  StringBuffer  (  )    .  indexOf  (  '  '  )  <1  ,  buff  .  toString  (  )  )    ;    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )    .  indexOf  (  DEFAULT_WIDTH  ,  DEFAULT_LEFT_PAD  )    +  1  ,  buff  .  toString  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      [ATTENTION]  printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  DEFAULT_WIDTH  ,  DEFAULT_LEFT_PAD  )  +  1  ,  buff  .  toString  (  )  )    ;    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      [ATTENTION]    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  buff  .  StringBuffer  (  )  .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      [ATTENTION]  printWrapped  (  pw  ,  width  ,  buff  .  StringBuffer  (  )    .  indexOf  (  '  '  )  +  1  ,  buff  .  toString  (  )  )    ;    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  buff  .  toString  (  )  )  ;	[BUGGY]  buff  .  StringBuffer  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {    StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )  .  append  (  app  )    .  append  (   "   "  )  ;      final  Collection  processedGroups  =  new  ArrayList  (  )  ;      Option  option  ;      for  (  Iterator  i  =  options  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    option  =    (  Option  )  i  .  next  (  )  ;      OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ;      if  (  group  !  =  null  )  {    if  (  !processedGroups  .  contains  (  group  )  )  {    processedGroups  .  add  (  group  )  ;      appendOptionGroup  (  buff  ,  group  )  ;  }      }    else  {  appendOption  (  buff  ,  option  ,  option  .  isRequired  (  )  )  ;  }  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "   "  )  ;  }  }      printWrapped  (  pw  ,  width  ,  buff  .  toString  (  )  .  indexOf  (  '  '  )  +  1  ,  [ATTENTION]  buff  .  StringBuffer  (  )  )    ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  app  Options  options  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  buff  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Collection  processedGroups  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  if  (  !group  .  isRequired  (  )  )  {	[BUGGY]  if  (  group  .  isRequired  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  [ATTENTION]  if  (  group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[ADD]  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  [ATTENTION]        for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "[ "  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  [ATTENTION]  buff  .  toString  (  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  i  .  hasNext  (  )  )  {	[BUGGY]  if  (  i  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    [ATTENTION]  if  (  i  .  next  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[ADD]  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    [ATTENTION]      }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "  |   "  )  ;	[BUGGY]  buff  .  StringBuffer  (   "  |   "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  StringBuffer  (   "  |   "  )    ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  contains  (  false  )    ;  i  .  hasNext  (  )  ;  )  {[CE]  incompatible  types  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    [ATTENTION]  for  (  Iterator  i  =  group  .  getOptions  (  )  .  contains  (  false  )  ;  i  .  hasNext  (  )    ;    )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  group  .  getOptions  (  )  .  add  (  )  ;  i  .  hasNext  (  )  ;  )  {[CE]  method  add  in  interface  Collection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    [ATTENTION]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  add  (  )    ;  i  .  hasNext  (  )    ;    )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  !group  .  isRequired  (  )  )  {	[BUGGY]  if  (  group  .  isRequired  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  [ATTENTION]  if  (  group  .  isRequired  (  )  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "] "  )  ;	[BUGGY]  buff  .  StringBuffer  (   "] "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  static  void  appendOptionGroup  (  final  StringBuffer  buff  ,  final  OptionGroup  group  )  {  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (   "[ "  )  ;  }    for  (  Iterator  i  =  group  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {    appendOption  (  buff  ,    (  Option  )  i  .  next  (  )  ,  true  )  ;    if  (  i  .  hasNext  (  )  )  {  buff  .  append  (   "  |   "  )  ;  }  }  if  (  !group  .  isRequired  (  )  )  {  [ATTENTION]  buff  .  StringBuffer  (   "] "  )    ;  }  }    [METHOD]  appendOptionGroup  [TYPE]  void  [PARAMETER]  StringBuffer  buff  OptionGroup  group  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Iterator  i  [TYPE]  StringBuffer  buff  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  !required  )  {	[BUGGY]  if  (  !true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  [ATTENTION]  if  (  !true  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }    if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "[ "  )  ;	[BUGGY]  buff  .  StringBuffer  (   "[ "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  !required  )  {  [ATTENTION]  buff  .  StringBuffer  (   "[ "  )    ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  {	[BUGGY]  if  (  option  .  getOpt  (  )    =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  [ATTENTION]  if  (  option  .  getOpt  (  )  =  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }    if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "-- "  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  StringBuffer  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  StringBuffer  (   "-- "  )    .  append  (  option  .  getLongOpt  (  )  )    ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REMOVE]  	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  +  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  non-static  variable  defaultLongOptPrefix  cannot  be  referenced  from  a  static  context  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;      [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "-- "  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  toString  (  )  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "-- "  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  append  (   "-- "  )    .  append  (  option  .  hasLongOpt  (  )  )    ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[ADD]  buff  .  append  (   "-- "  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "- "  )    .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  StringBuffer  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  [ATTENTION]  buff  .  StringBuffer  (   "- "  )    .  append  (  option  .  getOpt  (  )  )    ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "- "  )    .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  [ATTENTION]  buff  .  toString  (  )  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "- "  )    .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  append  (   "- "  )  .  append  (  option  .  getKey  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  [ATTENTION]  buff  .  append  (   "- "  )    .  append  (  option  .  getKey  (  )  )    ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !=  null  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }    if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  buff  .  append  (   "  < "  )  .  append  (  option  .  hasArgName  (  )  )  .  append  (   "> "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  [ATTENTION]  buff  .  append  (   "  < "  )    .  append  (  option  .  hasArgName  (  )  )    .  append  (   "> "  )    ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  buff  .  StringBuffer  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  [ATTENTION]  buff  .  StringBuffer  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )    ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  if  (  !required  )  {	[BUGGY]  if  (  required  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }    [ATTENTION]  if  (  required  )  {  buff  .  append  (   "] "  )  ;  }  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[ADD]  if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }    if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }    [ATTENTION]      }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  buff  .  append  (   "] "  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !required  )  {  [ATTENTION]  buff  .  toString  (  )  ;  }    [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  
[REPLACE]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1;	[BUGGY]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +defaultLeftPad  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printUsage  (  PrintWriter  pw  ,  int  width  ,  String  cmdLineSyntax  )  {  [ATTENTION]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +defaultLeftPad  ;    printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  length  (  )  +  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1;	[BUGGY]  [CE]  cannot  find  symbol  argPos  [CONTEXT]  public  void  printUsage  (  PrintWriter  pw  ,  int  width  ,  String  cmdLineSyntax  )  {  [ATTENTION]    printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  length  (  )  +  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;  }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  defaultSyntaxPrefix  .  length  (  )  +  argPos,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  length  (  )  *  0  .  5  +  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;  [CE]  no  suitable  method  found  for  printWrapped(PrintWriter  ,  int  ,  double  ,  String)  [CONTEXT]  public  void  printUsage  (  PrintWriter  pw  ,  int  width  ,  String  cmdLineSyntax  )  {  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1  ;    [ATTENTION]  printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  length  (  )  *0  .  5+  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )    ;    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  defaultSyntaxPrefix  .  length  (  )  +  argPos,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  charAt  (  )  +  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ;  [CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  void  printUsage  (  PrintWriter  pw  ,  int  width  ,  String  cmdLineSyntax  )  {  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1  ;    [ATTENTION]  printWrapped  (  pw  ,  width  ,  defaultSyntaxPrefix  .  charAt  (  )  +  argPos  ,  defaultSyntaxPrefix  +  cmdLineSyntax  )    ;    }    [METHOD]  printUsage  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  cmdLineSyntax  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  )  ;	[BUGGY]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  [ATTENTION]  StringBuffer  sb  =  new  StringBuffer  (  len  )    ;    renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  [ATTENTION]    renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  renderOptions  (  sb,  width,  options,  leftPad,  descPad  )  ;	[BUGGY]  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  StringBuffer  sb  =  new  StringBuffer  (  )  ;    [ATTENTION]  printOptions  (  pw  ,  width  ,  options  ,  leftPad  ,  descPad  )    ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  renderOptions  (  sb,  width,  options,  leftPad,  descPad  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;	[BUGGY]  pw  .  println  (  sb  .  toString  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  StringBuffer  sb  =  new  StringBuffer  (  )  ;    [ATTENTION]  pw  .  println  (  sb  .  toString  (  )  )    ;    }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ;	[BUGGY]  pw  .  PrintWriter  (  sb  .  toString  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  StringBuffer  sb  =  new  StringBuffer  (  )  ;    renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  [ATTENTION]  pw  .  PrintWriter  (  sb  .  toString  (  )  )    ;  }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ;	[BUGGY]  pw  .  println  (  sb  .  StringBuffer  (  defaultNewLine  )    )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  void  printOptions  (  PrintWriter  pw  ,  int  width  ,  Options  options  ,  int  leftPad  ,  int  descPad  )  {  StringBuffer  sb  =  new  StringBuffer  (  )  ;    renderOptions  (  sb  ,  width  ,  options  ,  leftPad  ,  descPad  )  ;  [ATTENTION]  pw  .  println  (  sb  .  StringBuffer  (  defaultNewLine  )    )    ;  }    [METHOD]  printOptions  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  printWrapped  (  pw,  width,  0,  text  )  ;	[BUGGY]  printWrapped  (  pw  ,  width  ,  1  ,  defaultOptPrefix  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  String  text  )  {  [ATTENTION]  printWrapped  (  pw  ,  width  ,  1  ,  defaultOptPrefix  )    ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;	[BUGGY]  StringBuffer  sb  =  new  StringBuffer  (  footer  .  trim  (  )  )  ;  [CE]  cannot  find  symbol  footer  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  [ATTENTION]  StringBuffer  sb  =  new  StringBuffer  (  footer  .  trim  (  )  )    ;    renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  [ATTENTION]    renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  renderWrappedText  (  sb,  width,  nextLineTabStop,  text  )  ;	[BUGGY]  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  defaultSyntaxPrefix  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;    [ATTENTION]  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  defaultSyntaxPrefix  )    ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[REMOVE]  	[BUGGY]  printUsage  (  pw  ,  width  ,  cmdLineSyntax  )  ;  [CE]  cannot  find  symbol  cmdLineSyntax  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;    [ATTENTION]  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;    printUsage  (  pw  ,  width  ,  cmdLineSyntax  )    ;  pw  .  println  (  sb  .  toString  (  )  )  ;      [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ;	[BUGGY]  pw  .  PrintWriter  (  false  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;    renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  [ATTENTION]  pw  .  PrintWriter  (  false  )  ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ;	[BUGGY]  pw  .  println  (  sb  .  StringBuffer  (  prefix  )    )  ;  [CE]  cannot  find  symbol  prefix  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;    renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  [ATTENTION]  pw  .  println  (  sb  .  StringBuffer  (  prefix  )    )    ;  }    [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  footer  header  name  newline  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  nextLineTabStop  padding  width  [TYPE]  PrintWriter  pw  
[REPLACE]  final  String  lpad  =  createPadding  (  leftPad  )  ;	[BUGGY]  final  String  lpad  =  createPadding  (  max  )  ;  [CE]  cannot  find  symbol  max  [CONTEXT]  {  [ATTENTION]  final  String  lpad  =  createPadding  (  max  )    ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  final  String  dpad  =  createPadding  (  descPad  )  ;	[BUGGY]  final  String  dpad  =  createPadding  (  nextLineTabStop  )  ;  [CE]  cannot  find  symbol  nextLineTabStop  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  [ATTENTION]  final  String  dpad  =  createPadding  (  nextLineTabStop  )    ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  int  max  =  0;	[BUGGY]  int  max  =  4  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            [ATTENTION]  int  max  =  4  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  StringBuffer  optBuf;	[BUGGY]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;  [CE]  variable  sb  is  already  defined  in  method  renderOptions(StringBuffer  ,  int  ,  Options  ,  int  ,  int)  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  [ATTENTION]  StringBuffer  sb  =  new  StringBuffer  (  len  )    ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  StringBuffer  optBuf;	[BUGGY]  [CE]  cannot  find  symbol  optBuf  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  [ATTENTION]  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  List  prefixList  =  new  ArrayList  (  )  ;	[BUGGY]  int  pos  =  s  .  length  (  )  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  [ATTENTION]  int  pos  =  s  .  length  (  )    ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  Option  option;	[BUGGY]  Option  opt1  =    (  Option  )  o1  ;  [CE]  cannot  find  symbol  o1  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  [ATTENTION]  Option  opt1  =  (  Option  )  o1  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  List  optList  =  options  .  helpOptions  (  )  ;	[BUGGY]  List  optList  =  options  .  getOptions  (  )  ;  [CE]  incompatible  types  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  [ATTENTION]  List  optList  =  options  .  getOptions  (  )    ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  Collections  .  sort  (  optList,  new  OptionComparator  (  )  )  ;	[BUGGY]  Collections  .  sort  (  prefixList  ,  new  OptionComparator  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    [ATTENTION]  Collections  .  sort  (  prefixList  ,  new  OptionComparator  (  )  )    ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  getOpt  (  )  ==  null  )  {	[BUGGY]  if  (  option  .  getOpt  (  )  !  =  dpad  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    [ATTENTION]  if  (  option  .  getOpt  (  )  !  =  dpad  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  '  ,  '  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  hasLongOpt  (  )  )    ;    }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  newline  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  newline  )    }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  dpad  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  dpad  )    }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]    }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )  [ATTENTION]  .  append  (  option  .  hasLongOpt  (  )  )    ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  <  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]  optBuf  .  append  (  lpad  )    .  append  (   "   "<defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )    ;    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  StringBuffer  (  newline  )  .  append  (   "     "    =  =    defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  cannot  find  symbol  newline  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]  optBuf  .  StringBuffer  (  newline  )    .  append  (   "   "  =  =  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )    ;    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  StringBuffer  (  lpad  )  .  append  (   "     "  +  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]  optBuf  .  StringBuffer  (  lpad  )    .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )    ;    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )  [ATTENTION]  .  append  (  option  .  hasLongOpt  (  )  )    ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  newline  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  newline  )    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  dpad  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  dpad  )    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  defaultLongOptPrefix  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  defaultLongOptPrefix  )    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )  [ATTENTION]  .  append  (  option  .  hasLongOpt  (  )  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REMOVE]  	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  +  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )  [ATTENTION]  .  append  (  option  .  getLongOpt  (  )  )  ;      [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArg  (  )  )  {	[BUGGY]  if  (  option  .  hasArgName  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  [ATTENTION]  if  (  option  .  hasArgName  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArgName  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  '  '  )  ;	[BUGGY]  optBuf  .  append  (  dpad  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  [ATTENTION]  optBuf  .  append  (  dpad  )    ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  append  (   "  < "  )  .  append  (  option  .  hasArgName  (  )  )  .  append  (   "> "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  hasArgName  (  )  )    .  append  (   "> "  )    ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  StringBuffer  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  StringBuffer  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )    ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  toString  (  )  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArgName  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  '  '  )  ;	[BUGGY]  optBuf  .  append  (  dpad  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  [ATTENTION]  optBuf  .  append  (  dpad  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  toString  (  )  }  else  {  optBuf  .  append  (  '  '  )  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  }  else  {  optBuf  .  append  (  '  '  )  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  StringBuffer  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  StringBuffer  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )    ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  append  (   "  < "  )  .  append  (  option  .  hasArgName  (  )  )  .  append  (   "> "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  hasArgName  (  )  )    .  append  (   "> "  )    ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  getOpt  (  )  ==  null  )  {	[BUGGY]  if  (dpad  (  )  !  =  false  )  {[CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    [ATTENTION]  if  (  dpad  (  )  !  =  false  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  if  (  option  .  getOpt  (  )  ==  null  )  {  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    [ATTENTION]      else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  {	[BUGGY]  if  (  option  .  getLongOpt  (  )  )  {[CE]  incompatible  types  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    [ATTENTION]  if  (  option  .  getLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  text  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  text  )    }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  ||  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]  optBuf  .  append  (  lpad  )    .  append  (   "   "||defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )    ;    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (   "     "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  &  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  if  (  option  .  getOpt  (  )    =  =  null  )  {  [ATTENTION]  optBuf  .  append  (  lpad  )    .  append  (   "   "&defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )    ;    }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )  .  append  (  option  .  hasLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  '  ,  '  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  hasLongOpt  (  )  )    ;    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  text  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  text  )    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  optBuf  .  append  (  defaultOptPrefix  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  option  .  hasLongOpt  (  )  )  {  [ATTENTION]  optBuf  .  append  (  defaultOptPrefix  )    }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArg  (  )  )  {	[BUGGY]  if  (  option  .  hasArgName  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  [ATTENTION]  if  (  option  .  hasArgName  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  [ATTENTION]      }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArgName  (  )  )  {	[BUGGY]  if  (  option  .  getArgName  (  )  )  {[CE]  incompatible  types  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  [ATTENTION]  if  (  option  .  getArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  '  '  )  ;	[BUGGY]  optBuf  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  [ATTENTION]  optBuf  .  toString  (  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (   "> "  )  ;	[BUGGY]  optBuf  .  append  (   "  < "  )  .  append  (  option  .  hasArgName  (  )    )  .  append  (   "> "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  [ATTENTION]  optBuf  .  append  (   "  < "  )    .  append  (  option  .  hasArgName  (  )    )    .  append  (   "> "  )    ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  hasArgName  (  )  )  {	[BUGGY]  if  (  option  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  [ATTENTION]  if  (  option  .  hasArg  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  =  new  StringBuffer  (  8  )  ;	[BUGGY]  optBuf  =  new  StringBuffer  (  8  >>  1  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  [ATTENTION]  optBuf  =  new  StringBuffer  (  8  >>  1  )    ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max;	[BUGGY]  max  =    (  optBuf  .  length  (  )  -  2  >  max  )        ?  optBuf  .  length  (  )  -  2  :  max  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  [ATTENTION]  max  =  (  optBuf  .  length  (  )  -  2  >  max  )  ?  optBuf  .  length  (  )  -  2  :  max  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  [ATTENTION]  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  =  new  StringBuffer  (  8  )  ;	[BUGGY]  optBuf  =  new  StringBuffer  (  5  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  [ATTENTION]  optBuf  =  new  StringBuffer  (  5  )    ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  optBuf  =  new  StringBuffer  (  8  )  ;	[BUGGY]  [CE]  variable  optBuf  might  not  have  been  initialized  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  [ATTENTION]    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max;	[BUGGY]  max  =    (  optBuf  .  length  (  )  -  4  >  max  )        ?  optBuf  .  length  (  )  -  4  :  max  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  [ATTENTION]  max  =  (  optBuf  .  length  (  )  -  4  >  max  )  ?  optBuf  .  length  (  )  -  4  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  prefixList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    [ATTENTION]  for  (  Iterator  i  =  prefixList  .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  int  x  =  0;	[BUGGY]  int  x  =  1  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  [ATTENTION]  int  x  =  1  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  optBuf  .  length  (  )  <  max  )  {	[BUGGY]  if  (  optBuf  .  length  (  )  /  2  <  max  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    [ATTENTION]  if  (  optBuf  .  length  (  )  /2  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  x  -  optBuf  .  length  (  )  -  3  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  x  -  optBuf  .  length  (  )  -  3  )  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REMOVE]  	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  +  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;      [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  size  (  )  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  size  (  )  )  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  append  (  )  )  )  ;  [CE]  no  suitable  method  found  for  append()  [CONTEXT]  if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  append  (  )  )  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  getDescription  (  )  !=  null  )  {	[BUGGY]  if  (defaultSyntaxPrefix  (  )    =  =  null  )  {[CE]  cannot  find  symbol  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    [ATTENTION]  if  (  defaultSyntaxPrefix  (  )  =  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ;	[BUGGY]  optBuf  .  append  (  option  .  getOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getDescription  (  )  !  =  null  )  {  [ATTENTION]  optBuf  .  append  (  option  .  getOpt  (  )  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REMOVE]  	[BUGGY]  optBuf  .  append  (  lpad  )  .  append  (   "     "  +  defaultLongOptPrefix  )  .  append  (  option  .  getLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getDescription  (  )  !  =  null  )  {  [ATTENTION]  optBuf  .  append  (  option  .  getDescription  (  )  )  ;      [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  i  .  hasNext  (  )  )  {	[BUGGY]  if  (  i  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    [ATTENTION]  if  (  i  .  next  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    [ATTENTION]      }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  sb  .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  StringBuffer  (  defaultNewLine  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  i  .  hasNext  (  )  )  {  [ATTENTION]  sb  .  StringBuffer  (  defaultNewLine  )    ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  next  (  )  ;  )  {[CE]  incompatible  types  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    [ATTENTION]  for  (  Iterator  i  =  optList  .  iterator  (  )    ;  i  .  next  (  )    ;    )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  optBuf  .  length  (  )  <  max  )  {	[BUGGY]  if  (  optBuf  .  size  (  )  <  max  )  {[CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    [ATTENTION]  if  (  optBuf  .  size  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  size  (  )  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  size  (  )  )  )    ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  +  5  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  +  5  )  )    ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;	[BUGGY]  optBuf  .  append  (  createPadding  (  max  -  sb  .  append  (  )  )  )  ;  [CE]  no  suitable  method  found  for  append()  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  [ATTENTION]  optBuf  .  append  (  createPadding  (  max  -  sb  .  append  (  )  )  )    ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  option  .  getDescription  (  )  !=  null  )  {	[BUGGY]  if  (  option  .  getDescription  (  )    =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    [ATTENTION]  if  (  option  .  getDescription  (  )  =  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  if  (  option  .  getDescription  (  )  !=  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    [ATTENTION]      renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ;	[BUGGY]  optBuf  .  append  (  option  .  getOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  [ATTENTION]  optBuf  .  append  (  option  .  getOpt  (  )  )    ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ;	[BUGGY]  optBuf  .  append  (  option  .  getOpt  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  [ATTENTION]  optBuf  .  append  (  option  .  getOpt  (  )    )    ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  if  (  i  .  hasNext  (  )  )  {	[BUGGY]  if  (  i  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    [ATTENTION]  if  (  i  .  next  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  sb  .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  [ATTENTION]  sb  .  toString  (  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ;	[BUGGY]  optBuf  =    new  StringBuffer  (  null  .  get  (  x++  )  .  toString  (  )  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  [ATTENTION]  optBuf  =  new  StringBuffer  (  null  .  get  (  x++  )    .  toString  (  )  )    ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  int  nextLineTabStop  =  max  +  descPad;	[BUGGY]  int  nextLineTabStop  =  max  +x  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    [ATTENTION]  int  nextLineTabStop  =  max  +x  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  int  nextLineTabStop  =  max  +  descPad;	[BUGGY]  [CE]  cannot  find  symbol  nextLineTabStop  [CONTEXT]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    [ATTENTION]    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ;	[BUGGY]  option  =    (  Optnullon  )  null  .  next  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  option  =    (  Optnullon  )  null  .  next  (  )    ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ;	[BUGGY]  optBuf  =    new  StringBuffer  (  optList  .  get  (  x++  )  .  toString  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  [ATTENTION]  optBuf  =  new  StringBuffer  (  optList  .  get  (  x++  )    .  toString  (  )  )    ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  prefixList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    [ATTENTION]  for  (  Iterator  i  =  prefixList  .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[ADD]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =  (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    [ATTENTION]      if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  int  nextLineTabStop  =  max  +  descPad;	[BUGGY]  int  nextLineTabStop  =  x  +  descPad  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    [ATTENTION]  int  nextLineTabStop  =  x  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  return  sb  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  optBuf  ;  [CE]  variable  optBuf  might  not  have  been  initialized  [CONTEXT]  {  final  String  lpad  =  createPadding  (  leftPad  )  ;  final  String  dpad  =  createPadding  (  descPad  )  ;            int  max  =  0  ;  StringBuffer  optBuf  ;  List  prefixList  =  new  ArrayList  (  )  ;  Option  option  ;  List  optList  =  options  .  helpOptions  (  )  ;    Collections  .  sort  (  optList  ,  new  OptionComparator  (  )  )  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  8  )  ;    if  (  option  .  getOpt  (  )    =  =  null  )  {  optBuf  .  append  (  lpad  )  .  append  (   "   "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  else  {  optBuf  .  append  (  lpad  )  .  append  (  defaultOptPrefix  )    .  append  (  option  .  getOpt  (  )  )  ;    if  (  option  .  hasLongOpt  (  )  )  {  optBuf  .  append  (  '  ,  '  )  .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  }  }  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  else  {  optBuf  .  append  (  '  '  )  ;  }  }  prefixList  .  add  (  optBuf  )  ;  max  =    (  optBuf  .  length  (  )  >  max  )  ?  optBuf  .  length  (  )  :  max  ;  }  int  x  =  0  ;    for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =    (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )  .  toString  (  )  )  ;    if  (  optBuf  .  length  (  )  <  max  )  {  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ;  }  optBuf  .  append  (  dpad  )  ;    int  nextLineTabStop  =  max  +  descPad  ;    if  (  option  .  getDescription  (  )  !  =  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  }  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  optBuf  .  toString  (  )  )  ;    if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  }  }  [ATTENTION]  return  optBuf  ;  }    [METHOD]  renderOptions  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  Options  options  int  leftPad  int  descPad  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Options  options  [TYPE]  StringBuffer  optBuf  sb  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  List  optList  prefixList  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  prefix  text  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  width  x  
[REPLACE]  int  pos  =  findWrapPos  (  text,  width,  0  )  ;	[BUGGY]  int  pos  =  findWrapPos  (  text  ,  width  ,  1  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  [ATTENTION]  int  pos  =  findWrapPos  (  text  ,  width  ,  1  )    ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[ADD]  int  pos  =  findWrapPos  (  text,  width,  0  )  ;	[BUGGY]  [CE]  cannot  find  symbol  pos  [CONTEXT]  {  [ATTENTION]    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  if  (  pos  ==  -1  )  {	[BUGGY]  if  (  pos  !  =    -3  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    [ATTENTION]  if  (  pos!  =  -3  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  s  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    [ATTENTION]  return  s  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  s  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    [ATTENTION]  return  s  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  StringBuffer  (  rtrim  (  text  .  substring  (  2  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  [ATTENTION]  sb  .  StringBuffer  (  rtrim  (  text  .  substring  (  2  ,  pos  )  )  )    .  append  (  defaultNewLine  )    ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  StringBuffer  (  rtrim  (  text  .  substring  (  0  /  4  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  [ATTENTION]  sb  .  StringBuffer  (  rtrim  (  text  .  substring  (  0  /  4  ,  pos  )  )  )    .  append  (  defaultNewLine  )    ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  append  (  rtrim  (  text  .  substring  (  0L  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  [ATTENTION]  sb  .  append  (  rtrim  (  text  .  substring  (  0L  ,  pos  )  )  )    .  append  (  defaultNewLine  )    ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ;	[BUGGY]  sb  .  append  (  rtrim  (  text  .  indexOf  (  1  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  [CE]  method  rtrim  in  class  HelpFormatter  cannot  be  applied  to  given  types  ;  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  [ATTENTION]  sb  .  append  (  rtrim  (  text  .  indexOf  (  1  ,  pos  )  )  )    .  append  (  defaultNewLine  )    ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  final  String  padding  =  createPadding  (  nextLineTabStop  )  ;	[BUGGY]  final  String  padding  =  createPadding  (  x  )  ;  [CE]  cannot  find  symbol  x  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        [ATTENTION]  final  String  padding  =  createPadding  (  x  )    ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  while  (  true  )  {	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    [ATTENTION]  while  (  false  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  if  (  pos  ==  -1  )  {	[BUGGY]  if  (  padding  &&  padding  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    [ATTENTION]  if  (  padding&&  padding  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[ADD]  if  (  pos  ==  -1  )  {  sb  .  append  (  text  )  ;  return  sb;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    [ATTENTION]      }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  s  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    [ATTENTION]  return  s  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  text  =  padding  +  text  .  substring  (  pos  )    .  trim  (  )  ;	[BUGGY]  text  =  prefix  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [CE]  cannot  find  symbol  prefix  [CONTEXT]  while  (  true  )  {  [ATTENTION]  text  =  prefix  +  text  .  substring  (  pos  )    .  trim  (  )    ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ;	[BUGGY]  pos  =    findWrapPos  (  footer  ,  width  ,  nextLineTabStop  )  ;  [CE]  cannot  find  symbol  footer  [CONTEXT]  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [ATTENTION]  pos  =  findWrapPos  (  footer  ,  width  ,  nextLineTabStop  )    ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[ADD]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [ATTENTION]    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  if  (  pos  ==  -1  )  {	[BUGGY]  if  (padding  !  =    -1  )  {[CE]  incomparable  types:  String  and  int  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    [ATTENTION]  if  (  padding!  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  s  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    [ATTENTION]  return  s  ;  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  text  =  padding  +  text  .  substring  (  pos  )    .  trim  (  )  ;	[BUGGY]  text  =  prefix  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [CE]  cannot  find  symbol  prefix  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  [ATTENTION]  text  =  prefix  +  text  .  substring  (  pos  )    .  trim  (  )    ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ;	[BUGGY]  pos  =    findWrapPos  (  newline  ,  width  ,  nextLineTabStop  )  ;  [CE]  cannot  find  symbol  newline  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [ATTENTION]  pos  =  findWrapPos  (  newline  ,  width  ,  nextLineTabStop  )    ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  return  sb;	[BUGGY]  return  s  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;    return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;        final  String  padding  =  createPadding  (  nextLineTabStop  )  ;    while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;    if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;    [ATTENTION]  return  s  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  }  }    [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  width  x  
[REPLACE]  int  pos  =  -1;	[BUGGY]  int  pos  =  -1  /  3  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  [ATTENTION]  int  pos  =  -1  /  3  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  if  (  (  (  pos  =  text  .  indexOf  (  '\n',  startPos  )  )  !=  -1  &&  pos  <=  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  {	[BUGGY]  if  (  (  (  pos  =  text  .  substring  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  &&  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {[CE]  incompatible  types  [CONTEXT]  {  int  pos  =  -1  ;      [ATTENTION]  if  (  (  (  pos  =  text  .  substring  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  &&  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {    return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  else  if  (  (  startPos  +  width  )  >=  text  .  length  (  )  )  {	[BUGGY]  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  *  2  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  [ATTENTION]  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  *2  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  -1;	[BUGGY]  return  -1  <<  0  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  [ATTENTION]  return  -1  <<  0  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  -1;	[BUGGY]  return  -1  +  2  ;  [FE]  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  [ATTENTION]  return  -1  +  2  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  pos+1;	[BUGGY]  return  startPos+1  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  [ATTENTION]  return  startPos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  else  if  (  (  startPos  +  width  )  >=  text  .  length  (  )  )  {	[BUGGY]  else  {[CE]  unreachable  statement  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  [ATTENTION]  else  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  -1;	[BUGGY]  return  -3  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  [ATTENTION]  return  -3  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  if  (  (  (  pos  =  text  .  indexOf  (  '\n',  startPos  )  )  !=  -1  &&  pos  <=  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  {	[BUGGY]  if  (  (  (  pos  =    null  .  indexOf  (  '\n'  ,  startPos  )  )  ![CE]  ')'  expected  [CONTEXT]  {  int  pos  =  -1  ;      [ATTENTION]  if  (  (  (  pos  =  null  .  indexOf  (  '\n'  ,  startPos  )  )  !    return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  {	[BUGGY]  ||  (  (  pos  =    prefix  .  indexOf  (  '\t'  ,  startPos  )  )  ![CE]  ')'  expected  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  [ATTENTION]  ||  (  (  pos  =  prefix  .  indexOf  (  '\t'  ,  startPos  )  )  !  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  pos+1;	[BUGGY]  returnpadding+1  ;  [CE]  not  a  statement  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  [ATTENTION]  returnpadding+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  -1;	[BUGGY]  return  -4  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  [ATTENTION]  return  -4  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  pos  =  startPos  +  width;	[BUGGY]  pos  =  max  +  width  ;  [CE]  cannot  find  symbol  max  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      [ATTENTION]  pos  =  max  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  char  c;	[BUGGY]  final  String  padding  =  createPadding  (  nextLineTabStop  )  ;  [CE]  cannot  find  symbol  nextLineTabStop  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    [ATTENTION]  final  String  padding  =  createPadding  (  nextLineTabStop  )    ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  while  (  (  pos  >=  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  {	[BUGGY]  while  (  (  pos  >  =  startPos  )  ||  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  ||  (  c  !  =  '\n'  )  ||  (  c  !  =  '\r'  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    [ATTENTION]  while  (  (  pos  >  =  startPos  )  ||  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  ||  (  c  !  =  '\n'  )  ||  (  c  !  =  '\r'  )  )  {    --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  while  (  (  pos  >=  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  {	[BUGGY]  while  (  (  pos  >  =    startPos  )  &&  (  (  c[CE]  ')'  expected  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    [ATTENTION]  while  (  (  pos  >  =  startPos  )  &&  (  (  c    --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  if  (  pos  >  startPos  )  {	[BUGGY]  if  (  pos  >  =    width  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    [ATTENTION]  if  (  pos>  =  width  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[ADD]  if  (  pos  >  startPos  )  {  return  pos;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    [ATTENTION]          pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  pos;	[BUGGY]  return  startPos  ;  [FE]  [CONTEXT]  if  (  pos  >  startPos  )  {  [ATTENTION]  return  startPos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  pos;	[BUGGY]  return  padding  ;  [CE]  cannot  find  symbol  padding  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  [ATTENTION]  return  padding  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  pos  =  startPos  +  width;	[BUGGY]  pos  =  startPos  +pos  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      [ATTENTION]  pos  =  startPos  +pos  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  while  (  (  pos  <=  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  {	[BUGGY]  while  (  (  pos  <  =  text  .  length  (  )  /  0  .  5  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    [ATTENTION]  while  (  (  pos  <  =  text  .  length  (  )  /0  .  5  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {    ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  while  (  (  pos  <=  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  {	[BUGGY]  while  (  (  pos  <  =    prefix  .  length  (  )  )  &&  (  (  c[CE]  ')'  expected  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    [ATTENTION]  while  (  (  pos  <  =  prefix  .  length  (  )  )  &&  (  (  c    ++pos  ;  }  return  (  pos  =  =  text  .  length  (  )  )  ?  (  -1  )  :  pos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  (  pos  ==  text  .  length  (  )  )          ?  (  -1  )  :  pos;	[BUGGY]  returnstartPos  ;  [CE]  not  a  statement  [CONTEXT]  {  int  pos  =  -1  ;      if  (  (  (  pos  =  text  .  indexOf  (  '\n'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t'  ,  startPos  )  )  !  =  -1  &&  pos  <  =  width  )  )  {  return  pos+1  ;  }  else  if  (  (  startPos  +  width  )  >  =  text  .  length  (  )  )  {  return  -1  ;  }      pos  =  startPos  +  width  ;    char  c  ;    while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }    if  (  pos  >  startPos  )  {  return  pos  ;  }      pos  =  startPos  +  width  ;    while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  [ATTENTION]  returnstartPos  ;  }    [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  leftPad  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;	[BUGGY]  StringBuffer  sb  =  new  StringBuffer  (  padding  )  ;  [CE]  cannot  find  symbol  padding  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  [ATTENTION]  StringBuffer  sb  =  new  StringBuffer  (  padding  )    ;    for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  sb  .  append  (  '  '  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;	[BUGGY]  [CE]  cannot  find  symbol  sb  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  [ATTENTION]    for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  sb  .  append  (  '  '  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  ++i  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  !  =    len  ;  ++i  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i!  =  len  ;  ++i  )  {  sb  .  append  (  '  '  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  sb  .  append  (  '  '  )  ;	[BUGGY]  sb  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;    for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  [ATTENTION]  sb  .  toString  (  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  ++i  )  {	[BUGGY]  for  (  int  i  =  4  ;  i  <  len  ;  ++i  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;    [ATTENTION]  for  (  int  i  =  4  ;  i  <  len  ;  ++i  )  {  sb  .  append  (  '  '  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuffer  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  protected  String  createPadding  (  int  len  )  {  StringBuffer  sb  =  new  StringBuffer  (  len  )  ;    for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  sb  .  append  (  '  '  )  ;  }  [ATTENTION]  return  sb  .  StringBuffer  (  )    ;  }    [METHOD]  createPadding  [TYPE]  String  [PARAMETER]  int  len  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  if  (  (  s  ==  null  )  ||  (  s  .  length  (  )  ==  0  )  )  {	[BUGGY]  if  (  (  defaultSyntaxPrefix  =  =  false  )  ||  (  s  .  length  (  )  /  2  =  =  0  )  )  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  [ATTENTION]  if  (  (  defaultSyntaxPrefix  =  =  false  )  ||  (  s  .  length  (  )  /2  =  =  0  )  )  {  return  s  ;  }  int  pos  =  s  .  length  (  )  ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  if  (  pos  >  startPos  )  {      return  pos  ;  }[CE]  cannot  find  symbol  pos  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  [ATTENTION]  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )    if  (  pos  >  startPos  )  {  return  pos  ;  }{  return  s  ;  }  int  pos  =  s  .  length  (  )  ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;      [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REPLACE]  return  s;	[BUGGY]  return  defaultSyntaxPrefix  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  return  defaultSyntaxPrefix  ;  }  int  pos  =  s  .  length  (  )  ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REPLACE]  return  s;	[BUGGY]  return  sb  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )  {  [ATTENTION]  return  sb  ;  }  int  pos  =  s  .  length  (  )  ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REPLACE]  int  pos  =  s  .  length  (  )  ;	[BUGGY]  int  pos  =  defaultSyntaxPrefix  .  length  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )  {  return  s  ;  }  [ATTENTION]  int  pos  =  defaultSyntaxPrefix  .  length  (  )    ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[ADD]  int  pos  =  s  .  length  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  pos  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )  {  return  s  ;  }  [ATTENTION]    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  return  s  .  substring  (  0  ,  pos  )  ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REPLACE]  return  s  .  substring  (  0,  pos  )  ;	[BUGGY]  return  s  .  indexOf  (  3  ,  pos  )  ;  [CE]  incompatible  types  [CONTEXT]  protected  String  rtrim  (  String  s  )  {  if  (  (  s  =  =  null  )  ||  (  s  .  length  (  )    =  =  0  )  )  {  return  s  ;  }  int  pos  =  s  .  length  (  )  ;    while  (  (  pos  >  0  )  &&  Character  .  isWhitespace  (  s  .  charAt  (  pos  -  1  )  )  )  {  --pos  ;  }  [ATTENTION]  return  s  .  indexOf  (  3  ,  pos  )    ;  }    [METHOD]  rtrim  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  
[REPLACE]  Option  opt1  =  (  Option  )  o1;	[BUGGY]  Option  opt2  =    (  Option  )  o2  ;  [CE]  variable  opt2  is  already  defined  in  method  compare(Object  ,  Object)  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  [ATTENTION]  Option  opt2  =  (  Option  )  o2  ;  Option  opt2  =    (  Option  )  o2  ;    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[ADD]  Option  opt1  =  (  Option  )  o1;	[BUGGY]  [CE]  cannot  find  symbol  opt1  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  [ATTENTION]  Option  opt2  =    (  Option  )  o2  ;    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  Option  opt2  =  (  Option  )  o2;	[BUGGY]  Option  opt1  =    (  Option  )  o1  ;  [CE]  variable  opt1  is  already  defined  in  method  compare(Object  ,  Object)  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  Option  opt1  =    (  Option  )  o1  ;  [ATTENTION]  Option  opt1  =  (  Option  )  o1  ;    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  return  opt1  .  getKey  (  )    .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;	[BUGGY]  return  opt1  .  getOpt  (  )    .  compareToIgnoreCase  (  opt2[CE]  ')'  expected  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  Option  opt1  =    (  Option  )  o1  ;  Option  opt2  =    (  Option  )  o2  ;    [ATTENTION]  return  opt1  .  getOpt  (  )  .  compareToIgnoreCase  (  opt2  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  HelpFormatter  OptionComparator    [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  app  cmdLineSyntax  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  dpad  footer  header  lpad  name  newline  padding  prefix  s  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  argPos  defaultDescPad  defaultLeftPad  defaultWidth  descPad  i  leftPad  len  max  nextLineTabStop  padding  pos  startPos  width  x  
[REPLACE]  Option  opt1  =  (  Option  )  o1;	[BUGGY]  Option  opt2  =    (  Option  )  o2  ;  [CE]  variable  opt2  is  already  defined  in  method  compare(Object  ,  Object)  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  [ATTENTION]  Option  opt2  =  (  Option  )  o2  ;  Option  opt2  =    (  Option  )  o2  ;    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  OptionComparator    [TYPE]  boolean  false  true  [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  
[REPLACE]  Option  opt2  =  (  Option  )  o2;	[BUGGY]  Option  opt1  =    (  Option  )  o1  ;  [CE]  variable  opt1  is  already  defined  in  method  compare(Object  ,  Object)  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  Option  opt1  =    (  Option  )  o1  ;  [ATTENTION]  Option  opt1  =  (  Option  )  o1  ;    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  OptionComparator    [TYPE]  boolean  false  true  [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  
[ADD]  Option  opt2  =  (  Option  )  o2;	[BUGGY]  [CE]  cannot  find  symbol  opt2  [CONTEXT]  public  int  compare  (  Object  o1  ,  Object  o2  )  {  Option  opt1  =    (  Option  )  o1  ;  [ATTENTION]    return  opt1  .  getKey  (  )  .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ;  }    [METHOD]  compare  [TYPE]  int  [PARAMETER]  Object  o1  Object  o2  [CLASS]  OptionComparator    [TYPE]  boolean  false  true  [TYPE]  Object  o1  o2  [TYPE]  Option  opt1  opt2  
[REPLACE]  public  static  final  int  UNINITIALIZED  =  -1;	[BUGGY]  public  final  int  UNINITIALIZED  =  -1  /  4  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Option  
[REPLACE]  public  static  final  int  UNLIMITED_VALUES  =  -2;	[BUGGY]  public  static  final  int  UNLIMITED_VALUES  =  -1  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Option  
[REPLACE]  private  String  argName  =   "arg ";	[BUGGY]  private  String  argName  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Option  
[REPLACE]  private  int  numberOfArgs  =  UNINITIALIZED;	[BUGGY]  private  int  numberOfArgs    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Option  
[REPLACE]  private  ArrayList  values  =  new  ArrayList  (  )  ;	[BUGGY]  private  ArrayList  values  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Option  
[REPLACE]  this  (  opt,  null,  false,  description  )  ;	[BUGGY]  this  (  opt  ,  false  ,  false  ,  longOpt  )  ;  [CE]  cannot  reference  longOpt  before  supertype  constructor  has  been  called  [CONTEXT]  public  Option  (  String  opt  ,  String  description  )  throws  IllegalArgumentException  {  [ATTENTION]  this  (  opt  ,  false  ,  false  ,  longOpt  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  (  opt,  null,  hasArg,  description  )  ;	[BUGGY]  this  (  opt  ,  true  ,  hasArg  ,  description  )  ;  [CE]  no  suitable  constructor  found  for  Option(String  ,  boolean  ,  boolean  ,  String)  [CONTEXT]  public  Option  (  String  opt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {  [ATTENTION]  this  (  opt  ,  true  ,  hasArg  ,  description  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[ADD]  this  (  opt,  null,  hasArg,  description  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  OptionValidator  .  validateOption  (  opt  )  ;	[BUGGY]  OptionValidator  .  validateOption  (  longOpt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    [ATTENTION]  OptionValidator  .  validateOption  (  longOpt  )    ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  opt  =  opt;	[BUGGY]  this  .  opt  =    longOpt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    [ATTENTION]  this  .  opt  =  longOpt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  longOpt  =  longOpt;	[BUGGY]  this  .  longOpt  =    opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  [ATTENTION]  this  .  longOpt  =  opt  ;      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[ADD]  this  .  longOpt  =  longOpt;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  [ATTENTION]      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  if  (  hasArg  )  {	[BUGGY]  if  (  required  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      [ATTENTION]  if  (  required  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  numberOfArgs  =  1;	[BUGGY]  this  .  numberOfArgs  =  num  ;    ;  [CE]  cannot  find  symbol  num  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  [ATTENTION]  this  .  numberOfArgs  =  num  ;    ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  numberOfArgs  =  1;	[BUGGY]  this  .  numberOfArgs  =  1  >>>  0  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  [ATTENTION]  this  .  numberOfArgs  =  1  >>>  0  ;  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[ADD]  this  .  numberOfArgs  =  1;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  [ATTENTION]  }  this  .  hasArg  =  hasArg  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  hasArg  =  hasArg;	[BUGGY]  this  .  hasArg  =    required  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  [ATTENTION]  this  .  hasArg  =  required  ;  this  .  description  =  description  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  description  =  description;	[BUGGY]  this  .  description  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  throws  IllegalArgumentException  {    OptionValidator  .  validateOption  (  opt  )  ;    this  .  opt  =  opt  ;  this  .  longOpt  =  longOpt  ;      if  (  hasArg  )  {  this  .  numberOfArgs  =  1  ;  }  this  .  hasArg  =  hasArg  ;  [ATTENTION]  this  .  description  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  getKey  (  )    .  charAt  (  0  )  ;	[BUGGY]  return  getKey  (  )  .  indexOf  (  0  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  int  getId  (  )  {  [ATTENTION]  return  getKey  (  )    .  indexOf  (  0  )    ;  }    [METHOD]  getId  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  if  (  opt  ==  null  )  {	[BUGGY]  if  (  opt  !  =  false  )  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  String  getKey  (  )  {    [ATTENTION]  if  (  opt  !  =  false  )  {  return  this  .  longOpt  ;  }  return  this  .  opt  ;  }    [METHOD]  getKey  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  longOpt;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  String  getKey  (  )  {    if  (  opt  =  =  null  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }  return  this  .  opt  ;  }    [METHOD]  getKey  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  opt;	[BUGGY]  return  this  .  type  ;  [CE]  incompatible  types  [CONTEXT]  String  getKey  (  )  {    if  (  opt  =  =  null  )  {  return  this  .  longOpt  ;  }  [ATTENTION]  return  this  .  type  ;  }    [METHOD]  getKey  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  opt;	[BUGGY]  return  this  .  type  ;  [CE]  incompatible  types  [CONTEXT]  public  String  getOpt  (  )  {  [ATTENTION]  return  this  .  type  ;  }    [METHOD]  getOpt  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  type;	[BUGGY]  return  this  .  opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Object  getType  (  )  {  [ATTENTION]  return  this  .  opt  ;  }    [METHOD]  getType  [TYPE]  Object  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  type  =  type;	[BUGGY]  this  .  type  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setType  (  Object  type  )  {  [ATTENTION]  this  .  type  =  null  ;  }    [METHOD]  setType  [TYPE]  void  [PARAMETER]  Object  type  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  longOpt;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  String  getLongOpt  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getLongOpt  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  longOpt  =  longOpt;	[BUGGY]  this  .  longOpt  =    opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setLongOpt  (  String  longOpt  )  {  [ATTENTION]  this  .  longOpt  =  opt  ;  }    [METHOD]  setLongOpt  [TYPE]  void  [PARAMETER]  String  longOpt  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  optionalArg  =  optionalArg;	[BUGGY]  this  .  optionalArg  =    true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setOptionalArg  (  boolean  optionalArg  )  {  [ATTENTION]  this  .  optionalArg  =  true  ;  }    [METHOD]  setOptionalArg  [TYPE]  void  [PARAMETER]  boolean  optionalArg  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  optionalArg;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  boolean  hasOptionalArg  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  hasOptionalArg  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  (  this  .  longOpt  !=  null  )  ;	[BUGGY]  return  (  this  .  longOpt  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  hasLongOpt  (  )  {  [ATTENTION]  return  (  this  .  longOpt  ;  }    [METHOD]  hasLongOpt  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  (  this  .  numberOfArgs  >  0  )  ||  (  numberOfArgs  ==  UNLIMITED_VALUES  )  ;	[BUGGY]  return  (  this  .  numberOfArgs  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  hasArg  (  )  {  [ATTENTION]  return  (  this  .  numberOfArgs  ;  }    [METHOD]  hasArg  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  description;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  String  getDescription  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getDescription  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  description  =  description;	[BUGGY]  this  .  description  =    opt  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setDescription  (  String  description  )  {  [ATTENTION]  this  .  description  =  opt  ;  }    [METHOD]  setDescription  [TYPE]  void  [PARAMETER]  String  description  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  required;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  boolean  isRequired  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  isRequired  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  required  =  required;	[BUGGY]  this  .  required  =    true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setRequired  (  boolean  required  )  {  [ATTENTION]  this  .  required  =  true  ;  }    [METHOD]  setRequired  [TYPE]  void  [PARAMETER]  boolean  required  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[ADD]  this  .  required  =  required;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setRequired  (  boolean  required  )  {  [ATTENTION]  }    [METHOD]  setRequired  [TYPE]  void  [PARAMETER]  boolean  required  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  argName  =  argName;	[BUGGY]  this  .  argName  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setArgName  (  String  argName  )  {  [ATTENTION]  this  .  argName  =  null  ;  }    [METHOD]  setArgName  [TYPE]  void  [PARAMETER]  String  argName  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  this  .  argName;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  String  getArgName  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getArgName  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  (  this  .  argName  !=  null  &&  this  .  argName  .  length  (  )  >  0  )  ;	[BUGGY]  return  (  this  .  argName  !  =  null  &&  this  .  argName  .  charAt  (  )  >  0  )  ;  [CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  boolean  hasArgName  (  )  {  [ATTENTION]  return  (  this  .  argName  !  =  null  &&  this  .  argName  .  charAt  (  )  >  0  )    ;  }    [METHOD]  hasArgName  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  return  (  this  .  numberOfArgs  >  1  )  ||  (  this  .  numberOfArgs  ==  UNLIMITED_VALUES  )  ;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  hasArgs  (  )  {  [ATTENTION]  return  false  ;    }    [METHOD]  hasArgs  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  numberOfArgs  
[REPLACE]  this  .  numberOfArgs  =  num;	[BUGGY]  this  .  numberOfArgs  =  1  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setArgs  (  int  num  )  {  [ATTENTION]  this  .  numberOfArgs  =  1  ;    ;  }    [METHOD]  setArgs  [TYPE]  void  [PARAMETER]  int  num  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  this  .  valuesep  =  sep;	[BUGGY]  this  .  valuesep  =    valuesep  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setValueSeparator  (  char  sep  )  {  [ATTENTION]  this  .  valuesep  =  valuesep  ;  }    [METHOD]  setValueSeparator  [TYPE]  void  [PARAMETER]  char  sep  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  return  this  .  valuesep;	[BUGGY]  return  this  .  values  ;  [CE]  incompatible  types  [CONTEXT]  public  char  getValueSeparator  (  )  {  [ATTENTION]  return  this  .  values  ;  }    [METHOD]  getValueSeparator  [TYPE]  char  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  return  (  this  .  valuesep  >  0  )  ;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  hasValueSeparator  (  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  hasValueSeparator  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  return  this  .  numberOfArgs;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  int  getArgs  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getArgs  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  void  addValue  (  String  value  )  {  switch  (  numberOfArgs  )  {  case  UNINITIALIZED:  [ATTENTION]  return  ;    default:  processValue  (  value  )  ;  }  }    [METHOD]  addValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[ADD]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  void  addValue  (  String  value  )  {  switch  (  numberOfArgs  )  {  case  UNINITIALIZED:  [ATTENTION]    default:  processValue  (  value  )  ;  }  }    [METHOD]  addValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  processValue  (  value  )  ;	[BUGGY]  processValue  (  argName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  void  addValue  (  String  value  )  {  switch  (  numberOfArgs  )  {  case  UNINITIALIZED:  throw  new  RuntimeException  (   "NO_ARGS_ALLOWED "  )  ;    default:  [ATTENTION]  processValue  (  argName  )    ;  }  }    [METHOD]  addValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[ADD]  processValue  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  void  addValue  (  String  value  )  {  switch  (  numberOfArgs  )  {  case  UNINITIALIZED:  throw  new  RuntimeException  (   "NO_ARGS_ALLOWED "  )  ;    default:  [ATTENTION]  }  }    [METHOD]  addValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  num  numberOfArgs  
[REPLACE]  while  (  index  !=  -1  )  {	[BUGGY]  while  (  index    =  =    -1  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      [ATTENTION]  while  (  index  =  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  while  (  index  !=  -1  )  {	[BUGGY]  [CE]  invalid  method  declaration  ;  return  type  required  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      [ATTENTION]    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {	[BUGGY]  if  (  values  .  size  (  )  +  3  =  =    (  numberOfArgs  -  1  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  index  !  =  -1  )  {    [ATTENTION]  if  (  values  .  size  (  )  +  3  =  =  (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ;	[BUGGY]  value  =  value  .  substring  (  numberOfArgs  +  1  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      [ATTENTION]  value  =  value  .  substring  (  numberOfArgs  +  1  )    ;      index  =  value  .  indexOf  (  sep  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  index  =    argName  .  indexOf  (  sep  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      [ATTENTION]  index  =  argName  .  indexOf  (  sep  )    ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  hasValueSeparator  (  )  )  {	[BUGGY]  if  (  hasArg  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    [ATTENTION]  if  (  hasArg  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  if  (  hasValueSeparator  (  )  )  {  char  sep  =  getValueSeparator  (  )  ;	[BUGGY]  [CE]  invalid  method  declaration  ;  return  type  required  [CONTEXT]  {    [ATTENTION]          int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  while  (  index  !=  -1  )  {	[BUGGY]  while  (  numberOfArgs    =  =    -3  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      [ATTENTION]  while  (  numberOfArgs  =  =  -3  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {	[BUGGY]  if  (  values  .  ArrayList  (  )    +  3  =  =    (  numberOfArgs  -  0  )  )  {[CE]  cannot  find  symbol  [CONTEXT]  while  (  index  !  =  -1  )  {    [ATTENTION]  if  (  values  .  ArrayList  (  )  +  3  =  =  (  numberOfArgs  -  0  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {  break;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  index  !  =  -1  )  {    [ATTENTION]          add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ;	[BUGGY]  value  =  value  .  substring  (  index  +numberOfArgs  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      [ATTENTION]  value  =  value  .  substring  (  index  +numberOfArgs  )    ;      index  =  value  .  indexOf  (  sep  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {	[BUGGY]  if  (  values  .  length  (  )    =  =    (  numberOfArgs  -  0  )  )  {[CE]  cannot  find  symbol  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    [ATTENTION]  if  (  values  .  length  (  )  =  =  (  numberOfArgs  -  0  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {  break;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    [ATTENTION]          add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ;	[BUGGY]  value  =  value  .  substring  (numberOfArgs  +  1  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      [ATTENTION]  value  =  value  .  substring  (  numberOfArgs  +  1  )    ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  index  =    argName  .  indexOf  (  sep  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      [ATTENTION]  index  =  argName  .  indexOf  (  sep  )    ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      [ATTENTION]  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  char  sep  =  getValueSeparator  (  )  ;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  int  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  int  index  =  value  .  indexOf  (  valuesep  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      [ATTENTION]  int  index  =  value  .  indexOf  (  valuesep  )    ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {	[BUGGY]  if  (  values  .  add  (  )  +  4  =  =    (  numberOfArgs  -  1  )  )  {[CE]  no  suitable  method  found  for  add()  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    [ATTENTION]  if  (  values  .  add  (  )  +  4  =  =  (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ;	[BUGGY]  value  =  value  .  substring  (  index    =  =    1  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      [ATTENTION]  value  =  value  .  substring  (  index  =  =  1  )    ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  index  =    argName  .  indexOf  (  sep  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      [ATTENTION]  index  =  argName  .  indexOf  (  sep  )    ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      [ATTENTION]  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  char  sep  =  getValueSeparator  (  )  ;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  int  index  =  value  .  indexOf  (  sep  )  ;	[BUGGY]  int  index  =  value  .  hashCode  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      [ATTENTION]  int  index  =  value  .  hashCode  (  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      add  (  value  )  ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  add  (  value  )  ;	[BUGGY]  add  (  argName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  hasValueSeparator  (  )  )  {    char  sep  =  getValueSeparator  (  )  ;      int  index  =  value  .  indexOf  (  sep  )  ;      while  (  index  !  =  -1  )  {    if  (  values  .  size  (  )    =  =    (  numberOfArgs  -  1  )  )  {  break  ;  }      add  (  value  .  substring  (  0  ,  index  )  )  ;      value  =  value  .  substring  (  index  +  1  )  ;      index  =  value  .  indexOf  (  sep  )  ;  }  }      [ATTENTION]  add  (  argName  )    ;  }    [METHOD]  processValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  (  numberOfArgs  >  0  )  &&  (  values  .  size  (  )  >  (  numberOfArgs  -  1  )  )  )  {	[BUGGY]  if  (    (  values  .  ArrayList  (  )    %  2  >  (  numberOfArgs  -  1  )  )  )  {[CE]  cannot  find  symbol  [CONTEXT]  private  void  add  (  String  value  )  {  [ATTENTION]  if  (    (  values  .  ArrayList  (  )  %2  >  (  numberOfArgs  -  1  )  )  )  {  throw  new  RuntimeException  (   "Cannot  add  value  ,  list  full  .   "  )  ;  }      this  .  values  .  add  (  value  )  ;  }    [METHOD]  add  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  add  (  String  value  )  {  if  (  (  numberOfArgs  >  0  )  &&  (  values  .  size  (  )  >  (  numberOfArgs  -  1  )  )  )  {  [ATTENTION]  return  ;  }      this  .  values  .  add  (  value  )  ;  }    [METHOD]  add  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  this  .  values  .  add  (  value  )  ;	[BUGGY]  this  .  values  .  add  (  argName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  add  (  String  value  )  {  if  (  (  numberOfArgs  >  0  )  &&  (  values  .  size  (  )  >  (  numberOfArgs  -  1  )  )  )  {  throw  new  RuntimeException  (   "Cannot  add  value  ,  list  full  .   "  )  ;  }      [ATTENTION]  this  .  values  .  add  (  argName  )    ;  }    [METHOD]  add  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  get  (  0  )  ;	[BUGGY]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  ArrayList  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  getValue  (  )  {  [ATTENTION]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  ArrayList  (  )  ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  get  (  index  )  ;	[BUGGY]  return  hasNoValues  (  )  ?  this  :  (  String  )  this  .  values  .  get  (  index  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  getValue  (  int  index  )  throws  IndexOutOfBoundsException  {  [ATTENTION]  return  hasNoValues  (  )  ?  this  :  (  String  )  this  .  values  .  get  (  index  )    ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  int  index  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  String  value  =  getValue  (  )  ;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  public  String  getValue  (  String  defaultValue  )  {  [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;    return  (  value  !  =  null  )  ?  value  :  defaultValue  ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  String  defaultValue  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  String  value  =  getValue  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  value  [CONTEXT]  public  String  getValue  (  String  defaultValue  )  {  [ATTENTION]    return  (  value  !  =  null  )  ?  value  :  defaultValue  ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  String  defaultValue  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  (  value  !=  null  )  ?  value  :  defaultValue;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  String  getValue  (  String  defaultValue  )  {  String  value  =  getValue  (  )  ;    [ATTENTION]  return  false  ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  String  defaultValue  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String[]  )  this  .  values  .  toArray  (  new  String[]  {  }  )  ;	[BUGGY]  return  hasNoValues  (  )  ?  this  :  (  String[]  )  this  .  values  .  toArray  (  new  String[]  {  }  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String[]  getValues  (  )  {  [ATTENTION]  return  hasNoValues  (  )  ?  this  :  (  String[]  )  this  .  values  .  toArray  (  new  String[]  {}  )    ;    }    [METHOD]  getValues  [TYPE]  String[]  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  this  .  values;	[BUGGY]  return  this  .  valuesep  ;  [CE]  incompatible  types  [CONTEXT]  public  java  .  util  .  List  getValuesList  (  )  {  [ATTENTION]  return  this  .  valuesep  ;  }    [METHOD]  getValuesList  [TYPE]  List  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  StringBuffer  buf  =  new  StringBuffer  (  )    .  append  (   "[  option:   "  )  ;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  {  [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  StringBuffer  buf  =  new  StringBuffer  (  )    .  append  (   "[  option:   "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  buf  [CONTEXT]  {  [ATTENTION]    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (  this  .  opt  )  ;	[BUGGY]  buf  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    [ATTENTION]  buf  .  toString  (  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  this  .  longOpt  !=  null  )  {	[BUGGY]  if  (  this  .  longOpt  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    [ATTENTION]  if  (  this  .  longOpt  =  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  if  (  this  .  longOpt  !=  null  )  {  buf  .  append  (   "   "  )    .  append  (  this  .  longOpt  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    [ATTENTION]      buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "   "  )    .  append  (  this  .  longOpt  )  ;	[BUGGY]  buf  .  append  (   "+ARG "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  this  .  longOpt  !  =  null  )  {  [ATTENTION]  buf  .  append  (   "+ARG "  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  buf  .  append  (   "   "  )    .  append  (  this  .  longOpt  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  this  .  longOpt  !  =  null  )  {  [ATTENTION]  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "   "  )    .  append  (  this  .  longOpt  )  ;	[BUGGY]  buf  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  this  .  longOpt  !  =  null  )  {  [ATTENTION]  buf  .  toString  (  )  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "   "  )  ;	[BUGGY]  buf  .  append  (   "  ] "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  [ATTENTION]  buf  .  append  (   "  ] "  )    ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  hasArg  )  {	[BUGGY]  if  (  opt  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    [ATTENTION]  if  (  opt  =  =  null  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "+ARG "  )  ;	[BUGGY]  add  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  if  (  hasArg  )  {  [ATTENTION]  add  (  value  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "  ::   "  )    .  append  (  this  .  description  )  ;	[BUGGY]  this  (  opt  ,  null  ,  false  ,  description  )  ;  [CE]  call  to  this  must  be  first  statement  in  constructor  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  [ATTENTION]  this  (  opt  ,  null  ,  false  ,  description  )    ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "  ::   "  )    .  append  (  this  .  description  )  ;	[BUGGY]  buf  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  [ATTENTION]  buf  .  toString  (  )    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  this  .  type  !=  null  )  {	[BUGGY]  if  (  this  .  type  =  =  this  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    [ATTENTION]  if  (  this  .  type  =  =  this  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "  ::   "  )    .  append  (  this  .  type  )  ;	[BUGGY]  buf  .  toString  (  )[CE]  '  ;  '  expected  [CONTEXT]  if  (  this  .  type  !  =  null  )  {  [ATTENTION]  buf  .  toString  (  )  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  buf  .  append  (   "  ::   "  )    .  append  (  this  .  type  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  this  .  type  !  =  null  )  {  [ATTENTION]  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "  ::   "  )    .  append  (  this  .  type  )  ;	[BUGGY]  buf  .  append  (   "+ARG "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  this  .  type  !  =  null  )  {  [ATTENTION]  buf  .  append  (   "+ARG "  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  buf  .  append  (   "  ] "  )  ;	[BUGGY]  buf  .  append  (   "   "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  [ATTENTION]  buf  .  append  (   "   "  )    ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  buf  .  toString  (  )  ;	[BUGGY]  return  buf  .  StringBuffer  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  {  StringBuffer  buf  =  new  StringBuffer  (  )  .  append  (   "[  option:   "  )  ;    buf  .  append  (  this  .  opt  )  ;    if  (  this  .  longOpt  !  =  null  )  {  buf  .  append  (   "   "  )  .  append  (  this  .  longOpt  )  ;  }  buf  .  append  (   "   "  )  ;    if  (  hasArg  )  {  buf  .  append  (   "+ARG "  )  ;  }  buf  .  append  (   "  ::   "  )  .  append  (  this  .  description  )  ;    if  (  this  .  type  !  =  null  )  {  buf  .  append  (   "  ::   "  )  .  append  (  this  .  type  )  ;  }  buf  .  append  (   "  ] "  )  ;    [ATTENTION]  return  buf  .  StringBuffer  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Option    [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  this  .  values  .  size  (  )  ==  0;	[BUGGY]  return  this  .  values  .  ArrayList  (  )    =  =  0L  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  boolean  hasNoValues  (  )  {  [ATTENTION]  return  this  .  values  .  ArrayList  (  )    =  =  0L  ;  }    [METHOD]  hasNoValues  [TYPE]  boolean  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  this  ==  o  )  {	[BUGGY]  if  (  option  ||  o  )  {[CE]  cannot  find  symbol  option  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  option||o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[ADD]  if  (  this  ==  o  )  {  return  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]      if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  [ATTENTION]  return  false  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )    )  {	[BUGGY]  if  (  o  !  =  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  [ATTENTION]  if  (  o  !  =  true  )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  [ATTENTION]  return  true  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  Option  option  =  (  Option  )  o;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  opt  !=  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !=  null  )  {	[BUGGY]  if  (  opt  =  =  this  ?  !opt  .  substring  (  option  .  opt  )  :  option  .  opt  !  =  this  )  {[CE]  incomparable  types:  String  and  Option  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    [ATTENTION]  if  (  opt  =  =  this  ?  !opt  .  substring  (  option  .  opt  )  :  option  .  opt  !  =  this  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  [ATTENTION]  return  true  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  if  (  longOpt  !=  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !=  null  )  {	[BUGGY]  if  (  longOpt  !  =    option  .  longOpt  =  =  false  )  {[CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  [ATTENTION]  if  (  longOpt  !  =  option  .  longOpt  =  =  false  )  {  return  false  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  [ATTENTION]  return  true  ;  }  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  {  return  true  ;  }  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )    )  {  return  false  ;  }  Option  option  =    (  Option  )  o  ;    if  (  opt  !  =  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !  =  null  )  {  return  false  ;  }  if  (  longOpt  !  =  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !  =  null  )  {  return  false  ;  }  [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  Option  option  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  
[REPLACE]  int  result;	[BUGGY]  int  index  =  value  .  indexOf  (  sep  )  ;  [CE]  cannot  find  symbol  sep  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  int  index  =  value  .  indexOf  (  sep  )    ;  result  =    (  opt  !  =  null  ?  opt  .  hashCode  (  )  :  0  )  ;  result  =  31  *  result  +  (  longOpt  !  =  null  ?  longOpt  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  result  
[REPLACE]  result  =  (  opt  !=  null  ?  opt  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  ;  [ATTENTION]  result  =  0  )    ;  result  =  31  *  result  +  (  longOpt  !  =  null  ?  longOpt  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  result  
[ADD]  result  =  (  opt  !=  null  ?  opt  .  hashCode  (  )  :  0  )  ;	[BUGGY]  [CE]  variable  result  might  not  have  been  initialized  [CONTEXT]  public  int  hashCode  (  )  {  int  result  ;  [ATTENTION]  result  =  31  *  result  +  (  longOpt  !  =  null  ?  longOpt  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  result  
[REPLACE]  result  =  31  *  result  +  (  longOpt  !=  null  ?  longOpt  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  ;  result  =    (  opt  !  =  null  ?  opt  .  hashCode  (  )  :  0  )  ;  [ATTENTION]  result  =  0  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  result  
[REPLACE]  return  result;	[BUGGY]  return  numberOfArgs  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  int  hashCode  (  )  {  int  result  ;  result  =    (  opt  !  =  null  ?  opt  .  hashCode  (  )  :  0  )  ;  result  =  31  *  result  +  (  longOpt  !  =  null  ?  longOpt  .  hashCode  (  )  :  0  )  ;  [ATTENTION]  return  numberOfArgs  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Option    [TYPE]  boolean  false  hasArg  optionalArg  required  true  [TYPE]  ArrayList  values  [TYPE]  char  sep  valuesep  [TYPE]  Object  o  type  [TYPE]  String  argName  defaultValue  description  longOpt  opt  value  [TYPE]  int  UNINITIALIZED  UNLIMITED_VALUES  index  num  numberOfArgs  result  
[REPLACE]  return  createValue  (  str,  (  Class  )  obj  )  ;	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  unreported  exception  ClassNotFoundException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  static  Object  createValue  (  String  str  ,  Object  obj  )  {  [ATTENTION]  return  Class  .  forName  (  str  )    ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Object  obj  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Object  obj  [TYPE]  String  str  
[REPLACE]  if  (  PatternOptionBuilder  .  STRING_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  STRING_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  [ATTENTION]  if  (  PatternOptionBuilder  .  STRING_VALUE&&clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  [ATTENTION]  else  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  NUMBER_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  NUMBER_VALUE!  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  DATE_VALUE  !  =  true  )  {[CE]  incomparable  types:  Class  and  boolean  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  DATE_VALUE!  =  true  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {  return  createDate  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  else  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  else  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {  return  createFile  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE!  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILES_VALUE!  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE||clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {  return  createURL  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]      else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  false  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createURL  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createURL  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  true  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFiles  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  this  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFiles  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  false  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFile  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {  return  createFiles  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  this  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFile  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFile  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE||clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REMOVE]  	[BUGGY]  if  (  (  FILE_VALUE  )    =  =  clazz  )  {      return  createFile  (  str  )  ;  }else      if  (  (  EXISTING_FILE_VALUE  )    =  =  clazz  )  {          return  createFile  (  str  )  ;      }else          if  (  (  FILES_VALUE  )    =  =  clazz  )  {              return  createFiles  (  str  )  ;          }else              if  (  (  URL_VALUE  )    =  =  clazz  )  {                  return  createURL  (  str  )  ;              }else  {                  return  null  ;              }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )    if  (  (  FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  EXISTING_FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  FILES_VALUE  )  =  =  clazz  )  {  return  createFiles  (  str  )    ;  }else  if  (  (  URL_VALUE  )  =  =  clazz  )  {  return  createURL  (  str  )    ;  }else  {  return  null  ;  }{  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REMOVE]  	[BUGGY]  if  (  (  FILE_VALUE  )    =  =  clazz  )  {      return  createFile  (  str  )  ;  }else      if  (  (  EXISTING_FILE_VALUE  )    =  =  clazz  )  {          return  createFile  (  str  )  ;      }else          if  (  (  FILES_VALUE  )    =  =  clazz  )  {              return  createFiles  (  str  )  ;          }else              if  (  (  URL_VALUE  )    =  =  clazz  )  {                  return  createURL  (  str  )  ;              }else  {                  return  null  ;              }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )    if  (  (  FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  EXISTING_FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  FILES_VALUE  )  =  =  clazz  )  {  return  createFiles  (  str  )    ;  }else  if  (  (  URL_VALUE  )  =  =  clazz  )  {  return  createURL  (  str  )    ;  }else  {  return  null  ;  }{  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE||clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE!  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  [ATTENTION]  return  true  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE!  =  this  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createFile  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createClass  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILE_VALUE  &&  null  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILE_VALUE&&  null  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {  return  createFile  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE||clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  1  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&  1  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE!  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  ||  true  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE||  true  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createClass  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createDate  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {  return  createClass  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE!  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE!  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE!  =  null  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE&&clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ||  null  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE||  null  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createDate  (  str  )  ;	[BUGGY]  return  createObject  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createObject  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createNumber  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  DATE_VALUE||clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  CLASS_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  CLASS_VALUE!  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILE_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILE_VALUE&&clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE||clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILES_VALUE||clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE!  =  this  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILE_VALUE||clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  &&  null  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE&&  null  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILES_VALUE&&clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE&&clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  &&  false  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE&&  false  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  ||  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE||  this  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  false  )  {[CE]  incomparable  types:  Class  and  boolean  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE!  =  false  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createNumber  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createObject  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  [ATTENTION]  else  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  {  return  createNumber  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  DATE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  DATE_VALUE||clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE&&clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  false  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&  false  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILE_VALUE&&clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  ||  true  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE||  true  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE!  =  null  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  DATE_VALUE!  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  &&  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE&&  this  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  !  =  0  )  {[CE]  incomparable  types:  Class  and  int  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILE_VALUE!  =  0  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  true  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&  true  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REMOVE]  	[BUGGY]  if  (  (  FILE_VALUE  )    =  =  clazz  )  {      return  createFile  (  str  )  ;  }else      if  (  (  EXISTING_FILE_VALUE  )    =  =  clazz  )  {          return  createFile  (  str  )  ;      }else          if  (  (  FILES_VALUE  )    =  =  clazz  )  {              return  createFiles  (  str  )  ;          }else              if  (  (  URL_VALUE  )    =  =  clazz  )  {                  return  createURL  (  str  )  ;              }else  {                  return  null  ;              }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )    if  (  (  FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  EXISTING_FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  FILES_VALUE  )  =  =  clazz  )  {  return  createFiles  (  str  )    ;  }else  if  (  (  URL_VALUE  )  =  =  clazz  )  {  return  createURL  (  str  )    ;  }else  {  return  null  ;  }{  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  createObject  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  str;	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  unreported  exception  ClassNotFoundException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  [ATTENTION]  return  Class  .  forName  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[ADD]  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  ==  clazz  )  {  return  createObject  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  [ATTENTION]      else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  else  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILE_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILE_VALUE||clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ||  null  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  FILE_VALUE||  null  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  CLASS_VALUE  ||  null  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  CLASS_VALUE||  null  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE&&clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  ||  null  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE||  null  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  ||  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE||  this  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REMOVE]  	[BUGGY]  if  (  (  FILE_VALUE  )    =  =  clazz  )  {      return  createFile  (  str  )  ;  }else      if  (  (  EXISTING_FILE_VALUE  )    =  =  clazz  )  {          return  createFile  (  str  )  ;      }else          if  (  (  FILES_VALUE  )    =  =  clazz  )  {              return  createFiles  (  str  )  ;          }else              if  (  (  URL_VALUE  )    =  =  clazz  )  {                  return  createURL  (  str  )  ;              }else  {                  return  null  ;              }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )    if  (  (  FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  EXISTING_FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  FILES_VALUE  )  =  =  clazz  )  {  return  createFiles  (  str  )    ;  }else  if  (  (  URL_VALUE  )  =  =  clazz  )  {  return  createURL  (  str  )    ;  }else  {  return  null  ;  }{  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  &&  null  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE&&  null  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE!  =  null  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE&&clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  &&  null  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE&&  null  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ||  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE||  this  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&  this  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ||  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  NUMBER_VALUE||clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REMOVE]  	[BUGGY]  if  (  (  FILE_VALUE  )    =  =  clazz  )  {      return  createFile  (  str  )  ;  }else      if  (  (  EXISTING_FILE_VALUE  )    =  =  clazz  )  {          return  createFile  (  str  )  ;      }else          if  (  (  FILES_VALUE  )    =  =  clazz  )  {              return  createFiles  (  str  )  ;          }else              if  (  (  URL_VALUE  )    =  =  clazz  )  {                  return  createURL  (  str  )  ;              }else  {                  return  null  ;              }[CE]  'else'  without  'if'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )    if  (  (  FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  EXISTING_FILE_VALUE  )  =  =  clazz  )  {  return  createFile  (  str  )    ;  }else  if  (  (  FILES_VALUE  )  =  =  clazz  )  {  return  createFiles  (  str  )    ;  }else  if  (  (  URL_VALUE  )  =  =  clazz  )  {  return  createURL  (  str  )    ;  }else  {  return  null  ;  }{  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  CLASS_VALUE  &&  clazz  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  CLASS_VALUE&&clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  &&  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE&&  this  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILE_VALUE  !  =  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILE_VALUE!  =  this  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILE_VALUE  !  =    clazz  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILE_VALUE!  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  FILES_VALUE  &&  0  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  FILES_VALUE&&  0  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  else  if  (  PatternOptionBuilder  .  URL_VALUE  !  =  false  )  {[CE]  incomparable  types:  Class  and  boolean  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  else  if  (  PatternOptionBuilder  .  URL_VALUE!  =  false  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {	[BUGGY]  if  (  PatternOptionBuilder  .  URL_VALUE  &&  null  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  [ATTENTION]  if  (  PatternOptionBuilder  .  URL_VALUE&&  null  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  return  str;	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  unreported  exception  ClassNotFoundException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  {  if  (  PatternOptionBuilder  .  STRING_VALUE  =  =  clazz  )  {  [ATTENTION]  return  Class  .  forName  (  str  )    ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  createURL  (  str  )  ;  }  else  {  return  null  ;  }  }    [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class  clazz  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  
[REPLACE]  Class  cl  =  null;	[BUGGY]  Class  cl  =  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  {  [ATTENTION]  Class  cl  =  this  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[ADD]  Class  cl  =  null;	[BUGGY]  [CE]  cannot  find  symbol  cl  [CONTEXT]  {  [ATTENTION]    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[ADD]  try  {  cl  =  Class  .  forName  (  str  )  ;  }	[BUGGY]  cl  =  Class  .  forName  (  str  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  {  Class  cl  =  null  ;    [ATTENTION]  cl  =  Class  .  forName  (  str  )    ;      catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  cl  =  Class  .  forName  (  str  )  ;	[BUGGY]  cl  =    Class  .  forName  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  try  {  [ATTENTION]  cl  =  Class  .  forName  (  null  )    ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  cl  =  Class  .  forName  (  str  )  ;	[BUGGY]  cl  =    Class  .  forName  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  Class  cl  =  null  ;    try  {  [ATTENTION]  cl  =  Class  .  forName  (  null  )    ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    [ATTENTION]  return  false  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  Object  instance  =  null;	[BUGGY]  Object  instance  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  [ATTENTION]  Object  instance  =  false  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[ADD]  try  {  instance  =  cl  .  newInstance  (  )  ;  }	[BUGGY]  instance  =  cl  .  newInstance  (  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    [ATTENTION]  instance  =  cl  .  newInstance  (  )    ;      catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  instance  =  cl  .  newInstance  (  )  ;	[BUGGY]  instance  =    null  .  newInstance  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  try  {  [ATTENTION]  instance  =  null  .  newInstance  (  )    ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  instance  =  cl  .  newInstance  (  )  ;	[BUGGY]  instance  =    null  .  newInstance  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  [ATTENTION]  instance  =  null  .  newInstance  (  )    ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    [ATTENTION]  return  true  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    [ATTENTION]  return  false  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[ADD]  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException;  Unable  to  create:   "	[BUGGY]  [CE]  'try'  without  'catch'  ,  'finally'  or  resource  declarations  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  [ATTENTION]    +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  return  instance  ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[REPLACE]  return  instance;	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  unreported  exception  ClassNotFoundException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  {  Class  cl  =  null  ;    try  {  cl  =  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  Object  instance  =  null  ;    try  {  instance  =  cl  .  newInstance  (  )  ;  }  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (   "InstantiationException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  catch  (  IllegalAccessException  cnfe  )  {  System  .  err  .  println  (   "IllegalAccessException  ;  Unable  to  create:   "  +  str  )  ;    return  null  ;  }  [ATTENTION]  return  Class  .  forName  (  str  )    ;  }    [METHOD]  createObject  [TYPE]  Object  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  Class  cl  [TYPE]  Object  instance  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  [TYPE]  InstantiationException  cnfe  [TYPE]  IllegalAccessException  cnfe  
[ADD]  try  {  return  NumberUtils  .  createNumber  (  str  )  ;  }	[BUGGY]  return  NumberUtils  .  createNumber  (  str  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  {    [ATTENTION]  return  NumberUtils  .  createNumber  (  str  )    ;        catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (  nfe  .  getMessage  (  )  )  ;    return  null  ;  }  }    [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  NumberFormatException  nfe  [TYPE]  String  str  
[REPLACE]  return  NumberUtils  .  createNumber  (  str  )  ;	[BUGGY]  return    str    ;  [CE]  incompatible  types  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  {    try  {    [ATTENTION]  return  str  ;  }  catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (  nfe  .  getMessage  (  )  )  ;    return  null  ;  }  }    [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  NumberFormatException  nfe  [TYPE]  String  str  
[REPLACE]  return  NumberUtils  .  createNumber  (  str  )  ;	[BUGGY]  return  NumberUtils  .  createValue  (  str  ,  this  )    ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  {    try  {    [ATTENTION]  return  NumberUtils  .  createValue  (  str  ,  this  )  ;  }  catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (  nfe  .  getMessage  (  )  )  ;    return  null  ;  }  }    [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  NumberFormatException  nfe  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  {    try  {    return  NumberUtils  .  createNumber  (  str  )  ;  }  catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (  nfe  .  getMessage  (  )  )  ;    [ATTENTION]  return  false  ;  }  }    [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  NumberFormatException  nfe  [TYPE]  String  str  
[ADD]  try  {  return  Class  .  forName  (  str  )  ;  }	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  public  static  Class  createClass  (  String  str  )  {  [ATTENTION]  return  Class  .  forName  (  str  )    ;      catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  }    [METHOD]  createClass  [TYPE]  Class  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  
[REPLACE]  return  Class  .  forName  (  str  )  ;	[BUGGY]  return    str    ;  [CE]  incompatible  types  [CONTEXT]  public  static  Class  createClass  (  String  str  )  {  try  {  [ATTENTION]  return  str  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    return  null  ;  }  }    [METHOD]  createClass  [TYPE]  Class  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  Class  createClass  (  String  str  )  {  try  {  return  Class  .  forName  (  str  )  ;  }  catch  (  ClassNotFoundException  cnfe  )  {  System  .  err  .  println  (   "Unable  to  find:   "  +  str  )  ;    [ATTENTION]  return  this  ;  }  }    [METHOD]  createClass  [TYPE]  Class  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  ClassNotFoundException  cnfe  
[REPLACE]  Date  date  =  null;	[BUGGY]  Date  date  =  false  ;  [CE]  incompatible  types  [CONTEXT]  public  static  Date  createDate  (  String  str  )  {  [ATTENTION]  Date  date  =  false  ;    if  (  date  =  =  null  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;  }  return  date  ;  }    [METHOD]  createDate  [TYPE]  Date  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  Date  date  
[REPLACE]  if  (  date  ==  null  )  {	[BUGGY]  if  (  date  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Date  createDate  (  String  str  )  {  Date  date  =  null  ;    [ATTENTION]  if  (  date  !  =  null  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;  }  return  date  ;  }    [METHOD]  createDate  [TYPE]  Date  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  Date  date  
[REPLACE]  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;	[BUGGY]  System  .  err  .  println  (   "Unable  to  parse:   "  ||  str  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  public  static  Date  createDate  (  String  str  )  {  Date  date  =  null  ;    if  (  date  =  =  null  )  {  [ATTENTION]  System  .  err  .  println  (   "Unable  to  parse:   "||str  )    ;  }  return  date  ;  }    [METHOD]  createDate  [TYPE]  Date  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  Date  date  
[REPLACE]  return  date;	[BUGGY]  return  Class  .  forName  (  str  )  ;  [CE]  incompatible  types  [CONTEXT]  public  static  Date  createDate  (  String  str  )  {  Date  date  =  null  ;    if  (  date  =  =  null  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;  }  [ATTENTION]  return  Class  .  forName  (  str  )    ;  }    [METHOD]  createDate  [TYPE]  Date  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  Date  date  
[ADD]  try  {  return  new  URL  (  str  )  ;  }	[BUGGY]  return  new  URL  (  str  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  public  static  URL  createURL  (  String  str  )  {  [ATTENTION]  return  new  URL  (  str  )    ;      catch  (  MalformedURLException  mue  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;    return  null  ;  }  }    [METHOD]  createURL  [TYPE]  URL  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  MalformedURLException  mue  [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  new  URL  (  str  )  ;	[BUGGY]  return  new  File  (  str  )    ;  [CE]  incompatible  types  [CONTEXT]  public  static  URL  createURL  (  String  str  )  {  try  {  [ATTENTION]  returnnew  File  (  str  )  ;  }  catch  (  MalformedURLException  mue  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;    return  null  ;  }  }    [METHOD]  createURL  [TYPE]  URL  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  MalformedURLException  mue  [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  URL  createURL  (  String  str  )  {  try  {  return  new  URL  (  str  )  ;  }  catch  (  MalformedURLException  mue  )  {  System  .  err  .  println  (   "Unable  to  parse:   "  +  str  )  ;    [ATTENTION]  return  this  ;  }  }    [METHOD]  createURL  [TYPE]  URL  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  MalformedURLException  mue  [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  new  File  (  str  )  ;	[BUGGY]  return  createFile  (  str  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  File  createFile  (  String  str  )  {  [ATTENTION]  return  createFile  (  str  )    ;  }    [METHOD]  createFile  [TYPE]  File  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  File[]  createFiles  (  String  str  )  {      [ATTENTION]  return  this  ;  }    [METHOD]  createFiles  [TYPE]  File[]  [PARAMETER]  String  str  [CLASS]  TypeHandler    [TYPE]  boolean  false  true  [TYPE]  String  str  
[REPLACE]  private  HashMap  optionMap  =  new  HashMap  (  )  ;	[BUGGY]  private  HashMap  optionMap    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  OptionGroup  
[REPLACE]  private  String  selected;	[BUGGY]  private  char  selected  ;  [CE]  incomparable  types:  char  and  <null>  [CONTEXT]      [CLASS]  OptionGroup  
[REPLACE]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ;	[BUGGY]  optionMap  .  put  (  opt  .  getOpt  (  )  ,  opt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  OptionGroup  addOption  (  Option  opt  )  {      [ATTENTION]  optionMap  .  put  (  opt  .  getOpt  (  )    ,  opt  )    ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  OptionGroup  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ;	[BUGGY]  optionMap  .  put  (  opt  .  getOpt  (  )    ,  opt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  OptionGroup  addOption  (  Option  opt  )  {      [ATTENTION]  optionMap  .  put  (  opt  .  getOpt  (  )  ,  opt  )    ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  OptionGroup  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  OptionGroup  addOption  (  Option  opt  )  {      [ATTENTION]    return  this  ;  }    [METHOD]  addOption  [TYPE]  OptionGroup  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  OptionGroup  addOption  (  Option  opt  )  {      optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  addOption  [TYPE]  OptionGroup  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  optionMap  .  keySet  (  )  ;	[BUGGY]  return  optionMap  .  values  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Collection  getNames  (  )  {    [ATTENTION]  return  optionMap  .  values  (  )    ;  }    [METHOD]  getNames  [TYPE]  Collection  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  optionMap  .  values  (  )  ;	[BUGGY]  return  optionMap  .  keySet  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Collection  getOptions  (  )  {    [ATTENTION]  return  optionMap  .  keySet  (  )    ;  }    [METHOD]  getOptions  [TYPE]  Collection  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  (  this  .  selected  ==  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {	[BUGGY]  if  (  (  this  .  selected  !  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        [ATTENTION]  if  (  (  this  .  selected  !  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  this  .  selected  =  opt  .  getOpt  (  )  ;  }  else  {  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;  }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  if  (  (  this  .  selected  ==  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  this  .  selected  =  opt  .  getOpt  (  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        [ATTENTION]      else  {  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;  }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        if  (  (  this  .  selected  =  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  this  .  selected  =  opt  .  getOpt  (  )  ;  }  else  {  [ATTENTION]  return  ;    }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  this  .  selected  =  opt  .  getOpt  (  )  ;	[BUGGY]  this  .  selected  =    null  .  getOpt  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        if  (  (  this  .  selected  =  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  [ATTENTION]  this  .  selected  =  null  .  getOpt  (  )    ;  }  else  {  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;  }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  this  .  selected  =  opt  .  getOpt  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        if  (  (  this  .  selected  =  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  [ATTENTION]  }  else  {  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;  }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  +  selected  +   "' "  )  ;	[BUGGY]  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  ;  [CE]  [CONTEXT]  public  void  setSelected  (  Option  opt  )  throws  AlreadySelectedException  {        if  (  (  this  .  selected  =  =  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  this  .  selected  =  opt  .  getOpt  (  )  ;  }  else  {  [ATTENTION]  throw  new  AlreadySelectedException  (   "an  option  from  this  group  has   "  +   "already  been  selected:  ' "  ;    }  }    [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  OptionGroup    [TYPE]  Option  opt  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  selected;	[BUGGY]  return  optionMap  .  values  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  getSelected  (  )  {  [ATTENTION]  return  optionMap  .  values  (  )    ;  }    [METHOD]  getSelected  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  this  .  required  =  required;	[BUGGY]  this  .  required  =    true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setRequired  (  boolean  required  )  {  [ATTENTION]  this  .  required  =  true  ;  }    [METHOD]  setRequired  [TYPE]  void  [PARAMETER]  boolean  required  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  this  .  required  =  required;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  setRequired  (  boolean  required  )  {  [ATTENTION]  }    [METHOD]  setRequired  [TYPE]  void  [PARAMETER]  boolean  required  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  this  .  required;	[BUGGY]  return  optionMap  .  values  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isRequired  (  )  {  [ATTENTION]  return  optionMap  .  values  (  )    ;  }    [METHOD]  isRequired  [TYPE]  boolean  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  iter  .  next  (  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  {  [ATTENTION]  Option  option  =  (  Option  )  iter  .  next  (  )    ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  buff  [CONTEXT]  {  [ATTENTION]    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  Iterator  iter  =  getOptions  (  )    .  iterator  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  iter  .  next  (  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    [ATTENTION]  Option  option  =  (  Option  )  iter  .  next  (  )    ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "[ "  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    [ATTENTION]  buff  .  append  (   "-- "  )    ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  {	[BUGGY]  if  (  option  .  getOpt  (  )    =  =  false  )  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    [ATTENTION]  if  (  option  .  getOpt  (  )  =  =  false  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "-- "  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  toString  (  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  buff  .  append  (   "-- "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  [ATTENTION]  buff  .  toString  (  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getOpt  (  )  )    ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REMOVE]  	[BUGGY]  return  optionMap  .  values  (  )  ;  [CE]  incompatible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;    return  optionMap  .  values  (  )    ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "- "  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  [ATTENTION]  buff  .  toString  (  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getKey  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getKey  (  )  )    ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getLongOpt  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getLongOpt  (  )    )    ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REMOVE]  	[BUGGY]  return  optionMap  .  values  (  )  ;  [CE]  incompatible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getOpt  (  )  )  ;    return  optionMap  .  values  (  )    ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  iter  .  hasNext  (  )  )  {	[BUGGY]  if  (  iter  .  next  (  )    )  {[CE]  incompatible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    [ATTENTION]  if  (  iter  .  next  (  )    )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   ",   "  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  append  (   "-- "  )    ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  Option  option  =  (  Option  )  iter  .  next  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  iter  .  hasNext  (  )    ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  Option  option  =  (  Option  )  iter  .  hasNext  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  Option  option  =  (  Option  )  iter  .  next  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  {	[BUGGY]  if  (  option  .  getOpt  (  )    =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    [ATTENTION]  if  (  option  .  getOpt  (  )  =  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "-- "  )  ;	[BUGGY]  buff  .  append  (   "[ "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  append  (   "[ "  )    ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  [ATTENTION]  buff  .  append  (  option  .  getLongOpt  (  )  )    ;    }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getOpt  (  )  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[ADD]  buff  .  append  (  option  .  getLongOpt  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  [ATTENTION]  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "- "  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  [ATTENTION]  buff  .  append  (   "-- "  )    ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  toString  (  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ;	[BUGGY]  buff  .  append  (  option  .  getLongOpt  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getLongOpt  (  )    )    ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REMOVE]  	[BUGGY]  return  optionMap  .  values  (  )  ;  [CE]  incompatible  types  [CONTEXT]  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  [ATTENTION]  buff  .  append  (  option  .  getOpt  (  )  )  ;    return  optionMap  .  values  (  )    ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;      [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  iter  .  hasNext  (  )  )  {	[BUGGY]  if  (  iter  .  next  (  )    )  {[CE]  incompatible  types  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    [ATTENTION]  if  (  iter  .  next  (  )    )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   ",   "  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  append  (   "-- "  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  Option  option  =  (  Option  )  iter  .  next  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  iter  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  Option  option  =  (  Option  )  iter  .  hasNext  (  )    ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  buff  .  append  (   "] "  )  ;	[BUGGY]  buff  .  append  (   "-- "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  [ATTENTION]  buff  .  append  (   "-- "  )    ;    return  buff  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  return  buff  .  toString  (  )  ;	[BUGGY]  return  buff  .  StringBuffer  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  StringBuffer  buff  =  new  StringBuffer  (  )  ;    Iterator  iter  =  getOptions  (  )  .  iterator  (  )  ;    buff  .  append  (   "[ "  )  ;    while  (  iter  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  iter  .  next  (  )  ;    if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  ;  buff  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ;  }  buff  .  append  (   "   "  )  ;  buff  .  append  (  option  .  getDescription  (  )  )  ;    if  (  iter  .  hasNext  (  )  )  {  buff  .  append  (   "  ,   "  )  ;  }  }  buff  .  append  (   "] "  )  ;    [ATTENTION]  return  buff  .  StringBuffer  (  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  OptionGroup    [TYPE]  Iterator  iter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  HashMap  optionMap  
[REPLACE]  if  (  opt  ==  null  )  {	[BUGGY]  if  (  opt  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    [ATTENTION]  if  (  opt  !  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REMOVE]  	[BUGGY]  if  (  (  opt  .  length  (  )  )    =  =  1  )  {      char  ch  =  opt  .  charAt  (  0  )  ;      if  (  !  (  isValidOpt  (  ch  )  )  )  {          throw  new  IllegalArgumentException  (  (  (   "illegal  option  value  ' "  +  ch  )  +   "' "  )  )  ;      }  }else  {      char[]  chars  =  opt  .  toCharArray  (  )  ;      for  (  int  i  =  0  ;  i  <  (  chars  .  length  )  ;  i++  )  {          if  (  !  (  isValidChar  (  chars[i]  )  )  )  {              throw  new  IllegalArgumentException  (  (  (   "opt  contains  illegal  character  value  ' "  +  (  chars[i]  )  )  +   "' "  )  )  ;          }      }  }[CE]  'else'  without  'if'  [CONTEXT]  {    [ATTENTION]  if  (  opt  =  =  null  )    if  (  (  opt  .  length  (  )  )  =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )    ;  if  (  !  (  isValidOpt  (  ch  )  )  )  {  throw  new  IllegalArgumentException  (  (  (   "illegal  option  value  ' "  +  ch  )  +   "' "  )  )    ;  }  }else  {  char[]  chars  =  opt  .  toCharArray  (  )    ;  for  (  int  i  =  0  ;  i  <  (  chars  .  length  )    ;  i++  )  {  if  (  !  (  isValidChar  (  chars[i]  )  )  )  {  throw  new  IllegalArgumentException  (  (  (   "opt  contains  illegal  character  value  ' "  +  (  chars[i]  )  )  +   "' "  )  )    ;  }  }  }{  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  else  if  (  opt  .  length  (  )  ==  1  )  {	[BUGGY]  else  if  (  opt  .  charAt  (  )  /  0  .  5    =  =  1  )  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    [ATTENTION]  else  if  (  opt  .  charAt  (  )  /0  .  5  =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  else  if  (  opt  .  length  (  )  ==  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;  if  (  !isValidOpt  (  ch  )  )	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    [ATTENTION]      {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  {	[BUGGY]  if  (  isValidChar  (  chars[i]  )  )  {[FE]  opt  contains  illegal  character  value  'h'  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  [ATTENTION]  if  (  isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;    ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )    ;    ;    }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  (  )    ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  [ATTENTION]      }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  return  ;    }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  opt  .  length  (  )  ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  [ATTENTION]  char[]  chars  =  opt  .  length  (  )    ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (	[BUGGY]  [CE]  not  a  statement  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]       "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]    }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  if  (  !isValidOpt  (  ch  )  )  {	[BUGGY]  if  (  isValidOpt  (  ch  )  )  {[FE]  illegal  option  value  'D'  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    [ATTENTION]  if  (  isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REMOVE]  	[BUGGY]  if  (  !  (  isValidChar  (  chars[i]  )  )  )  {      throw  new  IllegalArgumentException  (  (  (   "opt  contains  illegal  character  value  ' "  +  (  chars[i]  )  )  +   "' "  )  )  ;  }[CE]  cannot  find  symbol  chars  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    [ATTENTION]  if  (  !isValidOpt  (  ch  )  )    if  (  !  (  isValidChar  (  chars[i]  )  )  )  {  throw  new  IllegalArgumentException  (  (  (   "opt  contains  illegal  character  value  ' "  +  (  chars[i]  )  )  +   "' "  )  )    ;  }{  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]  return  ;    }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ;	[BUGGY]  char  ch  =  opt  .  charAt  (  3  )  ;  [FE]  String  index  out  of  range:  3  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  [ATTENTION]  char  ch  =  opt  .  charAt  (  3  )    ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;  [CE]  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;    }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]    }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  if  (  !isValidOpt  (  ch  )  )  {	[BUGGY]  if  (  isValidOpt  (  ch  )  )  {[FE]  illegal  option  value  'D'  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    [ATTENTION]  if  (  isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]  return  ;    }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]    }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  {	[BUGGY]  if  (  isValidChar  (  chars[i]  )  )  {[FE]  opt  contains  illegal  character  value  'h'  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  [ATTENTION]  if  (  isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;    ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )    ;    ;    }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]    }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  *  2  ;  i++  )  {[FE]  4  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  *2  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  {	[BUGGY]  if  (  isValidChar  (  chars[i]  )  )  {[FE]  opt  contains  illegal  character  value  'h'  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  [ATTENTION]  if  (  isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;    ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )    ;    ;    }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]    }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  return  ;    }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ;	[BUGGY]  char  ch  =  opt  .  charAt  (  0  -  0  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  [ATTENTION]  char  ch  =  opt  .  charAt  (  0  -  0  )    ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  opt  .  length  (  )  ;  [CE]  incompatible  types  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  [ATTENTION]  char[]  chars  =  opt  .  length  (  )    ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;  [CE]  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;    }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]    }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;    ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )    ;    ;    }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  [ATTENTION]    }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  return;	[BUGGY]  return  (  isValidChar  (  c  )  ||  (  c  =  =  '  '  )  ||  (  c  =  =  '?'  )  ||  c  =  =  '@'  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  if  (  opt  =  =  null  )  {  [ATTENTION]  return  (  isValidChar  (  c  )  ||  (  c  =  =  '  '  )  ||  (  c  =  =  '?'  )  ||  c  =  =  '@'  )    ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  else  if  (  opt  .  length  (  )  ==  1  )  {	[BUGGY]  else  if  (  opt  .  length  (  )  *  0  .  5    =  =  1  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    [ATTENTION]  else  if  (  opt  .  length  (  )  *0  .  5  =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  (  )    ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  opt  .  charAt  (  i  )    ;  [CE]  cannot  find  symbol  i  [CONTEXT]  else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  [ATTENTION]  char[]  chars  =  opt  .  charAt  (  i  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    [ATTENTION]      }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;	[BUGGY]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;  [CE]  [CONTEXT]  if  (  !isValidOpt  (  ch  )  )  {  [ATTENTION]  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  ;    }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  chars  .  length  +  4  ;  i++  )  {[FE]  4  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  chars  .  length  +  4  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (	[BUGGY]  [CE]  not  a  statement  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    [ATTENTION]       "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ;	[BUGGY]  char  ch  =  opt  .  charAt  (  1  )  ;  [FE]  String  index  out  of  range:  1  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  [ATTENTION]  char  ch  =  opt  .  charAt  (  1  )    ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  char[]  chars  =  opt  .  toCharArray  (  )  ;    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[ADD]  char[]  chars  =  opt  .  toCharArray  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  chars  [CONTEXT]  {    if  (  opt  =  =  null  )  {  return  ;  }    else  if  (  opt  .  length  (  )    =  =  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;    if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (   "illegal  option  value  ' "  +  ch  +   "' "  )  ;  }  }    else  {  [ATTENTION]    for  (  int  i  =  0  ;  i  <  chars  .  length  ;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (   "opt  contains  illegal  character  value  ' "  +  chars[i]  +   "' "  )  ;  }  }  }  }    [METHOD]  validateOption  [TYPE]  void  [PARAMETER]  String  opt  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  ch  [TYPE]  String  opt  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  return  (  isValidChar  (  c  )  ||  (  c  ==  '  '  )  ||  (  c  ==  '?'  )  ||  c  ==  '@'  )  ;	[BUGGY]  return    (  c  ;  [CE]  ')'  expected  [CONTEXT]  private  static  boolean  isValidOpt  (  char  c  )  {  [ATTENTION]  return  (  c  ;  }    [METHOD]  isValidOpt  [TYPE]  boolean  [PARAMETER]  char  c  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  c  
[REPLACE]  return  Character  .  isJavaIdentifierPart  (  c  )  ;	[BUGGY]  return    c    ;  [CE]  incompatible  types  [CONTEXT]  private  static  boolean  isValidChar  (  char  c  )  {  [ATTENTION]  return  c  ;  }    [METHOD]  isValidChar  [TYPE]  boolean  [PARAMETER]  char  c  [CLASS]  OptionValidator    [TYPE]  boolean  false  true  [TYPE]  char  c  
[REPLACE]  private  ArrayList  tokens  =  new  ArrayList  (  )  ;	[BUGGY]  private  ArrayList  tokens  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  PosixParser  
[REPLACE]  eatTheRest  =  false;	[BUGGY]  eatTheRest  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  init  (  )  {  [ATTENTION]  eatTheRest  =  true  ;  tokens  .  clear  (  )  ;  currentOption  =  null  ;  }    [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  true  
[REPLACE]  tokens  .  clear  (  )  ;	[BUGGY]  tokens  .  ArrayList  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  init  (  )  {  eatTheRest  =  false  ;  [ATTENTION]  tokens  .  ArrayList  (  )    ;  currentOption  =  null  ;  }    [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  true  
[ADD]  tokens  .  clear  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  init  (  )  {  eatTheRest  =  false  ;  [ATTENTION]  currentOption  =  null  ;  }    [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  true  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  private  void  init  (  )  {  eatTheRest  =  false  ;  tokens  .  clear  (  )  ;  [ATTENTION]  currentOption  =  false  ;  }    [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  true  
[REPLACE]  init  (  )  ;	[BUGGY]  gobble  (  iter  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  {  [ATTENTION]  gobble  (  iter  )    ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  this  .  options  =  options;	[BUGGY]  this  .  options  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  [ATTENTION]  this  .  options  =  null  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  this  .  options  =  options;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  [ATTENTION]      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  Iterator  iter  =  Arrays  .  asList  (  arguments  )    .  iterator  (  )  ;	[BUGGY]  Iterator  iter  =    arguments    .  iterator  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      [ATTENTION]  Iterator  iter  =  arguments  .  iterator  (  )    ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  String  token  =  null;	[BUGGY]  String  token  =  false  ;  [CE]  incompatible  types  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  [ATTENTION]  String  token  =  false  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  while  (  iter  .  hasNext  (  )  )  {	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      [ATTENTION]    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  token  .  startsWith  (   "-- "  )  )  {	[BUGGY]  else  if  (  token  .  startsWith  (   "- "  )  )  {[CE]  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]  else  if  (  token  .  startsWith  (   "- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (   "- "  .  equals  (  token  )  )  {	[BUGGY]  else  {[CE]  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [ATTENTION]  else  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  token  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  token  .  startsWith  (   "- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;  if  (  tokenLength  ==  2  )	[BUGGY]  [CE]  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]      {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]  if  (  true  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  token  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  token  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  process  (  token  )  ;	[BUGGY]  tokens  .  add  (   "- "  +  ch  )  ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (   "- "  +  ch  )    ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  !  =    2  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength!  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  else  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  burstToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  burstToken  (  token  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  [ATTENTION]  burstToken  (  token  ,  true  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  token  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  token  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  processOptionToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  burstToken  (  token  ,  stopAtNonOption  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  tokenLength  =  =  2  )  {  [ATTENTION]  burstToken  (  token  ,  stopAtNonOption  )    ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  token  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }	[BUGGY]  tokens  .  add  (  token  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  tokens  .  add  (  token  )    ;      else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  add  (  token  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  int  tokenLength  =  token  .  startsWith  (  token  )    ;  [CE]  incompatible  types  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  int  tokenLength  =  token  .  startsWith  (  token  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  tokenLength  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  !  =    0  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength!  =  0  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  token  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  token  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  token  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  processOptionToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  tokenLength  =  =  2  )  {  [ATTENTION]  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  else  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  burstToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  [ATTENTION]  boolean  hasOption  =  options  .  hasOption  (  ch  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]  if  (  true  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]      else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )    ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  processSingleHyphen  (  token  )  ;	[BUGGY]  gobble  (  iter  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (   "- "  .  equals  (  token  )  )  {  [ATTENTION]  gobble  (  iter  )    ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  token  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]  else  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )  {[CE]  'else'  without  'if'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]  else  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  ||  2  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength||2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  processOptionToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  processOptionToken  (  token  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  tokenLength  =  =  2  )  {  [ATTENTION]  processOptionToken  (  token  ,  true  )    ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  burstToken  (  token,  stopAtNonOption  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )    ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  &&  2  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength&&2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }	[BUGGY]  tokens  .  add  (  token  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  tokens  .  add  (  token  )    ;      else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  [ATTENTION]  burstToken  (  token  ,  stopAtNonOption  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (  token  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }  else  {  tokens  .  add  (  token  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  int  tokenLength  =  token  .  startsWith  (  token  )    ;  [CE]  incompatible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  int  tokenLength  =  token  .  startsWith  (  token  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {	[BUGGY]  if  (  token  .  indexOf  (  '  =  '  )    =  =    -1  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  startsWith  (   "-- "  )  )  {  [ATTENTION]  if  (  token  .  indexOf  (  '  =  '  )    =  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  token  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  token  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0L  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [CE]  no  suitable  method  found  for  substring(long  ,  int)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0L  ,  token  .  indexOf  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  4  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  4  ,  token  .  indexOf  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  valueOf  (  null  )    )  )  ;  [CE]  no  suitable  method  found  for  substring(int  ,  String)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  valueOf  (  null  )    )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  *  2  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  *2  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  -  5  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  -  5  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  charAt  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  charAt  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  token  .  length  (  )  )  )  ;	[BUGGY]  token  .  startsWith  (  token  )    )  )  ;  [CE]  no  suitable  method  found  for  substring(int  ,  boolean)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  [ATTENTION]  token  .  startsWith  (  token  )    )  )    ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {	[BUGGY]  if  (  token  .  indexOf  (  '  =  '  )    =  =    -1  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  [ATTENTION]  if  (  token  .  indexOf  (  '  =  '  )    =  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  [CE]  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  [ATTENTION]      }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0  %  1  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  %  1  ,  token  .  indexOf  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  valueOf  (  this  )    )  )  ;  [CE]  no  suitable  method  found  for  substring(int  ,  String)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  valueOf  (  this  )    )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  size  (  )  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  size  (  )  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  +  3  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  +  3  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  ')'  expected  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  [ATTENTION]  tokens  .  add  (  iter  .  next  (  )  )    ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]      else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  process  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  !  =    2  +  0  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength!  =  2  +  0  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]      else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  ||  2  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength||2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]      else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  add  (  token  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  if  (  tokenLength  =  =  2  )  {  [ATTENTION]  processOptionToken  (  token  ,  stopAtNonOption  )  ;    String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )    ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  1  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  1  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  ||  4  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength||4  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  true  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  true  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  token  =  (  String  )  iter  .  next  (  )  ;	[BUGGY]  token  =    (  String  )  null  .  next  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {    [ATTENTION]  token  =    (  String  )  null  .  next  (  )    ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  token  .  startsWith  (   "-- "  )  )  {	[BUGGY]  else  if  (  token  .  startsWith  (   "- "  )  )  {[CE]  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]  else  if  (  token  .  startsWith  (   "- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  [CE]  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]      tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (   "- "  .  equals  (  token  )  )  {	[BUGGY]  if  (   "- "  .  equals  (  token  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [ATTENTION]  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [ATTENTION]      else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  token  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]  else  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;  if  (  tokenLength  ==  2  )	[BUGGY]  [CE]  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]      {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  &&  2  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength&&2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  tokenLength  ==  2  )  {  processOptionToken  (  token,  stopAtNonOption  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]      else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  !  =    2  <<  0  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength!  =  2  <<  0  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  else  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  token  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  token  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  token  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }	[BUGGY]  tokens  .  add  (  token  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  tokens  .  add  (  token  )    ;      else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]  if  (  true  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  int  tokenLength  =  token  .  startsWith  (  token  )    ;  [CE]  incompatible  types  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  int  tokenLength  =  token  .  startsWith  (  token  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  token  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  token  .  startsWith  (   "- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  [ATTENTION]  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  0  )    ;  [CE]  no  suitable  method  found  for  toArray(int)  [CONTEXT]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  0  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  false  )    ;  [CE]  no  suitable  method  found  for  toArray(boolean)  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  false  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  !  =    2  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength!  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  add  (  token  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;      [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(PosixParser)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  2  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  2  ,  token  .  indexOf  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  charAt  (  '  =  '  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  ,  token  .  charAt  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  +  4  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  +  4  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  token  .  length  (  )  )  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  [ATTENTION]  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {	[BUGGY]  if  (  token  .  indexOf  (  '  =  '  )    =  =    -1  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  [ATTENTION]  if  (  token  .  indexOf  (  '  =  '  )    =  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  [CE]  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  [ATTENTION]      }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  0  *  4  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  0  *  4  ,  token  .  indexOf  (  '  =  '  )  )  )    ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  length  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  *  0  .  5  )  )  ;  [CE]  method  length  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  length  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  *0  .  5  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  %  0  .  5  )  )  ;  [CE]  no  suitable  method  found  for  substring(int  ,  double)  [CONTEXT]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  [ATTENTION]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  %0  .  5  )  )    ;    }  else  {  tokens  .  add  (  token  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  tokenLength  ==  2  )  {	[BUGGY]  if  (  tokenLength  ||  0  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  if  (  tokenLength||0  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  tokens  .  add  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  stopAtNonOption  )  {[CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]  else  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )    ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  {	[BUGGY]  if  (  options  .  getOption  (  token  )  )  {[CE]  incompatible  types  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  [ATTENTION]  if  (  options  .  getOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  tokens  .  add  (  token  )  ;	[BUGGY]  tokens  .  toArray  (  this  )    ;  [CE]  no  suitable  method  found  for  toArray(PosixParser)  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  [ATTENTION]  tokens  .  toArray  (  this  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  [ATTENTION]      else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  token  =  (  String  )  iter  .  next  (  )  ;	[BUGGY]  token  =    (  String  )  null  .  next  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    [ATTENTION]  token  =    (  String  )  null  .  next  (  )    ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[ADD]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  tokenLength  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  [ATTENTION]    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {}  )  ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {  }  )  ;	[BUGGY]  return  (  String[]  )  tokens  .  ArrayList  (  new  String[]  {  }  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;      Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;  String  token  =  null  ;      while  (  iter  .  hasNext  (  )  )  {    token  =    (  String  )  iter  .  next  (  )  ;      if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }    else  if  (   "- "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;    if  (  tokenLength  =  =  2  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  }    else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  else  {  if  (  stopAtNonOption  )  {  process  (  token  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  gobble  (  iter  )  ;  }  [ATTENTION]  return  (  String[]  )  tokens  .  ArrayList  (  new  String[]  {}  )    ;  }    [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [TYPE]  int  tokenLength  
[REPLACE]  while  (  iter  .  hasNext  (  )  )  {	[BUGGY]  while  (  iter  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  if  (  eatTheRest  )  {  [ATTENTION]  while  (  iter  .  next  (  )  )  {  tokens  .  add  (  iter  .  next  (  )  )  ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ;	[BUGGY]  tokens  .  toArray  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  if  (  eatTheRest  )  {  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  null  )  ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ;	[BUGGY]  tokens  .  add  (  iter  .  hasNext  (  )    )  ;  [FE]  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  if  (  eatTheRest  )  {  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  tokens  .  add  (  iter  .  hasNext  (  )    )    ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  if  (  eatTheRest  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  while  (  iter  .  hasNext  (  )  )  {  tokens  .  add  (  iter  .  next  (  )  )  ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ;	[BUGGY]  tokens  .  toArray  (  iter  .  next  (  )  )  ;  [CE]  no  suitable  method  found  for  toArray(Object)  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  if  (  eatTheRest  )  {  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  iter  .  next  (  )  )    ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ;	[BUGGY]  tokens  .  add  (  iter  .  hasNext  (  )  )  ;  [FE]  [CONTEXT]  private  void  gobble  (  Iterator  iter  )  {  if  (  eatTheRest  )  {  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  tokens  .  add  (  iter  .  hasNext  (  )  )    ;  }  }  }    [METHOD]  gobble  [TYPE]  void  [PARAMETER]  Iterator  iter  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  
[REPLACE]  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {	[BUGGY]  if  (  (  currentOption  =  =  this  )  )  {[CE]  incomparable  types:  Option  and  PosixParser  [CONTEXT]  private  void  process  (  String  value  )  {  [ATTENTION]  if  (  (  currentOption  =  =  this  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  [ATTENTION]  eatTheRest  =  false  ;    ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  [ATTENTION]      }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  tokens  .  add  (  value  )  ;	[BUGGY]  tokens  .  toArray  (  value  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  tokens  .  toArray  (  value  )    ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[ADD]  tokens  .  add  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  [ATTENTION]  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  this  ;  [CE]  incompatible  types  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  [ATTENTION]  currentOption  =  this  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  true  ;  [CE]  incompatible  types  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  [ATTENTION]  currentOption  =  true  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  [ATTENTION]      else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )[CE]  illegal  start  of  type  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )    tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  {	[BUGGY]  else  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  [ATTENTION]  else  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  currentOption  =  null;	[BUGGY]  currentOption  =  false  ;  [CE]  incompatible  types  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  [ATTENTION]  currentOption  =  false  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  process  (  String  value  )  {  if  (  (  currentOption  !  =  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null  ;  }  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  }  }  else  {  [ATTENTION]  eatTheRest  =  false  ;  tokens  .  add  (   "-- "  )  ;  tokens  .  add  (  value  )  ;  }  }    [METHOD]  process  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  value  
[REPLACE]  tokens  .  add  (  hyphen  )  ;	[BUGGY]  tokens  .  toArray  (  hyphen  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  private  void  processSingleHyphen  (  String  hyphen  )  {  [ATTENTION]  tokens  .  toArray  (  hyphen  )    ;  }    [METHOD]  processSingleHyphen  [TYPE]  void  [PARAMETER]  String  hyphen  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  hyphen  
[REPLACE]  if  (  this  .  options  .  hasOption  (  token  )  )  {	[BUGGY]  if  (  this  .  options  .  getOption  (  token  )  )  {[CE]  incompatible  types  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  [ATTENTION]  if  (  this  .  options  .  getOption  (  token  )  )  {  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  this  .  options  .  hasOption  (  token  )  )  {  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  [ATTENTION]  else  {  eatTheRest  =  true  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  this  .  options  .  hasOption  (  token  )  )  {  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[REPLACE]  currentOption  =  this  .  options  .  getOption  (  token  )  ;	[BUGGY]  currentOption  =  options  .  getOption  (  ch  )  ;    ;  [CE]  cannot  find  symbol  ch  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  this  .  options  .  hasOption  (  token  )  )  {  [ATTENTION]  currentOption  =  options  .  getOption  (  ch  )    ;    ;  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[ADD]  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  this  .  options  .  hasOption  (  token  )  )  {  [ATTENTION]    }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  this  .  options  .  hasOption  (  token  )  )  {  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ;	[BUGGY]  int  tokenLength  =  token  .  startsWith  (  token  )    ;  [CE]  incompatible  types  [CONTEXT]  {  [ATTENTION]  int  tokenLength  =  token  .  startsWith  (  token  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  hasOption  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[ADD]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    [ATTENTION]      if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  else  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  [ATTENTION]  else  if  (  true  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[ADD]  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  [ATTENTION]      else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (   "- "  +  ch  )  ;	[BUGGY]  tokens  .  add  (   "- "  !  =    ch  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (   "- "!  =  ch  )    ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  process  (  token  .  charAt  (  i  )  )  ;  [CE]  method  process  in  class  PosixParser  cannot  be  applied  to  given  types  ;  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  .  charAt  (  i  )  )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  .  substring  (  i  )  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;      [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  process  (  token  .  substring  (  tokenLength  ,  tokenLength  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  .  substring  (  tokenLength  ,  tokenLength  )    )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  -  3  !  =    (  i  +  1  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    [ATTENTION]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  -  3  !  =  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  toArray  (  token  .  substring  (  i  ||  3  )  )  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  toArray  (  token  .  substring  (  i||3  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  i    =  =    1  )  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i  =  =  1  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ;	[BUGGY]  currentOption  =  this  .  options  .  getOption  (  token  )  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  [ATTENTION]  currentOption  =  this  .  options  .  getOption  (  token  )    ;    ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  i  &  1  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i&1  )  )    ;    break  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  i  |  4  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i|4  )  )    ;    break  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  [ATTENTION]  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (   "- "  +  ch  )  ;	[BUGGY]  tokens  .  add  (   "- "  <  =    ch  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (   "- "<  =  ch  )    ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (   "- "  +  ch  )  ;      [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  iter  .  next  (  )  )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  {	[BUGGY]  for  (  int  i  =  1  ;  i  >  tokenLength  ;  i++  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  for  (  int  i  =  1  ;  i>tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[ADD]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]      if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  hasOption  )  {	[BUGGY]  else  if  (  currentOption  .  hasArgs  (  )  )  {[CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    [ATTENTION]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[ADD]  if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    [ATTENTION]      if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  else  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  [ATTENTION]  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (   "- "  +  ch  )  ;	[BUGGY]  tokens  .  add  (   "- "  &  ch  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (   "- "&ch  )    ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  process  (  token  .  charAt  (  i  )  )  ;  [CE]  method  process  in  class  PosixParser  cannot  be  applied  to  given  types  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  .  charAt  (  i  )  )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  process  (  token  .  substring  (  i  ,  i  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  process  (  token  .  substring  (  i  ,  i  )    )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    [ATTENTION]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  i    =  =    1  -  1  )  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i  =  =  1  -  1  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  length  (  i  <  1  )  )  ;  [CE]  method  length  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  length  (  i<1  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ;	[BUGGY]  currentOption  =  this  .  options  .  getOption  (  token  )  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  [ATTENTION]  currentOption  =  this  .  options  .  getOption  (  token  )    ;    ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {	[BUGGY]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  *  2  !  =    (  i  +  1  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    [ATTENTION]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  *2  !  =  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[ADD]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  break;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    [ATTENTION]      }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  length  (  i  &&  1  )  )  ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  length  (  i&&1  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;	[BUGGY]  tokens  .  add  (  token  .  substring  (  i  >  =    2  )  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i>  =  2  )  )    ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  [ATTENTION]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  tokens  .  add  (   "- "  +  ch  )  ;	[BUGGY]  tokens  .  clear  (   "- "  >  =    ch  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  clear  (   "- ">  =  ch  )    ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REMOVE]  	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [ATTENTION]  tokens  .  add  (   "- "  +  ch  )  ;    tokens  .  add  (  iter  .  next  (  )  )    ;  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  process  (  token  .  substring  (  i  )  )  ;	[BUGGY]  tokens  .  add  (  iter  .  next  (  )  )  ;  [CE]  cannot  find  symbol  iter  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  [ATTENTION]  tokens  .  add  (  iter  .  next  (  )  )    ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;	[BUGGY]  String  ch  =  String  .  indexOf  (  tokenLength  )    ;  [CE]  non-static  method  indexOf(int)  cannot  be  referenced  from  a  static  context  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  [ATTENTION]  String  ch  =  String  .  indexOf  (  tokenLength  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;	[BUGGY]  boolean  .  getOption  =  options  .  hasOption  (  ch  )  ;  [CE]  class  expected  [CONTEXT]  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [ATTENTION]  boolean  .  getOption  =  options  .  hasOption  (  ch  )    ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ;	[BUGGY]  currentOption  =  this  .  options  .  getOption  (  token  )  ;    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  [ATTENTION]  currentOption  =  this  .  options  .  getOption  (  token  )    ;    ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  {	[BUGGY]  for  (  int  i  =  1L  ;  i  <  tokenLength  ;  i++  )  {[CE]  possible  loss  of  precision  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    [ATTENTION]  for  (  int  i  =  1L  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;	[BUGGY]  String  ch  =  String  .  valueOf  (  token  .  startsWith  (  token  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  [ATTENTION]  String  ch  =  String  .  valueOf  (  token  .  startsWith  (  token  )    )    ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;	[BUGGY]  boolean  .  getOption  =  options  .  hasOption  (  ch  )  ;  [CE]  class  expected  [CONTEXT]  {  int  tokenLength  =  token  .  length  (  )  ;    for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  [ATTENTION]  boolean  .  getOption  =  options  .  hasOption  (  ch  )    ;    if  (  hasOption  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;    if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =    (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;    break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  tokens  .  add  (   "- "  +  ch  )  ;  }  }  }    [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser    [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  
[REPLACE]  private  Map  shortOpts  =  new  HashMap  (  )  ;	[BUGGY]  private  Map  shortOpts    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Options  
[REPLACE]  private  Map  longOpts  =  new  HashMap  (  )  ;	[BUGGY]  private  Map  longOpts    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Options  
[REPLACE]  private  List  requiredOpts  =  new  ArrayList  (  )  ;	[BUGGY]  private  List  requiredOpts  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Options  
[REPLACE]  private  Map  optionGroups  =  new  HashMap  (  )  ;	[BUGGY]  private  Map  optionGroups    =  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  Options  
[REPLACE]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )  ;	[BUGGY]  Iterator  options  =  group  .  isRequired  (  )    .  iterator  (  )  ;  [CE]  boolean  cannot  be  dereferenced  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  [ATTENTION]  Iterator  options  =  group  .  isRequired  (  )  .  iterator  (  )    ;    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  options  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  [ATTENTION]    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  group  .  isRequired  (  )  )  {	[BUGGY]  if  (  group  .  getOptions  (  )  )  {[CE]  incompatible  types  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    [ATTENTION]  if  (  group  .  getOptions  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  requiredOpts  .  add  (  group  )  ;	[BUGGY]  requiredOpts  .  remove  (  group  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  [ATTENTION]  requiredOpts  .  remove  (  group  )    ;  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  requiredOpts  .  add  (  group  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  [ATTENTION]  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  while  (  options  .  hasNext  (  )  )  {	[BUGGY]  while  (  options  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  [ATTENTION]  while  (  options  .  next  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  while  (  options  .  hasNext  (  )  )  {  Option  option  =  (  Option  )  options  .  next  (  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  [ATTENTION]            option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  Option  option  =  (  Option  )  options  .  next  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  options  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  while  (  options  .  hasNext  (  )  )  {  [ATTENTION]  Option  option  =  (  Option  )  options  .  hasNext  (  )    ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  return  this  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOptionGroup  (  OptionGroup  group  )  {  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOpts  .  add  (  group  )  ;  }  while  (  options  .  hasNext  (  )  )  {  Option  option  =    (  Option  )  options  .  next  (  )  ;          option  .  setRequired  (  false  )  ;  addOption  (  option  )  ;    optionGroups  .  put  (  option  .  getKey  (  )  ,  group  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addOptionGroup  [TYPE]  Options  [PARAMETER]  OptionGroup  group  [CLASS]  Options    [TYPE]  Iterator  options  [TYPE]  List  requiredOpts  [TYPE]  Option  option  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  new  HashSet  (  optionGroups  .  values  (  )  )  ;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  Collection  getOptionGroups  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getOptionGroups  [TYPE]  Collection  [PARAMETER]  [CLASS]  Options    [TYPE]  Map  longOpts  optionGroups  shortOpts  [TYPE]  List  requiredOpts  [TYPE]  boolean  false  true  
[REPLACE]  addOption  (  opt,  null,  hasArg,  description  )  ;	[BUGGY]  addOption  (  opt  ,  false  ,  hasArg  ,  description  )  ;  [CE]  no  suitable  method  found  for  addOption(String  ,  boolean  ,  boolean  ,  String)  [CONTEXT]  public  Options  addOption  (  String  opt  ,  boolean  hasArg  ,  String  description  )  {  [ATTENTION]  addOption  (  opt  ,  false  ,  hasArg  ,  description  )    ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  String  opt  boolean  hasArg  String  description  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  String  description  opt  [TYPE]  boolean  false  hasArg  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  String  opt  ,  boolean  hasArg  ,  String  description  )  {  addOption  (  opt  ,  null  ,  hasArg  ,  description  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  String  opt  boolean  hasArg  String  description  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  String  description  opt  [TYPE]  boolean  false  hasArg  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  addOption  (  new  Option  (  opt,  longOpt,  hasArg,  description  )  )  ;	[BUGGY]  addOption  (  new  Option  (  opt  ,  longOpt  ,  hasArg  ,  longOpt  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  {  [ATTENTION]  addOption  (  new  Option  (  opt  ,  longOpt  ,  hasArg  ,  longOpt  )  )    ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  String  description  longOpt  opt  [TYPE]  boolean  false  hasArg  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  String  opt  ,  String  longOpt  ,  boolean  hasArg  ,  String  description  )  {  addOption  (  new  Option  (  opt  ,  longOpt  ,  hasArg  ,  description  )  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  String  opt  String  longOpt  boolean  hasArg  String  description  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  String  description  longOpt  opt  [TYPE]  boolean  false  hasArg  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  String  key  =  opt  .  getKey  (  )  ;	[BUGGY]  String  key  =  opt  .  getLongOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  [ATTENTION]  String  key  =  opt  .  getLongOpt  (  )    ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  opt  .  hasLongOpt  (  )  )  {	[BUGGY]  if  (  opt  .  getLongOpt  (  )  )  {[CE]  incompatible  types  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      [ATTENTION]  if  (  opt  .  getLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      [ATTENTION]        if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;	[BUGGY]  longOpts  .  put  (  opt  .  hasLongOpt  (  )  ,  opt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  [ATTENTION]  longOpts  .  put  (  opt  .  hasLongOpt  (  )    ,  opt  )    ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  opt  .  isRequired  (  )    )  {	[BUGGY]  if  (  group  .  isRequired  (  )  )  {[CE]  cannot  find  symbol  group  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    [ATTENTION]  if  (  group  .  isRequired  (  )  )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }	[BUGGY]  [CE]  <identifier>  expected  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    [ATTENTION]      requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  requiredOpts  .  contains  (  key  )    )  {	[BUGGY]  if  (  !  requiredOpts  .  contains  (  key  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  [ATTENTION]  if  (  !requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }	[BUGGY]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  [ATTENTION]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )    ;    requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;	[BUGGY]  requiredOpts  .  add  (  requiredOpts  .  indexOf  (  key  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  [ATTENTION]  requiredOpts  .  add  (  requiredOpts  .  indexOf  (  key  )    )    ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  [ATTENTION]  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;	[BUGGY]  requiredOpts  .  remove  (  requiredOpts  .  contains  (  key  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  [ATTENTION]  requiredOpts  .  remove  (  requiredOpts  .  contains  (  key  )    )    ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;	[BUGGY]  requiredOpts  .  indexOf  (  false  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  [ATTENTION]  requiredOpts  .  indexOf  (  false  )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  shortOpts  .  put  (  key,  opt  )  ;	[BUGGY]  if  (  shortOpts  .  containsKey  (  opt  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  [ATTENTION]  if  (  shortOpts  .  containsKey  (  opt  )  )  {  return  this  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Options  addOption  (  Option  opt  )  {  String  key  =  opt  .  getKey  (  )  ;      if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  }    if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  }  requiredOpts  .  add  (  key  )  ;  }  shortOpts  .  put  (  key  ,  opt  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  addOption  [TYPE]  Options  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  requiredOpts  [TYPE]  Option  opt  [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  Collections  .  unmodifiableCollection  (  helpOptions  (  )  )  ;	[BUGGY]  return    helpOptions  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Collection  getOptions  (  )  {  [ATTENTION]  return  helpOptions  (  )  ;  }    [METHOD]  getOptions  [TYPE]  Collection  [PARAMETER]  [CLASS]  Options    [TYPE]  Map  longOpts  optionGroups  shortOpts  [TYPE]  List  requiredOpts  [TYPE]  boolean  false  true  
[REPLACE]  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;	[BUGGY]  Option  option  =    (  Option  )  options  .  next  (  )  ;  [CE]  cannot  find  symbol  options  [CONTEXT]  List  helpOptions  (  )  {  [ATTENTION]  Option  option  =  (  Option  )  options  .  next  (  )    ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  Iterator  iter  =  longOpts  .  values  (  )    .  iterator  (  )  ;	[BUGGY]  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;  [CE]  cannot  find  symbol  group  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        [ATTENTION]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )    ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  Iterator  iter  =  longOpts  .  values  (  )    .  iterator  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  iter  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        [ATTENTION]    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  !opts  .  contains  (  item  )  )  {	[BUGGY]  if  (  !opts  .  indexOf  (  item  )  )  {[CE]  bad  operand  type  int  for  unary  operator  '!'  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    [ATTENTION]  if  (  !opts  .  indexOf  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    [ATTENTION]      }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  opts  .  add  (  item  )  ;	[BUGGY]  opts  .  remove  (  item  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  [ATTENTION]  opts  .  remove  (  item  )    ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REMOVE]  	[BUGGY]  shortOpts  .  put  (  key  ,  opt  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  [ATTENTION]  opts  .  add  (  item  )  ;    shortOpts  .  put  (  key  ,  opt  )    ;  }  }  return  new  ArrayList  (  opts  )  ;      [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  Object  item  =  iter  .  next  (  )  ;	[BUGGY]  Object  item  =  iter  .  hasNext  (  )  ;  [FE]  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  Object  item  =  iter  .  hasNext  (  )    ;    if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  !opts  .  contains  (  item  )  )  {	[BUGGY]  if  (  !opts  .  add  (  null  )    )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    [ATTENTION]  if  (  !opts  .  add  (  null  )    )  {  opts  .  add  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  opts  .  add  (  item  )  ;	[BUGGY]  opts  .  indexOf  (  item  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  [ATTENTION]  opts  .  indexOf  (  item  )  ;  }  }  return  new  ArrayList  (  opts  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  new  ArrayList  (  opts  )  ;	[BUGGY]  return  new  ArrayList  (  shortOpts  .  values  (  )  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  List  helpOptions  (  )  {  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ;        Iterator  iter  =  longOpts  .  values  (  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  Object  item  =  iter  .  next  (  )  ;    if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  }  }  [ATTENTION]  returnnew  ArrayList  (  shortOpts  .  values  (  )  )  ;  }    [METHOD]  helpOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Iterator  iter  [TYPE]  List  opts  requiredOpts  [TYPE]  Object  item  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  requiredOpts;	[BUGGY]  return  buf  .  toString  (  )  ;  [CE]  cannot  find  symbol  buf  [CONTEXT]  public  List  getRequiredOptions  (  )  {  [ATTENTION]  return  buf  .  toString  (  )    ;  }    [METHOD]  getRequiredOptions  [TYPE]  List  [PARAMETER]  [CLASS]  Options    [TYPE]  Map  longOpts  optionGroups  shortOpts  [TYPE]  List  opts  requiredOpts  [TYPE]  boolean  false  true  
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;	[BUGGY]  opt  =    Util  .  stripLeadingHyphens  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  [ATTENTION]  opt  =  Util  .  stripLeadingHyphens  (  null  )    ;    if  (  shortOpts  .  containsKey  (  opt  )  )  {  return  (  Option  )  shortOpts  .  get  (  opt  )  ;  }  return  (  Option  )  longOpts  .  get  (  opt  )  ;  }    [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  if  (  shortOpts  .  containsKey  (  opt  )  )  {	[BUGGY]  if  (  shortOpts  .  get  (  opt  )  )  {[CE]  incompatible  types  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    [ATTENTION]  if  (  shortOpts  .  get  (  opt  )  )  {  return  (  Option  )  shortOpts  .  get  (  opt  )  ;  }  return  (  Option  )  longOpts  .  get  (  opt  )  ;  }    [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REMOVE]  	[BUGGY]  if  (  requiredOpts  .  contains  (  key  )  )  {      requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )  )  ;  }[CE]  cannot  find  symbol  key  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    [ATTENTION]  if  (  shortOpts  .  containsKey  (  opt  )  )    if  (  requiredOpts  .  contains  (  key  )  )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )  )    ;  }{  return  (  Option  )  shortOpts  .  get  (  opt  )  ;  }  return  (  Option  )  longOpts  .  get  (  opt  )  ;      [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  (  Option  )  shortOpts  .  get  (  opt  )  ;	[BUGGY]  return  (  Option  )  shortOpts  .  put  (  this  ,  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    if  (  shortOpts  .  containsKey  (  opt  )  )  {  [ATTENTION]  return  (  Option  )  shortOpts  .  put  (  this  ,  null  )  ;  }  return  (  Option  )  longOpts  .  get  (  opt  )  ;  }    [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  (  Option  )  shortOpts  .  get  (  opt  )  ;	[BUGGY]  return  (  Option  )  shortOpts  .  values  (  opt  )  ;  [CE]  method  values  in  interface  Map<K  ,  V>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    if  (  shortOpts  .  containsKey  (  opt  )  )  {  [ATTENTION]  return  (  Option  )  shortOpts  .  values  (  opt  )    ;  }  return  (  Option  )  longOpts  .  get  (  opt  )  ;  }    [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  (  Option  )  longOpts  .  get  (  opt  )  ;	[BUGGY]  return  (  Option  )  longOpts  .  put  (  null  ,  true  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Option  getOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    if  (  shortOpts  .  containsKey  (  opt  )  )  {  return  (  Option  )  shortOpts  .  get  (  opt  )  ;  }  [ATTENTION]  return  (  Option  )  longOpts  .  put  (  null  ,  true  )  ;  }    [METHOD]  getOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;	[BUGGY]  opt  =    Util  .  stripLeadingHyphens  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  boolean  hasOption  (  String  opt  )  {  [ATTENTION]  opt  =  Util  .  stripLeadingHyphens  (  null  )    ;    return  shortOpts  .  containsKey  (  opt  )  ||  longOpts  .  containsKey  (  opt  )  ;  }    [METHOD]  hasOption  [TYPE]  boolean  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  shortOpts  .  containsKey  (  opt  )  ||  longOpts  .  containsKey  (  opt  )  ;	[BUGGY]  return  shortOpts  .  get  (  opt  )  ||  longOpts  .  containsKey  (  opt  )  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  boolean  hasOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;    [ATTENTION]  return  shortOpts  .  get  (  opt  )  ||  longOpts  .  containsKey  (  opt  )    ;  }    [METHOD]  hasOption  [TYPE]  boolean  [PARAMETER]  String  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  String  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  (  OptionGroup  )  optionGroups  .  get  (  opt  .  getKey  (  )  )  ;	[BUGGY]  return  (  OptionGroup  )  optionGroups  .  get  (  opt  .  getLongOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  OptionGroup  getOptionGroup  (  Option  opt  )  {  [ATTENTION]  return  (  OptionGroup  )  optionGroups  .  get  (  opt  .  getLongOpt  (  )  )    ;  }    [METHOD]  getOptionGroup  [TYPE]  OptionGroup  [PARAMETER]  Option  opt  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  Option  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  StringBuffer  buf  =  new  StringBuffer  (  )  ;	[BUGGY]  String  key  =  opt  .  getKey  (  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  String  key  =  opt  .  getKey  (  )    ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  buf  .  append  (   "[  Options:  [  short   "  )  ;	[BUGGY]  Iterator  options  =  group  .  getOptions  (  )  .  iterator  (  )  ;  [CE]  cannot  find  symbol  group  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    [ATTENTION]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )    ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  buf  .  append  (  shortOpts  .  toString  (  )  )  ;	[BUGGY]  buf  .  append  (  shortOpts  .  Object  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  [ATTENTION]  buf  .  append  (  shortOpts  .  Object  (  )  )    ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  buf  .  append  (   "  ]  [  long   "  )  ;	[BUGGY]  buf  .  append  (   "  ] "  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  [ATTENTION]  buf  .  append  (   "  ] "  )    ;  buf  .  append  (  longOpts  )  ;  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  buf  .  append  (  longOpts  )  ;	[BUGGY]  shortOpts  .  put  (  key  ,  opt  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  [ATTENTION]  shortOpts  .  put  (  key  ,  opt  )    ;  buf  .  append  (   "  ] "  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  buf  .  append  (   "  ] "  )  ;	[BUGGY]  buf  .  toString  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  [ATTENTION]  buf  .  toString  (  )  ;    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[ADD]  buf  .  append  (   "  ] "  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  [ATTENTION]    return  buf  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  buf  .  toString  (  )  ;	[BUGGY]  return  buf  .  StringBuffer  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuffer  buf  =  new  StringBuffer  (  )  ;    buf  .  append  (   "[  Options:  [  short   "  )  ;  buf  .  append  (  shortOpts  .  toString  (  )  )  ;  buf  .  append  (   "  ]  [  long   "  )  ;  buf  .  append  (  longOpts  )  ;  buf  .  append  (   "  ] "  )  ;    [ATTENTION]  return  buf  .  StringBuffer  (  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Options    [TYPE]  List  opts  requiredOpts  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  
[REPLACE]  return  parse  (  options,  arguments,  null,  false  )  ;	[BUGGY]  return  parse  (  options  ,  arguments  ,  false  ,  false  )  ;  [CE]  no  suitable  method  found  for  parse(Options  ,  String[]  ,  boolean  ,  boolean)  [CONTEXT]  public  CommandLine  parse  (  Options  options  ,  String[]  arguments  )  throws  ParseException  {  [ATTENTION]  return  parse  (  options  ,  arguments  ,  false  ,  false  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  String[]  arguments  [TYPE]  boolean  false  true  
[REPLACE]  return  parse  (  options,  arguments,  properties,  false  )  ;	[BUGGY]  return  parse  (  options  ,  arguments  ,  properties  ,  true  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  CommandLine  parse  (  Options  options  ,  String[]  arguments  ,  Properties  properties  )  throws  ParseException  {  [ATTENTION]  return  parse  (  options  ,  arguments  ,  properties  ,  true  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  String[]  arguments  [TYPE]  boolean  false  true  [TYPE]  Properties  properties  
[REPLACE]  return  parse  (  options,  arguments,  null,  stopAtNonOption  )  ;	[BUGGY]  return  parse  (  options  ,  arguments  ,  false  ,  stopAtNonOption  )  ;  [CE]  no  suitable  method  found  for  parse(Options  ,  String[]  ,  boolean  ,  boolean)  [CONTEXT]  public  CommandLine  parse  (  Options  options  ,  String[]  arguments  ,  boolean  stopAtNonOption  )  throws  ParseException  {  [ATTENTION]  return  parse  (  options  ,  arguments  ,  false  ,  stopAtNonOption  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  String[]  arguments  [TYPE]  boolean  false  stopAtNonOption  true  
[REPLACE]  this  .  options  =  options;	[BUGGY]  this  .  options  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    [ATTENTION]  this  .  options  =  null  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  requiredOptions  =  options  .  getRequiredOptions  (  )  ;	[BUGGY]  requiredOptions  =    opts  .  getRequiredOptions  (  )  ;  [CE]  cannot  find  symbol  opts  [CONTEXT]  {    this  .  options  =  options  ;  [ATTENTION]  requiredOptions  =  opts  .  getRequiredOptions  (  )    ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  requiredOptions  =  options  .  getRequiredOptions  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  [ATTENTION]  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  =  new  CommandLine  (  )  ;	[BUGGY]  cmd  ;  [CE]  not  a  statement  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  [ATTENTION]  cmd  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  boolean  eatTheRest  =  false;	[BUGGY]  boolean  eatTheRest  =  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    [ATTENTION]  boolean  eatTheRest  =  true  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  arguments  ==  null  )  {	[BUGGY]  if  (  arguments  !  =  true  )  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    [ATTENTION]  if  (  arguments  !  =  true  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  arguments  =  new  String[0];	[BUGGY]  arguments  =  new  String[4]  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  arguments  =  =  null  )  {  [ATTENTION]  arguments  =  new  String[4]  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  arguments  =  new  String[0];	[BUGGY]  arguments  =  new  String[1]  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  [ATTENTION]  arguments  =  new  String[1]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options,  arguments,  stopAtNonOption  )  )  ;	[BUGGY]  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  true  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  [ATTENTION]  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  true  )  )    ;      ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;	[BUGGY]  ListIterator  iterator  =  requiredOptions  .  listIterator  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    [ATTENTION]  ListIterator  iterator  =  requiredOptions  .  listIterator  (  )    ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  {	[BUGGY]  while  (  iterator  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  [ATTENTION]  while  (  iterator  .  next  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  ! "-- "  .  equals  (  str  )  )  {	[BUGGY]  if  (  ! "-- "  .  equals  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  if  (  ! "-- "  .  equals  (  t  )  )  {  cmd  .  addArg  (  str  )  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  str  )  ;	[BUGGY]  cmd  .  addArg  (  t  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )    ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )    ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (   "-- "  .  equals  (  t  )  )  {	[BUGGY]  else  if  (   "- "  .  equals  (  t  )  )  {[CE]  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  else  if  (   "- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (   "- "  .  equals  (  t  )  )  {	[BUGGY]  else  {[CE]  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    [ATTENTION]  else  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (  t  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]  else  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]      }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  [ATTENTION]  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  stopAtNonOption  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  processOption  (  t,  iterator  )  ;	[BUGGY]  processOption  (  str  ,  iterator  )  ;  [CE]  cannot  find  symbol  str  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  processOption  (  str  ,  iterator  )    ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]      else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  processOption  (  t,  iterator  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  variable  t  is  already  defined  in  method  parse(Options  ,  String[]  ,  Properties  ,  boolean)  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]      }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  [ATTENTION]  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )[CE]  [CONTEXT]  else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]      else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  t  )  ;	[BUGGY]  cmd  .  hasOption  (  str  )  ;  [CE]  cannot  find  symbol  str  [CONTEXT]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  [ATTENTION]  cmd  .  hasOption  (  str  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  [ATTENTION]  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )[CE]  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]      else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  t  )  ;	[BUGGY]  cmd  .  addArg  (  str  )  ;  [CE]  cannot  find  symbol  str  [CONTEXT]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  [ATTENTION]  cmd  .  addArg  (  str  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  [ATTENTION]  }  else  {  cmd  .  addArg  (  t  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (  t  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  t  .  startsWith  (   "- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;	[BUGGY]  [CE]  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]      cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REMOVE]  	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  variable  t  is  already  defined  in  method  parse(Options  ,  String[]  ,  Properties  ,  boolean)  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  processOption  (  t  ,  iterator  )  ;      [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (   "-- "  .  equals  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (   "- "  .  equals  (  t  )  )  {	[BUGGY]  if  (   "- "  .  equals  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    [ATTENTION]  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  processOption  (  t,  iterator  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  variable  t  is  already  defined  in  method  parse(Options  ,  String[]  ,  Properties  ,  boolean)  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  processOption  (  t,  iterator  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;	[BUGGY]  cmd  .  addArg  (  t  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )    ;    }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (false  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  false  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  processOption  (  t,  iterator  )  ;	[BUGGY]  processOption  (  str  ,  iterator  )  ;  [CE]  cannot  find  symbol  str  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  processOption  (  str  ,  iterator  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  processOption  (  t,  iterator  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  cmd  .  addArg  (  t  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  [ATTENTION]  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )[CE]  invalid  method  declaration  ;  return  type  required  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  str  )  )  {[CE]  cannot  find  symbol  str  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  options  .  hasOption  (  str  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]      else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  eatTheRest  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [ATTENTION]  if  (  true  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  {	[BUGGY]  while  (  iterator  .  next  (  )  )  {[CE]  incompatible  types  [CONTEXT]  if  (  eatTheRest  )  {  [ATTENTION]  while  (  iterator  .  next  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  ! "-- "  .  equals  (  str  )  )  {	[BUGGY]  if  (  ! "-- "  .  equals  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  if  (  ! "-- "  .  equals  (  t  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  str  )  ;	[BUGGY]  cmd  .  addArg  (  t  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )    ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )    ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  str  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]      }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )    ;  [CE]  inconvertible  types  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  ! "-- "  .  equals  (  str  )  )  {	[BUGGY]  if  (   "-- "  .  equals  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  if  (   "-- "  .  equals  (  t  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  str  )  ;	[BUGGY]  cmd  .  addArg  (  t  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  t  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  hasNext  (  )    ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  t  =  (  String  )  iterator  .  hasNext  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )    ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  str  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  {	[BUGGY]  while  (  iterator  .  next  (  )    )  {[CE]  incompatible  types  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  [ATTENTION]  while  (  iterator  .  next  (  )    )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  ! "-- "  .  equals  (  str  )  )  {	[BUGGY]  if  (  ! "-- "  .  equalsIgnoreCase  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  if  (  ! "-- "  .  equalsIgnoreCase  (  t  )  )  {  cmd  .  addArg  (  str  )  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  str  )  ;	[BUGGY]  cmd  .  addOption  (  null  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  cmd  .  addOption  (  null  )  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  cmd  .  addArg  (  str  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )    ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (   "-- "  .  equals  (  t  )  )  {	[BUGGY]  else  if  (   "- "  .  equals  (  t  )  )  {[CE]  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  else  if  (   "- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true;  }	[BUGGY]  [CE]  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]        else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (   "- "  .  equals  (  t  )  )  {	[BUGGY]  else  {[CE]  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    [ATTENTION]  else  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (  t  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  {[CE]  'else'  without  'if'  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]  else  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]      else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  t  )  ;	[BUGGY]  cmd  .  addOption  (  false  )    ;  [CE]  method  addOption  in  class  CommandLine  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  [ATTENTION]  cmd  .  addOption  (  false  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  stopAtNonOption  )[CE]  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]  if  (  stopAtNonOption  )    eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  cmd  .  addArg  (  t  )  ;	[BUGGY]  cmd  .  hasOption  (  t  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  [ATTENTION]  cmd  .  hasOption  (  t  )    ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (  t  .  startsWith  (   "- "  )  )  {	[BUGGY]  else  if  (  t  .  startsWith  (   "- "  )  )[CE]  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]  else  if  (  t  .  startsWith  (   "- "  )  )    if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  stopAtNonOption  &&  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    [ATTENTION]      }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  [ATTENTION]  eatTheRest  =  false  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]    }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (   "-- "  .  equals  (  t  )  )  {  [ATTENTION]  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (   "- "  .  equals  (  t  )  )  {	[BUGGY]  if  (   "-- "  .  equals  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    [ATTENTION]  if  (   "-- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  options  .  getOption  (  t  )  )  {[CE]  incompatible  types  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  options  .  getOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]    }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  t  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  [ATTENTION]  if  (  options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]    }  else  {  processOption  (  t  ,  iterator  )  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  [ATTENTION]  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  stopAtNonOption  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  [ATTENTION]  if  (  true  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  else  if  (  t  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  t  .  startsWith  (   "- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    [ATTENTION]  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  eatTheRest  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    [ATTENTION]  if  (  true  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  cmd  .  addArg  (  str  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  [ATTENTION]  }  }  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  ! "-- "  .  equals  (  str  )  )  {	[BUGGY]  if  (  ! "-- "  .  equalsIgnoreCase  (  str  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]  if  (  ! "-- "  .  equalsIgnoreCase  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      [ATTENTION]      }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  eatTheRest  =  true;	[BUGGY]  eatTheRest  =  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  [ATTENTION]  eatTheRest  =  false  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  eatTheRest  =  true;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  [ATTENTION]  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  t  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  t  =  (  String  )  iterator  .  hasNext  (  )    ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[ADD]  String  t  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  t  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iterator  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iterator  .  hasNext  (  )    ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  processProperties  (  properties  )  ;	[BUGGY]  cmd  .  addOption  (  opt  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  [ATTENTION]  cmd  .  addOption  (  opt  )    ;  checkRequiredOptions  (  )  ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  checkRequiredOptions  (  )  ;	[BUGGY]  cmd  .  addOption  (  opt  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  [ATTENTION]  cmd  .  addOption  (  opt  )    ;    return  cmd  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  return  cmd;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  {    this  .  options  =  options  ;  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  cmd  =  new  CommandLine  (  )  ;    boolean  eatTheRest  =  false  ;    if  (  arguments  =  =  null  )  {  arguments  =  new  String[0]  ;  }  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options  ,  arguments  ,  stopAtNonOption  )  )  ;    ListIterator  iterator  =  tokenList  .  listIterator  (  )  ;      while  (  iterator  .  hasNext  (  )  )  {  String  t  =    (  String  )  iterator  .  next  (  )  ;      if  (   "-- "  .  equals  (  t  )  )  {  eatTheRest  =  true  ;  }    else  if  (   "- "  .  equals  (  t  )  )  {  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  else  {  cmd  .  addArg  (  t  )  ;  }  }    else  if  (  t  .  startsWith  (   "- "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true  ;  cmd  .  addArg  (  t  )  ;  }  else  {  processOption  (  t  ,  iterator  )  ;  }  }    else  {  cmd  .  addArg  (  t  )  ;    if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  }  }    if  (  eatTheRest  )  {  while  (  iterator  .  hasNext  (  )  )  {  String  str  =    (  String  )  iterator  .  next  (  )  ;      if  (  ! "-- "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  }  }  }  }  processProperties  (  properties  )  ;  checkRequiredOptions  (  )  ;    [ATTENTION]  return  ;  }    [METHOD]  parse  [TYPE]  CommandLine  [PARAMETER]  Options  options  String[]  arguments  Properties  properties  boolean  stopAtNonOption  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  String[]  arguments  [TYPE]  String  str  t  [TYPE]  Properties  properties  [TYPE]  ListIterator  iterator  
[REPLACE]  if  (  properties  ==  null  )  {	[BUGGY]  if  (  properties  !  =  true  )  {[CE]  incomparable  types:  Properties  and  boolean  [CONTEXT]  {  [ATTENTION]  if  (  properties  !  =  true  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  return;	[BUGGY]  return  cmd  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  if  (  properties  =  =  null  )  {  [ATTENTION]  return  cmd  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  return;	[BUGGY]  return  cmd  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  {  if  (  properties  =  =  null  )  {  [ATTENTION]  return  cmd  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  !cmd  .  hasOption  (  option  )  )  {	[BUGGY]  if  (  cmd  .  hasOption  (  option  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    [ATTENTION]  if  (  cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  opt  .  hasArg  (  )  )  {	[BUGGY]  if  (   "-- "  .  equals  (  t  )  )  {[CE]  cannot  find  symbol  t  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    [ATTENTION]  if  (   "-- "  .  equals  (  t  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  else  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  else  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (    (  opt  .  getValues  (  )  .  length  -  4  =  =  0  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (    (  opt  .  getValues  (  )    .  length  -  4  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  try  {  opt  .  addValue  (  value  )  ;  }	[BUGGY]  opt  .  addValue  (  value  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  [ATTENTION]  opt  .  addValue  (  value  )    ;      catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  opt  .  getValues  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  opt  .  getValues  (  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  ||  (  opt  .  getValues  (  )    .  length  =  =  0  )  )  {  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  false  )  ||  (  opt  .  getValues  (  )  .  length  -  5  =  =  0  )  )  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  false  )  ||  (  opt  .  getValues  (  )    .  length  -  5  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  try  {  opt  .  addValue  (  value  )  ;  }	[BUGGY]  opt  .  addValue  (  value  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  [ATTENTION]  opt  .  addValue  (  value  )    ;      catch  (  RuntimeException  exp  )  {    }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  ||  (  opt  .  getValues  (  )    .  length  =  =  0  )  )  {  }  catch  (  RuntimeException  exp  )  {    }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  opt  .  addValue  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  }  catch  (  RuntimeException  exp  )  {    }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]          break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  try  {  opt  .  addValue  (  value  )  ;  }	[BUGGY]  opt  .  addValue  (  value  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  [ATTENTION]  opt  .  addValue  (  value  )    ;      catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  opt  .  getValues  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  try  {  [ATTENTION]  opt  .  getValues  (  )  ;  }  catch  (  RuntimeException  exp  )  {    }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ;	[BUGGY]  Option  opt  =  options  .  hasOption  (  option  )  ;  [CE]  incompatible  types  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  [ATTENTION]  Option  opt  =  options  .  hasOption  (  option  )    ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  cannot  find  symbol  iterator  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  catch  (  RuntimeException  exp  )  {	[BUGGY]  [CE]  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  [ATTENTION]    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  opt  .  hasArg  (  )  )  {	[BUGGY]  if  (   "-- "  .  equals  (  t  )  )  {[CE]  cannot  find  symbol  t  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    [ATTENTION]  if  (   "-- "  .  equals  (  t  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  else  if  (   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  else  if  (   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]          break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  null  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  null  )    )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  catch  (  RuntimeException  exp  )  {	[BUGGY]  [CE]  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  [ATTENTION]    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  this  )  ||  (  opt  .  getValues  (  )  .  length  *  0  .  5    =  =  0  )  )  {[CE]  incomparable  types:  String[]  and  Parser  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  this  )  ||  (  opt  .  getValues  (  )    .  length  *0  .  5  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  opt  .  getValues  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  opt  .  getValues  (  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REMOVE]  	[BUGGY]  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  [ATTENTION]  opt  .  addValue  (  value  )  ;    ||  (  opt  .  getValues  (  )    .  length  =  =  0  )  )  {}  catch  (  RuntimeException  exp  )  {    }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  catch  (  RuntimeException  exp  )  {	[BUGGY]  [CE]  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  [ATTENTION]    }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ;  if  (  !cmd  .  hasOption  (  option  )  )	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  [ATTENTION]      {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  !cmd  .  hasOption  (  option  )  )  {	[BUGGY]  if  (  cmd  .  hasOption  (  option  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    [ATTENTION]  if  (  cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  if  (  (   "yes "  .  equals  (  null  )  ||   "true "[CE]  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  if  (  (   "yes "  .  equals  (  null  )  ||   "true "        break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  (  )    =  =  0  )  )  {[CE]  cannot  find  symbol  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  null  )  ||  (  opt  .  getValues  (  )    .  length  (  )  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {  try	[BUGGY]  [CE]  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]      {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (    (  opt  .  getValues  (  )  .  length  -  5  =  =  0  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (    (  opt  .  getValues  (  )    .  length  -  5  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  opt  .  addValue  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  try  {  [ATTENTION]  }  catch  (  RuntimeException  exp  )  {    }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  String  value  =  properties  .  propertyNames  (  )    ;  [CE]  incompatible  types  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]  String  value  =  properties  .  propertyNames  (  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  [CE]  cannot  find  symbol  value  [CONTEXT]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  opt  .  hasArg  (  )  )  {	[BUGGY]  if  (   "-- "  .  equals  (  t  )  )  {[CE]  cannot  find  symbol  t  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    [ATTENTION]  if  (   "-- "  .  equals  (  t  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  /  0  .  5    =  =  0  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  null  )  ||  (  opt  .  getValues  (  )    .  length  /0  .  5  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )    =  =  this  )  ||  (  opt  .  getValues  (  )  .  length  *  0  .  5    =  =  0  )  )  {[CE]  incomparable  types:  String[]  and  Parser  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  if  (  (  opt  .  getValues  (  )  =  =  this  )  ||  (  opt  .  getValues  (  )    .  length  *0  .  5  =  =  0  )  )  {    try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {	[BUGGY]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )  )  {[CE]  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  [ATTENTION]  if  (  (   "yes "  .  equalsIgnoreCase  (  value  )    )  {        break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  try  {  opt  .  addValue  (  value  )  ;  }	[BUGGY]  opt  .  addValue  (  value  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  [ATTENTION]  opt  .  addValue  (  value  )    ;      catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  opt  .  addValue  (  value  )  ;	[BUGGY]  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  try  {  [ATTENTION]  ||  (  opt  .  getValues  (  )    .  length  =  =  0  )  )  {  }  catch  (  RuntimeException  exp  )  {    }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ;	[BUGGY]  String  option  =  e  .  nextElement  (  )    .  Object  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  [ATTENTION]  String  option  =  e  .  nextElement  (  )  .  Object  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ;	[BUGGY]  Option  opt  =  options  .  hasOption  (  option  )  ;  [CE]  incompatible  types  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  [ATTENTION]  Option  opt  =  options  .  hasOption  (  option  )    ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  cannot  find  symbol  iterator  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  [CE]  cannot  find  symbol  value  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  catch  (  RuntimeException  exp  )  {	[BUGGY]  [CE]  [CONTEXT]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  [ATTENTION]    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[ADD]  try  {  opt  .  addValue  (  value  )  ;  }	[BUGGY]  opt  .  addValue  (  value  )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  [ATTENTION]  opt  .  addValue  (  value  )    ;      catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {	[BUGGY]  for  (  Enumeration  e  =  properties  .  getProperty  (  value  )    ;  e  .  hasMoreElements  (  )  ;  )  {[CE]  cannot  find  symbol  value  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  [ATTENTION]  for  (  Enumeration  e  =  properties  .  getProperty  (  value  )  ;  e  .  hasMoreElements  (  )    ;    )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ;	[BUGGY]  String  option  =  e  .  nextElement  (  )    .  Object  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  [ATTENTION]  String  option  =  e  .  nextElement  (  )  .  Object  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ;	[BUGGY]  Option  opt  =  options  .  hasOption  (  option  )  ;  [CE]  incompatible  types  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  [ATTENTION]  Option  opt  =  options  .  hasOption  (  option  )    ;      String  value  =  properties  .  getProperty  (  option  )  ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  cannot  find  symbol  iterator  [CONTEXT]  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;    if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;      [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;    if  (  opt  .  hasArg  (  )  )  {  if  (  (  opt  .  getValues  (  )    =  =  null  )  ||  (  opt  .  getValues  (  )  .  length  =  =  0  )  )  {  try  {  opt  .  addValue  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {    }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {      break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  }    [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  
[REPLACE]  while  (  iter  .  hasNext  (  )  )  {	[BUGGY]  while  (  iter  .  next  (  )    )  {[CE]  incompatible  types  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      [ATTENTION]  while  (  iter  .  next  (  )    )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ;	[BUGGY]  buff  .  toString  (  )    ;  [FE]  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  toString  (  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ;	[BUGGY]  buff  .  append  (  iter  .  hasNext  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  append  (  iter  .  hasNext  (  )  )    ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[ADD]  buff  .  append  (  iter  .  next  (  )  )  ;	[BUGGY]  [FE]  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  if  (  requiredOptions  .  size  (  )  >  0  )  {	[BUGGY]  if  (  requiredOptions  .  size  (  )  -  3  >  0  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      [ATTENTION]  if  (  requiredOptions  .  size  (  )  -  3  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[ADD]  while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      [ATTENTION]    }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ;	[BUGGY]  buff  .  append  (  iter  .  hasNext  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  append  (  iter  .  hasNext  (  )    )    ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  cannot  find  symbol  iterator  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  buff  .  append  (  iter  .  next  (  )  )  ;    String  t  =  (  String  )  iterator  .  next  (  )    ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;	[BUGGY]  Iterator  iter  =  requiredOptions  .  listIterator  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  [ATTENTION]  Iterator  iter  =  requiredOptions  .  listIterator  (  )    ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[ADD]  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  iter  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  [ATTENTION]      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  )  ;	[BUGGY]  String  t  =    (  String  )  iterator  .  next  (  )  ;  [CE]  cannot  find  symbol  iterator  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  [ATTENTION]  String  t  =  (  String  )  iterator  .  next  (  )    ;      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  buff  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  [ATTENTION]      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  throw  new  MissingOptionException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  [ATTENTION]  return  ;  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[ADD]  throw  new  MissingOptionException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {      if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ;      while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  [ATTENTION]  }  }    [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  Iterator  iter  [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  tokenList  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  
[REPLACE]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  str  .  startsWith  (   "- "  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]  if  (  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]          try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  iter  .  previous  (  )  ;	[BUGGY]  iter  .  next  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  [ATTENTION]  iter  .  next  (  )    ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }	[BUGGY]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    [ATTENTION]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )    ;      catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;	[BUGGY]  opt  .  getValues  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  [ATTENTION]  opt  .  getValues  (  )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;	[BUGGY]  opt  .  addValue  (    str      )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  [ATTENTION]  opt  .  addValue  (  str  )    ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  String  str  =  (  String  )  iter  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iter  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iter  .  hasNext  (  )    ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {	[BUGGY]  if  (  options  .  hasOption  (  str  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      [ATTENTION]  if  (  options  .  hasOption  (  str  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  iter  .  previous  (  )  ;	[BUGGY]  iter  .  next  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  [ATTENTION]  iter  .  next  (  )    ;  break  ;  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  iter  .  previous  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  [ATTENTION]  break  ;  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }	[BUGGY]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  [CE]  'catch'  without  'try'  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    [ATTENTION]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )    ;      catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;	[BUGGY]  opt  .  addValue  (    str      )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  try  {  [ATTENTION]  opt  .  addValue  (  str  )    ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  String  str  =  (  String  )  iter  .  next  (  )  ;	[BUGGY]  String  str  =    (  String  )  iter  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iter  .  hasNext  (  )    ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {	[BUGGY]  if  (  (  opt  .  getValues  (  )  !  =  false  )  )  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  [ATTENTION]  if  (  (  opt  .  getValues  (  )  !  =  false  )  )  {  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  [ATTENTION]  return  ;    }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  [ATTENTION]        [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  +  opt  .  getKey  (  )  )  ;	[BUGGY]  +  opt  .  addValue  (  )  )  ;  [CE]  method  addValue  in  class  Option  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  [ATTENTION]  +  opt  .  addValue  (  )  )    ;  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  [ATTENTION]  return  ;    }  }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[ADD]  throw  new  MissingArgumentException  (   "Missing  argument  for  option: "  +  opt  .  getKey  (  )  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  {    while  (  iter  .  hasNext  (  )  )  {  String  str  =    (  String  )  iter  .  next  (  )  ;      if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (   "- "  )  )  {  iter  .  previous  (  )  ;  break  ;  }    try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  }  catch  (  RuntimeException  exp  )  {  iter  .  previous  (  )  ;  break  ;  }  }  if  (  (  opt  .  getValues  (  )    =  =  null  )  &&  !opt  .  hasOptionalArg  (  )  )  {  [ATTENTION]    }    [METHOD]  processArgs  [TYPE]  void  [PARAMETER]  Option  opt  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  str  [TYPE]  ListIterator  iter  
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;	[BUGGY]  boolean  .  getOption  =  options  .  hasOption  (  arg  )  ;  [CE]  class  expected  [CONTEXT]  {  [ATTENTION]  boolean  .  getOption  =  options  .  hasOption  (  arg  )    ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  !hasOption  )  {	[BUGGY]  if  (  hasOption  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      [ATTENTION]  if  (  hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  !hasOption  )  {  [ATTENTION]  return  ;    }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  [ATTENTION]  return  ;    }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  final  Option  opt  =  options  .  getOption  (  arg  )  ;	[BUGGY]  final  Option  opt  =  options  .  hasOption  (  arg  )  ;  [CE]  incompatible  types  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    [ATTENTION]  final  Option  opt  =  options  .  hasOption  (  arg  )    ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[ADD]  final  Option  opt  =  options  .  getOption  (  arg  )  ;	[BUGGY]  [CE]  cannot  find  symbol  opt  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    [ATTENTION]        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  opt  .  isRequired  (  )  )  {	[BUGGY]  if  (  group  .  isRequired  (  )  )  {[CE]  cannot  find  symbol  group  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        [ATTENTION]  if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;	[BUGGY]  cmd  .  addOption  (  opt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  isRequired  (  )  )  {  [ATTENTION]  cmd  .  addOption  (  opt  )    ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;	[BUGGY]  requiredOptions  .  remove  (  opt  .  getValues  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  isRequired  (  )  )  {  [ATTENTION]  requiredOptions  .  remove  (  opt  .  getValues  (  )  )    ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  options  .  getOptionGroup  (  opt  )  !=  null  )  {	[BUGGY]  if  (  options  .  getOptionGroup  (  opt  )    =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      [ATTENTION]  if  (  options  .  getOptionGroup  (  opt  )  =  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  group  .  isRequired  (  )  )  {	[BUGGY]  if  (  opt  .  isRequired  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    [ATTENTION]  if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  requiredOptions  .  remove  (  group  )  ;	[BUGGY]  requiredOptions  .  size  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  [ATTENTION]  requiredOptions  .  size  (  )  ;  }  group  .  setSelected  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[ADD]  requiredOptions  .  remove  (  group  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  [ATTENTION]  }  group  .  setSelected  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;	[BUGGY]  OptionGroup  group  =  options  .  getOption  (  opt  )  ;  [CE]  method  getOption  in  class  Options  cannot  be  applied  to  given  types  ;  [CONTEXT]  if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  [ATTENTION]  OptionGroup  group  =  options  .  getOption  (  opt  )    ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  group  .  isRequired  (  )  )  {	[BUGGY]  if  (  opt  .  isRequired  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    [ATTENTION]  if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  requiredOptions  .  remove  (  group  )  ;	[BUGGY]  requiredOptions  .  size  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  group  .  isRequired  (  )  )  {  [ATTENTION]  requiredOptions  .  size  (  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;	[BUGGY]  OptionGroup  group  =  options  .  getOption  (  arg  )    ;  [CE]  incompatible  types  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  [ATTENTION]  OptionGroup  group  =  options  .  getOption  (  arg  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  if  (  opt  .  hasArg  (  )  )  {	[BUGGY]  if  (  opt  .  getKey  (  )  )  {[CE]  incompatible  types  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    [ATTENTION]  if  (  opt  .  getKey  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      cmd  .  addOption  (  opt  )  ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  processArgs  (  opt,  iter  )  ;	[BUGGY]  String  str  =    (  String  )  iter  .  next  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  opt  .  hasArg  (  )  )  {  [ATTENTION]  String  str  =  (  String  )  iter  .  next  (  )    ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  cmd  .  addOption  (  opt  )  ;	[BUGGY]  cmd  .  hasOption  (  opt  )  ;  [CE]  no  suitable  method  found  for  hasOption(Option)  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      [ATTENTION]  cmd  .  hasOption  (  opt  )    ;  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[ADD]  cmd  .  addOption  (  opt  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  {  boolean  hasOption  =  options  .  hasOption  (  arg  )  ;      if  (  !hasOption  )  {  throw  new  UnrecognizedOptionException  (   "Unrecognized  option:   "  +  arg  )  ;  }    final  Option  opt  =  options  .  getOption  (  arg  )  ;        if  (  opt  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ;  }      if  (  options  .  getOptionGroup  (  opt  )  !  =  null  )  {  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ;    if  (  group  .  isRequired  (  )  )  {  requiredOptions  .  remove  (  group  )  ;  }  group  .  setSelected  (  opt  )  ;  }    if  (  opt  .  hasArg  (  )  )  {  processArgs  (  opt  ,  iter  )  ;  }      [ATTENTION]  }    [METHOD]  processOption  [TYPE]  void  [PARAMETER]  String  arg  ListIterator  iter  [CLASS]  Parser    [TYPE]  Options  options  opts  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  hasOption  true  [TYPE]  OptionGroup  group  [TYPE]  List  requiredOptions  tokenList  [TYPE]  Option  opt  [TYPE]  String  arg  [TYPE]  ListIterator  iter  
[REPLACE]  private  List  args  =  new  LinkedList  (  )  ;	[BUGGY]  private  List  args  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  CommandLine  
[REPLACE]  private  Set  options  =  new  HashSet  (  )  ;	[BUGGY]  private  Set  options  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]      [CLASS]  CommandLine  
[REPLACE]  return  options  .  contains  (  resolveOption  (  opt  )  )  ;	[BUGGY]  return  getOptionValue  (  String  .  valueOf  (  opt  )  ,  defaultValue  )  ;  [CE]  cannot  find  symbol  defaultValue  [CONTEXT]  public  boolean  hasOption  (  String  opt  )  {  [ATTENTION]  return  getOptionValue  (  String  .  valueOf  (  opt  )    ,  defaultValue  )    ;  }    [METHOD]  hasOption  [TYPE]  boolean  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  hasOption  (  String  .  valueOf  (  opt  )  )  ;	[BUGGY]  return  getOptionObject  (  String  .  valueOf  (  opt  )  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasOption  (  char  opt  )  {  [ATTENTION]  return  getOptionObject  (  String  .  valueOf  (  opt  )  )    ;  }    [METHOD]  hasOption  [TYPE]  boolean  [PARAMETER]  char  opt  [CLASS]  CommandLine    [TYPE]  char  opt  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  String  res  =  getOptionValue  (  opt  )  ;	[BUGGY]  String  answer  =  getOptionValue  (  opt  )  ;  [CE]  cannot  find  symbol  res  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  [ATTENTION]  String  answer  =  getOptionValue  (  opt  )    ;    Option  option  =  resolveOption  (  opt  )  ;  if  (  option  =  =  null  )  {  return  null  ;  }  Object  type  =  option  .  getType  (  )  ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[ADD]  String  res  =  getOptionValue  (  opt  )  ;	[BUGGY]  [CE]  cannot  find  symbol  res  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  [ATTENTION]    Option  option  =  resolveOption  (  opt  )  ;  if  (  option  =  =  null  )  {  return  null  ;  }  Object  type  =  option  .  getType  (  )  ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  Option  option  =  resolveOption  (  opt  )  ;	[BUGGY]  Collection  processed  =  options  ;  [CE]  cannot  find  symbol  option  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  String  res  =  getOptionValue  (  opt  )  ;    [ATTENTION]  Collection  processed  =  options  ;  if  (  option  =  =  null  )  {  return  null  ;  }  Object  type  =  option  .  getType  (  )  ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  if  (  option  ==  null  )  {	[BUGGY]  if  (  option  !  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  String  res  =  getOptionValue  (  opt  )  ;    Option  option  =  resolveOption  (  opt  )  ;  [ATTENTION]  if  (  option  !  =  null  )  {  return  null  ;  }  Object  type  =  option  .  getType  (  )  ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  String  res  =  getOptionValue  (  opt  )  ;    Option  option  =  resolveOption  (  opt  )  ;  if  (  option  =  =  null  )  {  [ATTENTION]  return  false  ;  }  Object  type  =  option  .  getType  (  )  ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  Object  type  =  option  .  getType  (  )  ;	[BUGGY]  Object  type  =  option  .  getOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  String  res  =  getOptionValue  (  opt  )  ;    Option  option  =  resolveOption  (  opt  )  ;  if  (  option  =  =  null  )  {  return  null  ;  }  [ATTENTION]  Object  type  =  option  .  getOpt  (  )    ;    return  (  res  =  =  null  )  ?  null  :  TypeHandler  .  createValue  (  res  ,  type  )  ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  return  (  res  ==  null  )          ?  null  :  TypeHandler  .  createValue  (  res,  type  )  ;	[BUGGY]  return  TypeHandler  .  createValue  (  res  ,  type  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  Object  getOptionObject  (  String  opt  )  {  String  res  =  getOptionValue  (  opt  )  ;    Option  option  =  resolveOption  (  opt  )  ;  if  (  option  =  =  null  )  {  return  null  ;  }  Object  type  =  option  .  getType  (  )  ;    [ATTENTION]  return  TypeHandler  .  createValue  (  res  ,  type  )    ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Object  type  [TYPE]  Set  options  [TYPE]  String  opt  res  [TYPE]  boolean  false  true  
[REPLACE]  return  getOptionObject  (  String  .  valueOf  (  opt  )  )  ;	[BUGGY]  return  getOptionObject  (  String  .  equals  (  opt  )  )  ;  [CE]  non-static  method  equals(Object)  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  Object  getOptionObject  (  char  opt  )  {  [ATTENTION]  return  getOptionObject  (  String  .  equals  (  opt  )  )    ;  }    [METHOD]  getOptionObject  [TYPE]  Object  [PARAMETER]  char  opt  [CLASS]  CommandLine    [TYPE]  char  opt  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  String[]  values  =  getOptionValues  (  opt  )  ;	[BUGGY]  String  answer  =  getOptionValue  (  opt  )  ;  [CE]  cannot  find  symbol  values  [CONTEXT]  public  String  getOptionValue  (  String  opt  )  {  [ATTENTION]  String  answer  =  getOptionValue  (  opt  )    ;    return  (  values  =  =  null  )  ?  null  :  values[0]  ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  String[]  values  [TYPE]  boolean  false  true  
[REPLACE]  return  (  values  ==  null  )  ?  null  :  values[0];	[BUGGY]  return  values[0]  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  getOptionValue  (  String  opt  )  {  String[]  values  =  getOptionValues  (  opt  )  ;    [ATTENTION]  return  values[0]  ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  String[]  values  [TYPE]  boolean  false  true  
[REPLACE]  return  getOptionValue  (  String  .  valueOf  (  opt  )  )  ;	[BUGGY]  return  hasOption  (  String  .  valueOf  (  opt  )  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  getOptionValue  (  char  opt  )  {  [ATTENTION]  return  hasOption  (  String  .  valueOf  (  opt  )  )    ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  char  opt  [CLASS]  CommandLine    [TYPE]  char  opt  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  Option  key  =  resolveOption  (  opt  )  ;	[BUGGY]  String[]  values  =  getOptionValues  (  opt  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  public  String[]  getOptionValues  (  String  opt  )  {  [ATTENTION]  String[]  values  =  getOptionValues  (  opt  )    ;    if  (  options  .  contains  (  key  )  )  {  return  key  .  getValues  (  )  ;  }  return  null  ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  key  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  if  (  options  .  contains  (  key  )  )  {	[BUGGY]  if  (  options  .  iterator  (  )    )  {[CE]  incompatible  types  [CONTEXT]  public  String[]  getOptionValues  (  String  opt  )  {  Option  key  =  resolveOption  (  opt  )  ;    [ATTENTION]  if  (  options  .  iterator  (  )    )  {  return  key  .  getValues  (  )  ;  }  return  null  ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  key  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[ADD]  if  (  options  .  contains  (  key  )  )  {  return  key  .  getValues  (  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String[]  getOptionValues  (  String  opt  )  {  Option  key  =  resolveOption  (  opt  )  ;    [ATTENTION]      return  null  ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  key  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  key  .  getValues  (  )  ;	[BUGGY]  return  key  .  getType  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String[]  getOptionValues  (  String  opt  )  {  Option  key  =  resolveOption  (  opt  )  ;    if  (  options  .  contains  (  key  )  )  {  [ATTENTION]  return  key  .  getType  (  )    ;  }  return  null  ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  key  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  String[]  getOptionValues  (  String  opt  )  {  Option  key  =  resolveOption  (  opt  )  ;    if  (  options  .  contains  (  key  )  )  {  return  key  .  getValues  (  )  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  key  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;	[BUGGY]  opt  =    Util  .  stripLeadingHyphens  (  null  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  [ATTENTION]  opt  =  Util  .  stripLeadingHyphens  (  null  )    ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {	[BUGGY]  if  (  opt  .  valueOf  (  null  )    )  {[CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  [ATTENTION]  if  (  opt  .  valueOf  (  null  )    )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  option;	[BUGGY]  return  hasOption  (  String  .  valueOf  (  opt  )  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  [ATTENTION]  return  hasOption  (  String  .  valueOf  (  opt  )  )    ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {	[BUGGY]  if  (  opt  .  valueOf  (  option  .  getLongOpt  (  )  )  )  {[CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  [ATTENTION]  if  (  opt  .  valueOf  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  option;	[BUGGY]  return  hasOption  (  String  .  valueOf  (  opt  )  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  [ATTENTION]  return  hasOption  (  String  .  valueOf  (  opt  )  )    ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  next  (  )  ;    )  {[CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  [ATTENTION]  for  (  Iterator  it  =  options  .  iterator  (  )    ;  it  .  next  (  )    ;  )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {	[BUGGY]  if  (  opt  .  equals  (  option  .  getType  (  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  [ATTENTION]  if  (  opt  .  equals  (  option  .  getType  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {	[BUGGY]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  [ATTENTION]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[ADD]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  [ATTENTION]      }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  Option  option  =  (  Option  )  it  .  next  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  it  .  hasNext  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  [ATTENTION]  Option  option  =  (  Option  )  it  .  hasNext  (  )    ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[ADD]  Option  option  =  (  Option  )  it  .  next  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  option  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  [ATTENTION]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  Option  option  =  (  Option  )  it  .  next  (  )  ;	[BUGGY]  Option  option  =    (  Option  )  it  .  hasNext  (  )    ;  [CE]  inconvertible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  [ATTENTION]  Option  option  =  (  Option  )  it  .  hasNext  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  return  null  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  private  Option  resolveOption  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;    )  {  Option  option  =    (  Option  )  it  .  next  (  )  ;  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  {  return  option  ;  }  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option  ;  }  }  [ATTENTION]  return  false  ;  }    [METHOD]  resolveOption  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  CommandLine    [TYPE]  Iterator  it  [TYPE]  List  args  [TYPE]  Option  option  [TYPE]  Set  options  [TYPE]  String  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  getOptionValues  (  String  .  valueOf  (  opt  )  )  ;	[BUGGY]  return  getOptionValues  (  String  .  equals  (  null  )    )  ;  [CE]  non-static  method  equals(Object)  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  String[]  getOptionValues  (  char  opt  )  {  [ATTENTION]  return  getOptionValues  (  String  .  equals  (  null  )    )    ;  }    [METHOD]  getOptionValues  [TYPE]  String[]  [PARAMETER]  char  opt  [CLASS]  CommandLine    [TYPE]  char  opt  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  String  answer  =  getOptionValue  (  opt  )  ;	[BUGGY]  String  answer  =  getOptionValue  (  defaultValue  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String  getOptionValue  (  String  opt  ,  String  defaultValue  )  {  [ATTENTION]  String  answer  =  getOptionValue  (  defaultValue  )    ;    return  (  answer  !  =  null  )  ?  answer  :  defaultValue  ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  String  opt  String  defaultValue  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  answer  defaultValue  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  (  answer  !=  null  )  ?  answer  :  defaultValue;	[BUGGY]  return  (  answer    =    defaultValue  ;  [CE]  ')'  expected  [CONTEXT]  public  String  getOptionValue  (  String  opt  ,  String  defaultValue  )  {  String  answer  =  getOptionValue  (  opt  )  ;    [ATTENTION]  return  (  answer  =  defaultValue  ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  String  opt  String  defaultValue  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  answer  defaultValue  opt  [TYPE]  boolean  false  true  
[REPLACE]  return  getOptionValue  (  String  .  valueOf  (  opt  )  ,  defaultValue  )  ;	[BUGGY]  return  (  answer  !  =  null  )  ?  answer  :  defaultValue  ;  [CE]  cannot  find  symbol  answer  [CONTEXT]  public  String  getOptionValue  (  char  opt  ,  String  defaultValue  )  {  [ATTENTION]  return  (  answer  !  =  null  )  ?  answer  :  defaultValue  ;  }    [METHOD]  getOptionValue  [TYPE]  String  [PARAMETER]  char  opt  String  defaultValue  [CLASS]  CommandLine    [TYPE]  char  opt  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  defaultValue  [TYPE]  boolean  false  true  
[REPLACE]  String[]  answer  =  new  String[args  .  size  (  )  ];	[BUGGY]  String[]  values  =  getOptionValues  (  opt  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  public  String[]  getArgs  (  )  {  [ATTENTION]  String[]  values  =  getOptionValues  (  opt  )    ;    args  .  toArray  (  answer  )  ;    return  answer  ;  }    [METHOD]  getArgs  [TYPE]  String[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String[]  answer  [TYPE]  boolean  false  true  
[REPLACE]  args  .  toArray  (  answer  )  ;	[BUGGY]  args  .  add  (  0  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  String[]  getArgs  (  )  {  String[]  answer  =  new  String[args  .  size  (  )  ]  ;    [ATTENTION]  args  .  add  (  0  )  ;    return  answer  ;  }    [METHOD]  getArgs  [TYPE]  String[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String[]  answer  [TYPE]  boolean  false  true  
[REPLACE]  return  answer;	[BUGGY]  return  args  ;  [CE]  incompatible  types  [CONTEXT]  public  String[]  getArgs  (  )  {  String[]  answer  =  new  String[args  .  size  (  )  ]  ;    args  .  toArray  (  answer  )  ;    [ATTENTION]  return  args  ;  }    [METHOD]  getArgs  [TYPE]  String[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String[]  answer  [TYPE]  boolean  false  true  
[REPLACE]  return  args;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  List  getArgList  (  )  {  [ATTENTION]  return  null  ;  }    [METHOD]  getArgList  [TYPE]  List  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  args  .  add  (  arg  )  ;	[BUGGY]  args  .  toArray  (  arg  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  void  addArg  (  String  arg  )  {  [ATTENTION]  args  .  toArray  (  arg  )    ;  }    [METHOD]  addArg  [TYPE]  void  [PARAMETER]  String  arg  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  String  arg  [TYPE]  boolean  false  true  
[REPLACE]  options  .  add  (  opt  )  ;	[BUGGY]  options  .  contains  (  opt  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  void  addOption  (  Option  opt  )  {  [ATTENTION]  options  .  contains  (  opt  )    ;  }    [METHOD]  addOption  [TYPE]  void  [PARAMETER]  Option  opt  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Option  opt  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  return  options  .  iterator  (  )  ;	[BUGGY]  return  getOptionValue  (  String  .  valueOf  (  opt  )  ,  defaultValue  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  public  Iterator  iterator  (  )  {  [ATTENTION]  return  getOptionValue  (  String  .  valueOf  (  opt  )    ,  defaultValue  )    ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  boolean  false  true  
[REPLACE]  Collection  processed  =  options;	[BUGGY]  Option  option  =  resolveOption  (  opt  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  public  Option[]  getOptions  (  )  {  [ATTENTION]  Option  option  =  resolveOption  (  opt  )    ;      Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ]  ;      return  (  Option[]  )  processed  .  toArray  (  optionsArray  )  ;  }    [METHOD]  getOptions  [TYPE]  Option[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  Collection  processed  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  Option[]  optionsArray  [TYPE]  boolean  false  true  
[REPLACE]  Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ];	[BUGGY]  String[]  values  =  getOptionValues  (  opt  )  ;  [CE]  cannot  find  symbol  opt  [CONTEXT]  public  Option[]  getOptions  (  )  {  Collection  processed  =  options  ;      [ATTENTION]  String[]  values  =  getOptionValues  (  opt  )    ;      return  (  Option[]  )  processed  .  toArray  (  optionsArray  )  ;  }    [METHOD]  getOptions  [TYPE]  Option[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  Collection  processed  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  Option[]  optionsArray  [TYPE]  boolean  false  true  
[ADD]  Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ];	[BUGGY]  [CE]  cannot  find  symbol  optionsArray  [CONTEXT]  public  Option[]  getOptions  (  )  {  Collection  processed  =  options  ;      [ATTENTION]      return  (  Option[]  )  processed  .  toArray  (  optionsArray  )  ;  }    [METHOD]  getOptions  [TYPE]  Option[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  Collection  processed  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  Option[]  optionsArray  [TYPE]  boolean  false  true  
[REPLACE]  return  (  Option[]  )  processed  .  toArray  (  optionsArray  )  ;	[BUGGY]  return  (  Option[]  )  processed  .  size  (  optionsArray  )  ;  [CE]  method  size  in  interface  Collection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Option[]  getOptions  (  )  {  Collection  processed  =  options  ;      Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ]  ;      [ATTENTION]  return  (  Option[]  )  processed  .  size  (  optionsArray  )    ;  }    [METHOD]  getOptions  [TYPE]  Option[]  [PARAMETER]  [CLASS]  CommandLine    [TYPE]  Collection  processed  [TYPE]  List  args  [TYPE]  Set  options  [TYPE]  Option[]  optionsArray  [TYPE]  boolean  false  true  
[REPLACE]  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;	[BUGGY]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  [ATTENTION]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )    ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;	[BUGGY]  obuilder  .  withRequired  (  option1  .  getId  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  [ATTENTION]  obuilder  .  withRequired  (  option1  .  getId  (  )  )    ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  String  shortName  =  option1  .  getOpt  (  )  ;	[BUGGY]  final  String  shortName  =  option1  .  getType  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    [ATTENTION]  final  String  shortName  =  option1  .  getType  (  )    ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  final  String  shortName  =  option1  .  getOpt  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    [ATTENTION]  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  shortName!=null  &&  ! "   "  .  equals  (  shortName  )  )  {	[BUGGY]  if  (  shortName  =  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  [ATTENTION]  if  (  shortName  =  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withShortName  (  shortName  )  ;	[BUGGY]  obuilder  .  withShortName  (  longName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  [ATTENTION]  obuilder  .  withShortName  (  longName  )    ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  String  longName  =  option1  .  getLongOpt  (  )  ;	[BUGGY]  final  String  longName  =  option1  .  getOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  [ATTENTION]  final  String  longName  =  option1  .  getOpt  (  )    ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  longName!=null  )  {	[BUGGY]  if  (  shortName  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  [ATTENTION]  if  (  shortName  =  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  if  (  longName!=null  )  {  obuilder  .  withLongName  (  longName  )  ;  }	[BUGGY]  obuilder  .  withLongName  (  longName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  [ATTENTION]  obuilder  .  withLongName  (  longName  )    ;    obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withLongName  (  longName  )  ;	[BUGGY]  obuilder  .  withLongName  (  shortName  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  [ATTENTION]  obuilder  .  withLongName  (  shortName  )    ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withId  (  option1  .  getId  (  )  )  ;	[BUGGY]  obuilder  .  withId  (  option1  .  getOpt  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  [ATTENTION]  obuilder  .  withId  (  option1  .  getOpt  (  )    )    ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withId  (  option1  .  getId  (  )  )  ;	[BUGGY]  obuilder  .  withId  (  option1  .  getOpt  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  [ATTENTION]  obuilder  .  withId  (  option1  .  getOpt  (  )  )    ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  String  description  =  option1  .  getDescription  (  )  ;	[BUGGY]  final  String  description  =  option1  .  getOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    [ATTENTION]  final  String  description  =  option1  .  getOpt  (  )    ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  description!=null  )  {	[BUGGY]  if  (  description  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  [ATTENTION]  if  (  description  =  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  obuilder  .  withDescription  (  description  )  ;	[BUGGY]  obuilder  .  withShortName  (  description  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  [ATTENTION]  obuilder  .  withShortName  (  description  )    ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  obuilder  .  withDescription  (  description  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  [ATTENTION]  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  option1  .  hasArg  (  )  )  {	[BUGGY]  if  (  !  option1  .  hasArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  [ATTENTION]  if  (  !  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  option1  .  hasValueSeparator  (  )  )  {	[BUGGY]  if  (  !  option1  .  hasValueSeparator  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  [ATTENTION]  if  (  !  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  [ATTENTION]    if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;	[BUGGY]  abuilder  .  withValidator  (  this  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  [ATTENTION]  abuilder  .  withValidator  (  this  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;	[BUGGY]  abuilder  .  withSubsequentSeparator  (  option1  .  hasValueSeparator  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  [ATTENTION]  abuilder  .  withSubsequentSeparator  (  option1  .  hasValueSeparator  (  )    )    ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  option1  .  hasOptionalArg  (  )  )  {	[BUGGY]  if  (  !  option1  .  hasOptionalArg  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  [ATTENTION]  if  (  !  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;	[BUGGY]  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    [ATTENTION]  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )    ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;	[BUGGY]  abuilder  .  withMinimum  (  option1  .  getArgName  (  )    )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    [ATTENTION]  abuilder  .  withMinimum  (  option1  .  getArgName  (  )    )    ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withMinimum  (  0  )  ;	[BUGGY]  abuilder  .  withMaximum  (  0  -  3  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  [ATTENTION]  abuilder  .  withMaximum  (  0  -  3  )    ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  type!=null  )  {	[BUGGY]  if  (  type  =  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  [ATTENTION]  if  (  type  =  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;	[BUGGY]  abuilder  .  withName  (  new  TypeHandlerValidator  (  type  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  [ATTENTION]  abuilder  .  withName  (  new  TypeHandlerValidator  (  type  )  )    ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;	[BUGGY]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  [ATTENTION]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )    ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  [ATTENTION]  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  String  argName  =  option1  .  getArgName  (  )  ;	[BUGGY]  final  String  argName  =  option1  .  getArgs  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  [ATTENTION]  final  String  argName  =  option1  .  getArgs  (  )    ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  final  String  argName  =  option1  .  getArgName  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  [ATTENTION]  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  Object  type  =  option1  .  getType  (  )  ;	[BUGGY]  final  Object  type  =  option1  .  getOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  [ATTENTION]  final  Object  type  =  option1  .  getOpt  (  )    ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;	[BUGGY]  abuilder  .  withSubsequentSeparator  (  option1  .  hasValueSeparator  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  [ATTENTION]  abuilder  .  withSubsequentSeparator  (  option1  .  hasValueSeparator  (  )  )    ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[ADD]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }	[BUGGY]  abuilder  .  withMinimum  (  0  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  [ATTENTION]  abuilder  .  withMinimum  (  0  )    ;    else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;	[BUGGY]  abuilder  .  withMinimum  (  option1  .  getArgName  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    [ATTENTION]  abuilder  .  withMinimum  (  option1  .  getArgName  (  )  )    ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REMOVE]  	[BUGGY]  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    [ATTENTION]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;      [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  abuilder  .  withMinimum  (  0  )  ;	[BUGGY]  abuilder  .  withMinimum  (  3  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  [ATTENTION]  abuilder  .  withMinimum  (  3  )    ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  if  (  type!=null  )  {	[BUGGY]  if  (  type  =  =  false  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  [ATTENTION]  if  (  type  =  =  false  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  return  obuilder  .  create  (  )  ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  return  obuilder  .  create  (  )  ;	[BUGGY]  return  obuilder  .  withArgument  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Option  option  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  )  {  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ;  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ;    final  String  shortName  =  option1  .  getOpt  (  )  ;  if  (  shortName!  =  null  &&  ! "   "  .  equals  (  shortName  )  )  {  obuilder  .  withShortName  (  shortName  )  ;  }  final  String  longName  =  option1  .  getLongOpt  (  )  ;  if  (  longName!  =  null  )  {  obuilder  .  withLongName  (  longName  )  ;  }  obuilder  .  withId  (  option1  .  getId  (  )  )  ;    final  String  description  =  option1  .  getDescription  (  )  ;  if  (  description!  =  null  )  {  obuilder  .  withDescription  (  description  )  ;  }  if  (  option1  .  hasArg  (  )  )  {  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ;  final  String  argName  =  option1  .  getArgName  (  )  ;  abuilder  .  withName  (  argName  )  ;  abuilder  .  withMaximum  (  option1  .  getArgs  (  )  )  ;  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  }  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  }  else{    abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ;  }  final  Object  type  =  option1  .  getType  (  )  ;  if  (  type!  =  null  )  {  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ;  }  obuilder  .  withArgument  (  abuilder  .  create  (  )  )  ;  }  [ATTENTION]  return  obuilder  .  withArgument  (  )    ;  }    [METHOD]  option  [TYPE]  Option  [PARAMETER]  Option  option1  [CLASS]  CLI2Converter    [TYPE]  boolean  false  true  [TYPE]  ArgumentBuilder  abuilder  [TYPE]  Option  option1  [TYPE]  DefaultOptionBuilder  obuilder  [TYPE]  Object  type  [TYPE]  String  argName  description  longName  shortName  
[REPLACE]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;	[BUGGY]  final  Set  optionGroups  =  new  HashSet  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  [ATTENTION]  final  Set  optionGroups  =  new  HashSet  (  )    ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    [ATTENTION]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[ADD]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    [ATTENTION]        gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;	[BUGGY]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  hasNext  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  hasNext  (  )    ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  Option  option2  =  option  (  option1  )  ;	[BUGGY]  final  Option  option2  =  option  (  option2  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  [ATTENTION]  final  Option  option2  =  option  (  option2  )    ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  optionGroup1  .  isRequired  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    [ATTENTION]  for  (  final  Iterator  i  =  optionGroup1  .  isRequired  (  )  .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  gbuilder  .  withMaximum  (  1  )  ;	[BUGGY]  gbuilder  .  withMaximum  (  2  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  [ATTENTION]  gbuilder  .  withMaximum  (  2  )    ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  if  (  optionGroup1  .  isRequired  (  )  )  {	[BUGGY]  if  (  optionGroup1  %  4  .  isRequired  (  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    [ATTENTION]  if  (  optionGroup1  %  4  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  gbuilder  .  withMinimum  (  1  )  ;	[BUGGY]  gbuilder  .  withMinimum  (  2  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  [ATTENTION]  gbuilder  .  withMinimum  (  2  )    ;  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[ADD]  gbuilder  .  withMinimum  (  1  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  [ATTENTION]  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  return  gbuilder  .  create  (  )  ;	[BUGGY]  return  gbuilder  .  GroupBuilder  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  OptionGroup  optionGroup1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  gbuilder  .  withMaximum  (  1  )  ;    if  (  optionGroup1  .  isRequired  (  )  )  {  gbuilder  .  withMinimum  (  1  )  ;  }  [ATTENTION]  return  gbuilder  .  GroupBuilder  (  )    ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  OptionGroup  optionGroup1  [CLASS]  CLI2Converter    [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;	[BUGGY]  final  Set  optionGroups  =  new  HashSet  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  [ATTENTION]  final  Set  optionGroups  =  new  HashSet  (  )    ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[ADD]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  [ATTENTION]    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  Set  optionGroups  =  new  HashSet  (  )  ;	[BUGGY]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    [ATTENTION]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )    ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    [ATTENTION]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  OptionGroup  optionGroup1  =  (  OptionGroup  )  i  .  next  (  )  ;	[BUGGY]  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  hasNext  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  final  OptionGroup  optionGroup1  =  (  OptionGroup  )  i  .  hasNext  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  Group  group  =  group  (  optionGroup1  )  ;	[BUGGY]  final  String  shortName  =  option1  .  getOpt  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  [ATTENTION]  final  String  shortName  =  option1  .  getOpt  (  )    ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    [ATTENTION]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  if  (  !optionInAGroup  (  option1,optionGroups  )  )  {	[BUGGY]  if  (  optionInAGroup  (  option1  ,  optionGroups  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  [ATTENTION]  if  (  optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  Option  option2  =  option  (  option1  )  ;	[BUGGY]  final  Option  option2  =  option  (  option2  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  [ATTENTION]  final  Option  option2  =  option  (  option2  )    ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[ADD]  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  [ATTENTION]    }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  contains  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  [ATTENTION]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  contains  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[ADD]  if  (  !optionInAGroup  (  option1,optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }	[BUGGY]  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  [ATTENTION]  final  Option  option2  =  option  (  option1  )    ;  gbuilder  .  withOption  (  option2  )    ;      }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;	[BUGGY]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  hasNext  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  hasNext  (  )    ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  [ATTENTION]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )    .  iterator  (  )    ;  i  .  hasNext  (  )    ;    )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  return  gbuilder  .  create  (  )  ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  return  gbuilder  .  create  (  )  ;	[BUGGY]  return  gbuilder  .  GroupBuilder  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  static  Group  group  (  final  Options  options1  )  {  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ;    final  Set  optionGroups  =  new  HashSet  (  )  ;    for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  OptionGroup  optionGroup1  =    (  OptionGroup  )  i  .  next  (  )  ;  Group  group  =  group  (  optionGroup1  )  ;  gbuilder  .  withOption  (  group  )  ;  optionGroups  .  add  (  optionGroup1  )  ;  }  for  (  final  Iterator  i  =  options1  .  getOptions  (  )  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =    (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  if  (  !optionInAGroup  (  option1  ,  optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  }  }  [ATTENTION]  return  gbuilder  .  GroupBuilder  (  )    ;  }    [METHOD]  group  [TYPE]  Group  [PARAMETER]  Options  options1  [CLASS]  CLI2Converter    [TYPE]  Options  options1  [TYPE]  Group  group  [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  optionGroup1  [TYPE]  boolean  false  true  [TYPE]  GroupBuilder  gbuilder  [TYPE]  Iterator  i  [TYPE]  Option  option1  option2  
[REPLACE]  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  {	[BUGGY]  if  (  group  .  isRequired  (  )    .  contains  (  option1  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  [ATTENTION]  if  (  group  .  isRequired  (  )  .  contains  (  option1  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )  .  contains  (  option1  )  )  {  [ATTENTION]  return  false  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  optionGroups  .  contains  (  null  )    ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  [ATTENTION]  for  (  Iterator  i  =  optionGroups  .  contains  (  null  )  ;  i  .  hasNext  (  )    ;    )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )  .  contains  (  option1  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[ADD]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =  (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  {  return  true;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  [ATTENTION]      }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  {	[BUGGY]  if  (  !  group  .  getOptions  (  )  .  contains  (  option1  )  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  [ATTENTION]  if  (  !  group  .  getOptions  (  )    .  contains  (  option1  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  OptionGroup  group  =  (  OptionGroup  )  i  .  next  (  )  ;	[BUGGY]  OptionGroup  group  =    (  OptionGroup  )  i  .  hasNext  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  [ATTENTION]  OptionGroup  group  =  (  OptionGroup  )  i  .  hasNext  (  )    ;  if  (  group  .  getOptions  (  )  .  contains  (  option1  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {	[BUGGY]  for  (  Iterator  i  =  optionGroups  .  contains  (  true  )    ;  i  .  hasNext  (  )  ;  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  [ATTENTION]  for  (  Iterator  i  =  optionGroups  .  contains  (  true  )  ;  i  .  hasNext  (  )    ;    )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )  .  contains  (  option1  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  private  static  boolean  optionInAGroup  (  final  org  .  apache  .  commons  .  cli  .  Option  option1  ,  final  Set  optionGroups  )  {  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =    (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )  .  contains  (  option1  )  )  {  return  true  ;  }  }  [ATTENTION]  return  true  ;  }    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  CLI2Converter    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  private  final  Object  type;	[BUGGY]  private  Object  type  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]    [METHOD]  optionInAGroup  [TYPE]  boolean  [PARAMETER]  Option  option1  Set  optionGroups  [CLASS]  TypeHandlerValidator    [TYPE]  Set  optionGroups  [TYPE]  OptionGroup  group  [TYPE]  boolean  false  true  [TYPE]  Iterator  i  [TYPE]  Option  option1  
[REPLACE]  this  .  type  =  type;	[BUGGY]  this  .  type  =    null  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  TypeHandlerValidator  (  final  Object  type  )  {  [ATTENTION]  this  .  type  =  null  ;  }    [METHOD]  <init>  [TYPE]  Object)  [PARAMETER]  Object  type  [CLASS]  TypeHandlerValidator    [TYPE]  Object  type  [TYPE]  boolean  false  true  
[REPLACE]  final  ListIterator  i  =  values  .  listIterator  (  )  ;	[BUGGY]  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  [ATTENTION]  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )    ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[ADD]  final  ListIterator  i  =  values  .  listIterator  (  )  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  [ATTENTION]  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  if  (  converted==null  )  {	[BUGGY]  if  (  converted!  =  null  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  [ATTENTION]  if  (  converted!  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[ADD]  if  (  converted==null  )  {  throw  new  InvalidArgumentException  ( "   ")  ;  }	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  [ATTENTION]    i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  throw  new  InvalidArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  [ATTENTION]  return  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  final  String  value  =  (  String  )  i  .  next  (  )  ;	[BUGGY]  final  String  value  =    (  String  )  i  .  hasNext  (  )    ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  [ATTENTION]  final  String  value  =  (  String  )  i  .  hasNext  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  final  Object  converted  =  TypeHandler  .  createValue  (  value,type  )  ;	[BUGGY]  final  ListIterator  i  =  values  .  listIterator  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  [ATTENTION]  final  ListIterator  i  =  values  .  listIterator  (  )    ;  if  (  converted  =  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  if  (  converted==null  )  {	[BUGGY]  if  (  converted!  =  this  )  {[FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  [ATTENTION]  if  (  converted!  =  this  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[REPLACE]  final  String  value  =  (  String  )  i  .  next  (  )  ;	[BUGGY]  final  String  value  =    (  String  )  i  .  hasNext  (  )  ;  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  [ATTENTION]  final  String  value  =  (  String  )  i  .  hasNext  (  )    ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  throw  new  InvalidArgumentException  (   "Unable  to  understand  value:   "  +  value  )  ;  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
[ADD]  throw  new  InvalidArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals(   "property "  ,  opts[0]  )  ;  assertEquals(   "value "  ,  opts[1]  )  ;  assertEquals(   "property1 "  ,  opts[2]  )  ;  assertEquals(   "value1 "  ,  opts[3]  )  ;  assertEquals(  line.getOptionValue(   "buildfile ")  ,   "mybuild.xml "  )  ;  assertTrue(  line.hasOption(   "projecthelp ")  )  ;  [CONTEXT]  public  void  validate  (  final  List  values  )  throws  InvalidArgumentException  {  final  ListIterator  i  =  values  .  listIterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  final  String  value  =    (  String  )  i  .  next  (  )  ;  final  Object  converted  =  TypeHandler  .  createValue  (  value  ,  type  )  ;  if  (  converted  =  =  null  )  {  [ATTENTION]  }  i  .  set  (  converted  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  List  values  [CLASS]  TypeHandlerValidator    [TYPE]  Object  converted  type  [TYPE]  List  values  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  ListIterator  i  
