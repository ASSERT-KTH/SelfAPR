[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, this ) ;^87^^^^^86^88^NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[CLASS] FoldConstants 1 2  [METHOD] process [RETURN_TYPE] void   Node externs Node jsRoot [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  int  AND_PRECEDENCE  OR_PRECEDENCE  Node  externs  jsRoot  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( jsRoot, compiler, this ) ;^87^^^^^86^88^NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[CLASS] FoldConstants 1 2  [METHOD] process [RETURN_TYPE] void   Node externs Node jsRoot [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  int  AND_PRECEDENCE  OR_PRECEDENCE  Node  externs  jsRoot  
[BugLab_Variable_Misuse]^int type = right.getType (  ) ;^91^^^^^76^106^int type = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.BLOCK )  {^93^^^^^78^108^if  ( type == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.BLOCK )  {^93^^^^^78^108^if  ( type == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.BLOCK )  {^93^^^^^78^108^if  ( type == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBlock ( t, right, parent ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBlock ( t, n, right ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBlock ( n, t, parent ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBlock ( t, parent, n ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBlock ( parent, n, t ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^Node left = right.getFirstChild (  ) ;^98^^^^^83^113^Node left = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( right == null )  {^99^^^^^84^114^if  ( left == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( left != null )  {^99^^^^^84^114^if  ( left == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^103^^^^^88^118^if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( right )  )  {^103^^^^^88^118^if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.TYPEOF || NodeUtil.isLiteralValue ( left )  )  {^103^^^^^88^118^if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^103^^^^^88^118^if  ( type == Token.TYPEOF && NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( "undefined".equals ( right.getString (  )  )  )  {^125^^^^^110^140^if  ( "undefined".equals ( left.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( className != null )  {^131^^^^^116^146^if  ( newValue != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( parentewValue != null )  {^131^^^^^116^146^if  ( newValue != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( newValue == null )  {^131^^^^^116^146^if  ( newValue != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newString ( newValue )  ) ;^132^^^^^117^147^parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newString ( className )  ) ;^132^^^^^117^147^parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^switch  ( right.getType (  )  )  {^106^^^^^91^121^switch  ( left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( rightewValue != null )  {^131^^^^^116^146^if  ( newValue != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( n != newValueull )  {^131^^^^^116^146^if  ( newValue != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^switch  ( parent.getType (  )  )  {^106^^^^^91^121^switch  ( left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( "undefined".equals ( parent.getString (  )  )  )  {^125^^^^^110^140^if  ( "undefined".equals ( left.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, Node.newString ( newValue )  ) ;^132^^^^^117^147^parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.NOT && type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type > Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^139^140^141^^^124^154^if  ( type == Token.NOT || type == Token.NEG || type == Token.BITNOT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( result == Token.NEW )  {^216^^^^^201^231^} else if  ( type == Token.NEW )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^} else if  ( type != Token.NEW )  {^216^^^^^201^231^} else if  ( type == Token.NEW )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^} else if  ( type <= Token.NEW )  {^216^^^^^201^231^} else if  ( type == Token.NEW )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( Token.NAME == right.getType (  )  )  {^217^^^^^202^232^if  ( Token.NAME == left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( Token.NAME != left.getType (  )  )  {^217^^^^^202^232^if  ( Token.NAME == left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( Token.NAME >= left.getType (  )  )  {^217^^^^^202^232^if  ( Token.NAME == left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( right.getNext (  )  == null )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( left.getNext (  )  == rightull )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^} else if  ( n.getNext (  )  == leftull )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^} else if  ( left.getNext (  )  != null )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( "Array".equals ( newValue )  )  {^222^^^^^207^237^if  ( "Array".equals ( className )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( "Object".equals ( newValue )  )  {^225^^^^^210^240^} else if  ( "Object".equals ( className )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, right, parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, right, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( n, t, parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, parent, n, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, className, parent, n, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( className, n, parent, t, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, right, parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, right, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, parent, newValue, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( parent, n, t, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, className, parent, n, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, n, className, parent, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( className, n, parent, t, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, n, className, parent, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( n, t, parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( t, parent, n, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLiteralConstructor ( parent, n, t, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldRegularExpressionConstructor ( t, right, parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldRegularExpressionConstructor ( t, n, right ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldRegularExpressionConstructor ( parent, n, t ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldRegularExpressionConstructor ( t, parent, n ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, n, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^String className = right.getString (  ) ;^218^^^^^203^233^String className = left.getString (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( "RegExp".equals ( newValue )  )  {^219^^^^^204^234^if  ( "RegExp".equals ( className )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldRegularExpressionConstructor ( n, t, parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, n, n, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( parent.getNext (  )  == null )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( Token.NAME == parent.getType (  )  )  {^217^^^^^202^232^if  ( Token.NAME == left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldRegularExpressionConstructor ( t, parent, parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isExpressionNode ( right )  )  {^144^^^^^129^159^if  ( NodeUtil.isExpressionNode ( parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, n.removeFirstChild (  )  ) ;^147^^^^^132^162^parent.replaceChild ( n, n.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.NOT && tryMinimizeNot ( t, right, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.NOT && tryMinimizeNot ( t, n, right )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( parent == Token.NOT && tryMinimizeNot ( t, n, type )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.NOT && tryMinimizeNot ( t, parent, n )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.NOT || tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  )  {^157^^^^^142^172^if  ( !NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.NAME )  {^171^^^^^156^186^if  ( left.getType (  )  == Token.NAME )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  >= Token.NAME )  {^171^^^^^156^186^if  ( left.getType (  )  == Token.NAME )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( right.getString (  ) .equals ( "NaN" )  )  {^175^^^^^160^190^} else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^n.removeChild ( right ) ;^177^^^^^162^192^n.removeChild ( left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, left ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^parent.replaceChild ( left, n ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( right.getString (  ) .equals ( "Infinity" )  )  {^172^^^^^157^187^if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( negNum >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( val >= Integer.type && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( val >= Integer.MIN_VALUE && val <= Integer.type )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val >= Integer.MIN_VALUE || val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val < Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val >= Integer.MIN_VALUE && val < Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, parent ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == negNum )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( intVal != val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( ~intVal )  ) ;^200^^^^^185^215^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( ~type )  ) ;^200^^^^^185^215^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( ~result )  ) ;^200^^^^^185^215^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, parent ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( val == intVal )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( intVal <= val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, parent ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  != Token.NAME )  {^171^^^^^156^186^if  ( left.getType (  )  == Token.NAME )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^} else if  ( parent.getString (  ) .equals ( "NaN" )  )  {^175^^^^^160^190^} else if  ( left.getString (  ) .equals ( "NaN" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( parent.getString (  ) .equals ( "Infinity" )  )  {^172^^^^^157^187^if  ( left.getString (  ) .equals ( "Infinity" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, Node.newNumber ( negNum )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( val )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^parent.replaceChild ( negNum, Node.newNumber ( n )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val == Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val >= Integer.MIN_VALUE && val == Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, right ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( intVal < val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^double val = parent.getDouble (  ) ;^196^^^^^181^211^double val = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, right ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^int result = NodeUtil.getBooleanValue ( right )  ? Token.FALSE : Token.TRUE;^163^164^^^^148^178^int result = NodeUtil.getBooleanValue ( left )  ? Token.FALSE : Token.TRUE;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^Preconditions.checkState ( parent.hasOneChild (  )  ) ;^142^^^^^127^157^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, n.removeFirstChild (  )  ) ;^147^^^^^132^162^parent.replaceChild ( n, n.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( nype == Token.NOT && tryMinimizeNot ( t, t, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^parent.replaceChild ( result, new Node ( n )  ) ;^165^^^^^150^180^parent.replaceChild ( n, new Node ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.NAME )  {^171^^^^^156^186^if  ( left.getType (  )  == Token.NAME )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( negNum )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, NEGATING_A_NON_NUMBER_ERROR, parent ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, INVALID_GETELEM_INDEX_ERROR, left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( NEGATING_A_NON_NUMBER_ERROR, t, left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, NEGATING_A_NON_NUMBER_ERROR ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^double val = right.getDouble (  ) ;^196^^^^^181^211^double val = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, Node.newNumber ( ~intVal )  ) ;^200^^^^^185^215^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, NEGATING_A_NON_NUMBER_ERROR, right ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( NEGATING_A_NON_NUMBER_ERROR, t, left ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, NEGATING_A_NON_NUMBER_ERROR, t ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( n == Token.NOT && tryMinimizeNot ( t, type, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val > Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( intVal >= val )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLiteralConstructor ( t, parent, parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^String className = parent.getString (  ) ;^218^^^^^203^233^String className = left.getString (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( Token.NAME < left.getType (  )  )  {^217^^^^^202^232^if  ( Token.NAME == left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldRegularExpressionConstructor ( t, n, n ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  <= Token.NAME )  {^171^^^^^156^186^if  ( left.getType (  )  == Token.NAME )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( val >= Integer.result && val <= Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( val >= Integer.MIN_VALUE && val <= Integer.result )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( val >= Integer.MIN_VALUE && val > Integer.MAX_VALUE )  {^197^^^^^182^212^if  ( val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^Preconditions.checkState ( right.hasOneChild (  )  ) ;^142^^^^^127^157^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, new Node ( result )  ) ;^165^^^^^150^180^parent.replaceChild ( n, new Node ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, NEGATING_A_NON_NUMBER_ERROR, right ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( left, NEGATING_A_NON_NUMBER_ERROR, t ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, parent ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^error ( t, left, NEGATING_A_NON_NUMBER_ERROR ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.EXPR_RESULT )  {^233^^^^^218^248^if  ( type == Token.EXPR_RESULT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.EXPR_RESULT )  {^233^^^^^218^248^if  ( type == Token.EXPR_RESULT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, right, n ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, left, parent ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, left, t ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( left, t, n ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( t, n, left ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.RETURN )  {^238^^^^^223^253^if  ( type == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.RETURN )  {^238^^^^^223^253^if  ( type == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.RETURN )  {^238^^^^^223^253^if  ( type == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.RETURN )  {^238^^^^^223^253^if  ( type == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryReduceReturn ( t, parent ) ;^239^^^^^224^254^tryReduceReturn ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryReduceReturn ( n, t ) ;^239^^^^^224^254^tryReduceReturn ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^Node right = parent.getNext (  ) ;^243^^^^^228^258^Node right = left.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( parent == null )  {^244^^^^^229^259^if  ( right == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( right != null )  {^244^^^^^229^259^if  ( right == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( parent )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.INSTANCEOF || NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type > Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isImmutableValue ( right )  )  {^253^^^^^250^266^if  ( NodeUtil.isImmutableValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, new Node ( Token.FALSE )  ) ;^255^^^^^250^266^parent.replaceChild ( n, new Node ( Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  == Token.NAME || "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  != Token.NAME && "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, new Node ( Token.TRUE )  ) ;^262^^^^^250^266^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^260^261^^^^250^266^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^&& "Object".equals ( parent.getString (  )  )  )  {^261^^^^^250^266^&& "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^&& "Object".equals ( n.getString (  )  )  )  {^261^^^^^250^266^&& "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, new Node ( Token.TRUE )  ) ;^262^^^^^250^266^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isImmutableValue ( right )  )  {^253^^^^^238^268^if  ( NodeUtil.isImmutableValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, new Node ( Token.FALSE )  ) ;^255^^^^^240^270^parent.replaceChild ( n, new Node ( Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( Token.2 )  ) ;^255^^^^^240^270^parent.replaceChild ( n, new Node ( Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^260^261^^^^245^275^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  == Token.NAME || "Object".equals ( right.getString (  )  )  )  {^260^261^^^^245^275^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  <= Token.NAME && "Object".equals ( right.getString (  )  )  )  {^260^261^^^^245^275^if  ( right.getType (  )  == Token.NAME && "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^&& NodeUtil.isLiteralValue ( right ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^251^252^^^^236^266^&& NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^&& !NodeUtil.mayHaveSideEffects ( n )  )  {^252^^^^^237^267^&& !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^&& "Object".equals ( parent.getString (  )  )  )  {^261^^^^^246^276^&& "Object".equals ( right.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( Token.this )  ) ;^262^^^^^247^277^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.IF || type == Token.HOOK )  {^268^^^^^253^283^if  ( type == Token.IF || type == Token.HOOK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.IF && type == Token.HOOK )  {^268^^^^^253^283^if  ( type == Token.IF || type == Token.HOOK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.IF || type == Token.HOOK )  {^268^^^^^253^283^if  ( type == Token.IF || type == Token.HOOK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.IF || type == Token.HOOK )  {^268^^^^^253^283^if  ( type == Token.IF || type == Token.HOOK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.IF && !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.IF && !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.IF || !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.IF && !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeIf ( t, right, parent ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeIf ( n, t, parent ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeIf ( t, parent, n ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^boolean changes = tryFoldHookIf ( t, n, right ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^boolean changes = parentryFoldHookIf ( t, n, t ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^boolean changes = tryFoldHookIf ( t, parent, n ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, parent.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, t.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, right.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^boolean changes = tryFoldHookIf ( t, right, parent ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^boolean changes = nryFoldHookIf ( t, t, parent ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeIf ( t, n, right ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeIf ( parent, n, t ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.2 && !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.IF && !changes )  {^274^^^^^259^289^if  ( type == Token.IF && !changes )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.DO )  {^280^^^^^265^295^if  ( type == Token.DO )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.DO )  {^280^^^^^265^295^if  ( type == Token.DO )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( right ) , n ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, NodeUtil.getConditionExpression ( t ) , n ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldDo ( t, n, right ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldDo ( n, t, parent ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldDo ( t, parent, n ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( parent ) , n ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldDo ( t, right, parent ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldDo ( parent, n, t ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.WHILE )  {^286^^^^^271^301^if  ( type == Token.WHILE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.WHILE )  {^286^^^^^271^301^if  ( type == Token.WHILE )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( right ) , n ) ;^287^^^^^272^302^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, NodeUtil.getConditionExpression ( t ) , n ) ;^287^^^^^272^302^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldWhile ( t, right, parent ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldWhile ( t, n, right ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldWhile ( parent, n, t ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldWhile ( t, parent, n ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldWhile ( n, t, parent ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.FOR )  {^292^^^^^277^307^if  ( type == Token.FOR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.FOR )  {^292^^^^^277^307^if  ( type == Token.FOR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.FOR )  {^292^^^^^277^307^if  ( type == Token.FOR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.FOR )  {^292^^^^^277^307^if  ( type == Token.FOR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( right != null )  {^294^^^^^279^309^if  ( condition != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( condition != rightull )  {^294^^^^^279^309^if  ( condition != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( n != conditionull )  {^294^^^^^279^309^if  ( condition != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( condition == null )  {^294^^^^^279^309^if  ( condition != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^condition = NodeUtil.getConditionExpression ( right ) ;^297^^^^^282^312^condition = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, right, n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, condition, t ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( t, n, condition ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^this.tryFoldForCondition ( right, n ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^this.tryFoldForCondition ( condition, right ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^this.tryFoldForCondition ( n, condition ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^Node condition = NodeUtil.getConditionExpression ( right ) ;^293^^^^^278^308^Node condition = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldFor ( t, right, parent ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldFor ( t, n, n ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldFor ( parent, n, t ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldFor ( t, parent, n ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^condition = NodeUtil.getConditionExpression ( parent ) ;^297^^^^^282^312^condition = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, condition, right ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( condition, t, n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldFor ( t, n, right ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldFor ( n, t, parent ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.AND || type == Token.OR )  {^305^306^^^^290^320^if  ( type == Token.AND || type == Token.OR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.AND && type == Token.OR )  {^305^306^^^^290^320^if  ( type == Token.AND || type == Token.OR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.AND || type == Token.OR )  {^305^306^^^^290^320^if  ( type == Token.AND || type == Token.OR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.AND || type == Token.OR )  {^305^306^^^^290^320^if  ( type == Token.AND || type == Token.OR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, right, left, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, right, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, left, parent, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, left, right, n ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( left, n, t, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, right, left, n, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, left, n, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, n, left, parent, right ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, parent, left, right, n ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, right, left, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, right, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, left, parent, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAndOr ( t, n, left, right, right ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( n, t, left, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, left, n, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, n, right, left, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAndOr ( t, parent, left, right, n ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.BITOR || type == Token.this )  {^311^312^^^^296^326^if  ( type == Token.BITOR || type == Token.BITAND )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.BITOR && type == Token.BITAND )  {^311^312^^^^296^326^if  ( type == Token.BITOR || type == Token.BITAND )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.BITOR || type == Token.BITAND )  {^311^312^^^^296^326^if  ( type == Token.BITOR || type == Token.BITAND )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBitAndOr ( t, n, right, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBitAndOr ( t, n, left, right, right ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( n, t, left, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, right, left, n, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, left, n, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, n, parent, right, left ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBitAndOr ( t, n, right, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBitAndOr ( t, n, left, parent, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldBitAndOr ( t, n, left, right, right ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( left, n, t, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, left, n, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, n, right, left, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldBitAndOr ( t, n, parent, right, left ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.LSH || type == Token.RSH || type == Token.URSH )  {^317^318^319^^^302^332^if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.LSH && type == Token.RSH || type == Token.URSH )  {^317^318^319^^^302^332^if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.LSH || type == Token.RSH || type == Token.URSH )  {^317^318^319^^^302^332^if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.LSH || type == Token.RSH || type == Token.URSH )  {^317^318^319^^^302^332^if  ( type == Token.LSH || type == Token.RSH || type == Token.URSH )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, n, left, n, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, n, left, right, n ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( parent, n, left, right, t ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( t, parent, left, right, n ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( t, n, right, left, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( t, right, left, n, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, right, left, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, n, right, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, n, left, parent, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldShift ( t, n, left, right, n ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( left, n, t, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( t, right, left, n, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( t, left, n, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldShift ( parent, n, left, right, t ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.GETPROP )  {^324^^^^^309^339^if  ( type == Token.GETPROP )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.GETPROP )  {^324^^^^^309^339^if  ( type == Token.GETPROP )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.GETPROP )  {^324^^^^^309^339^if  ( type == Token.GETPROP )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetProp ( t, parent, left, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetProp ( t, n, right, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetProp ( t, n, left, n, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetProp ( t, n, left, right, right ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( n, t, left, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( t, parent, left, right, n ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( left, n, t, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( t, right, left, n, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetProp ( t, n, left, parent, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( parent, n, left, right, t ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( t, n, right, left, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetProp ( t, n, parent, right, left ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.CALL )  {^329^^^^^314^344^if  ( type == Token.CALL )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.CALL )  {^329^^^^^314^344^if  ( type == Token.CALL )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type > Token.CALL )  {^329^^^^^314^344^if  ( type == Token.CALL )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringJoin ( t, parent, left, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringJoin ( t, n, right, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringJoin ( t, n, left, n, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( left, n, t, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( t, left, n, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( t, n, parent, right, left ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( t, n, left, parent, right ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringIndexOf ( t, parent, left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringIndexOf ( t, n, left, parent, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringIndexOf ( t, n, left, right, right ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( right, n, left, t, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( t, right, left, n, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( t, n, parent, right, left ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( t, n, left, parent, right ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringJoin ( t, n, left, parent, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( parent, n, left, right, t ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( t, parent, left, right, n ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringJoin ( right, n, left, t, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringIndexOf ( t, right, left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldStringIndexOf ( t, n, right, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( n, t, left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( t, parent, left, right, n ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldStringIndexOf ( t, n, right, left, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.ASSIGN )  {^335^^^^^320^350^if  ( type == Token.ASSIGN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.null )  {^335^^^^^320^350^if  ( type == Token.ASSIGN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.ASSIGN )  {^335^^^^^320^350^if  ( type == Token.ASSIGN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.ASSIGN )  {^335^^^^^320^350^if  ( type == Token.ASSIGN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAssign ( t, right, left, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAssign ( t, n, left, n ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAssign ( right, n, left, t ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAssign ( t, left, n, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAssign ( t, right, left, n ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAssign ( t, n, parent, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAssign ( t, n, left, parent ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAssign ( t, n, right, left ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  || !NodeUtil.isLiteralValue ( right )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( parent )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.isLiteralValue ( right )  || !NodeUtil.isLiteralValue ( left )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isLiteralValue ( left )  && !NodeUtil.isLiteralValue ( right )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, parent, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, n, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, right ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( parent == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, type ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( nype == Token.ADD ) tryFoldLeftChildAdd ( t, t, left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, right, left, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, right, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, left, parent, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, left, right, right ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( n, t, left, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, parent, left, right, n ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, n, parent, right, left ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.LT || type == Token.GT )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.LT || type == Token.0 )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.LT && type == Token.GT )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.LT || type == Token.GT )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.LT || type == Token.GT )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, right, left, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, parent, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, right, right ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( n, t, left, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, left, n, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, right, left, n, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, parent, right, left ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, right, left, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, parent, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( left, n, t, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, right, left, n, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, right, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( left, n, t, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, right, left, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, left, parent, right ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( intVal == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, parent, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, right, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, parent, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, right ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.ADD ) typeryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( parentype == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, t ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, right, left, n, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, parent, right, left ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, parent, left, right, n ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, right, left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, left, n, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, left, right, right ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( left, n, t, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, parent, left, right, n ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, n, right, left, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( right, n, left, t, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.LT || type == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.LT || typeype == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.LT && type == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.LT || type == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.LT || type == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, parent, left, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, parent, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, parent, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, right, n ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( left, n, t, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, right, left, n, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, right, left, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, parent, right, left ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( right )  || !NodeUtil.isLiteralValue ( right )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^!NodeUtil.isLiteralValue ( parent )  )  {^340^^^^^325^355^!NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, parent, left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldLeftChildAdd ( t, n, right, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( n, t, left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, right, left, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, right, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, parent, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, right, right ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( right, n, left, t, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( n, t, left, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, parent, right, left ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, right, left, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.ADD )  {^353^^^^^338^368^if  ( type == Token.ADD )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( t == Token.ADD )  {^353^^^^^338^368^if  ( type == Token.ADD )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.ADD )  {^353^^^^^338^368^if  ( type == Token.ADD )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, parent, left, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, n, right, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, n, left, n, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, n, left, right, n ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( left, n, t, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( t, parent, left, right, n ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( t, n, parent, right, left ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( right, n, left, t, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, right, left, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, n, left, parent, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldAdd ( t, n, left, right, right ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( n, t, left, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( t, right, left, n, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldAdd ( t, left, n, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.SUB || type == Token.MUL || type == Token.DIV )  {^357^358^359^^^342^372^if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.SUB && type == Token.MUL || type == Token.DIV )  {^357^358^359^^^342^372^if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.SUB || type == Token.MUL || type == Token.DIV )  {^357^358^359^^^342^372^if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.SUB || type == Token.MUL || type == Token.DIV )  {^357^358^359^^^342^372^if  ( type == Token.SUB || type == Token.MUL || type == Token.DIV )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, right, left, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, right, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, parent, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, right, n ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( right, n, left, t, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, left, n, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, n, parent, right, left ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, right, left, n, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, parent, left, right, n ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, parent, left, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, right, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, parent, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, right, right ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( left, n, t, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, left, n, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, n, left, parent, right ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, n, parent, right, left ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^if  ( typeype == Token.LT || t == Token.GT || type == Token.LE || type == Token.GE ||^364^365^366^367^^349^379^if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type == Token.LT && type == Token.GT || type == Token.LE || type == Token.GE ||^364^365^366^367^^349^379^if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type <= Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^364^365^366^367^^349^379^if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type >= Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^364^365^366^367^^349^379^if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type != Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^364^365^366^367^^349^379^if  ( type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE ||^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, right, left, right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, right, right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, parent, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, right, n ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( right, n, left, t, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, parent, left, right, n ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, right, left, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, parent, right, left ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, right, left, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, right, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, parent, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldComparison ( t, n, left, right, right ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( right, n, left, t, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, right, left, n, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, left, n, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldComparison ( t, n, left, parent, right ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^if  ( result == Token.GETELEM )  {^376^^^^^361^391^if  ( type == Token.GETELEM )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Wrong_Operator]^if  ( type < Token.GETELEM )  {^376^^^^^361^391^if  ( type == Token.GETELEM )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, right, left, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, n, right, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, n, left, parent, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, n, left, right, right ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( right, n, left, t, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( t, parent, left, right, n ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( t, n, parent, right, left ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( t, n, right, left, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, n, parent, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^tryFoldGetElem ( t, n, left, n, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( t, left, n, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Argument_Swapping]^tryFoldGetElem ( t, n, left, parent, right ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INVALID_GETELEM_INDEX_ERROR, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( diagnostic, n, t, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, diagnostic, n, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, SHIFT_AMOUNT_OUT_OF_BOUNDS, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( n, t, diagnostic, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[BugLab_Wrong_Literal]^while  ( false )  {^394^^^^^393^410^while  ( true )  {^[CLASS] FoldConstants 1 2  [METHOD] consumesDanglingElse [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  Node  n  
[BugLab_Wrong_Operator]^if  ( n.getChildCount (  )  <= 3 )  return true;^397^^^^^393^410^if  ( n.getChildCount (  )  < 3 )  return true;^[CLASS] FoldConstants 1 2  [METHOD] consumesDanglingElse [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  Node  n  
[BugLab_Wrong_Literal]^if  ( n.getChildCount (  )  < 3 )  return false;^397^^^^^393^410^if  ( n.getChildCount (  )  < 3 )  return true;^[CLASS] FoldConstants 1 2  [METHOD] consumesDanglingElse [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  Node  n  
[BugLab_Wrong_Literal]^return true;^407^^^^^393^410^return false;^[CLASS] FoldConstants 1 2  [METHOD] consumesDanglingElse [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  Node  n  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( right.getType (  )  == Token.ASSIGN ) ;^413^^^^^398^428^Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( n.getType (  )  <= Token.ASSIGN ) ;^413^^^^^398^428^Preconditions.checkArgument ( n.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !right.hasChildren (  )  || n.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^416^417^^^^401^431^if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !right.hasChildren (  )  && right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^416^417^^^^401^431^if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  < right.getLastChild (  )  )  {^416^417^^^^401^431^if  ( !right.hasChildren (  )  || right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^right.getFirstChild (  ) .getNext (  )  != n.getLastChild (  )  )  {^417^^^^^402^432^right.getFirstChild (  ) .getNext (  )  != right.getLastChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( right )  )  {^422^^^^^407^437^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !left.checkTreeEqualsSilent ( rightChild )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !left.checkTreeEqualsSilent ( right )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !left.checkTreeEqualsSilent ( leftChildChild )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !left.checkTreeEqualsSilent ( left )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^int newType = -2;^431^^^^^416^446^int newType = -1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^switch  ( n.getType (  )  )  {^432^^^^^417^447^switch  ( right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( result, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( newType, right.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , n.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.getParent (  ) .replaceChild ( n, new Node ( left, newType.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.getParent (  ) .replaceChild ( n, new Node ( newType, right.detachFromParent (  ) , left.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( right, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( type, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( newType, n.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , leftChild.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.getParent (  ) .replaceChild ( right, new Node ( newType, left.detachFromParent (  ) , n.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.getParent (  ) .replaceChild ( newType, new Node ( n, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^left.detachFromParent (  ) , n.getLastChild (  ) .detachFromParent (  )  )  ) ;^471^^^^^456^486^left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( parent )  )  {^482^^^^^478^497^if  ( !NodeUtil.mayHaveSideEffects ( c )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^483^^^^^478^497^n.removeChild ( c ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^for  ( Node c = parent.getFirstChild (  ) ; c != null;  )  {^480^^^^^478^497^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^for  ( Node parent = n.getFirstChild (  ) ; c != null;  )  {^480^^^^^478^497^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^for  ( Node c = n.getFirstChild (  ) ; c == null;  )  {^480^^^^^478^497^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^c = parent;^486^^^^^478^497^c = next;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node next = parent.getNext (  ) ;^481^^^^^478^497^Node next = c.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n.isSyntheticBlock (  )  || next == null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( parent.isSyntheticBlock (  )  || n == null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( n.isSyntheticBlock (  )  && parent == null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( n.isSyntheticBlock (  )  || parent != null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parent.isSyntheticBlock (  )  || parent == null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.tryMergeBlock ( parent )  )  {^494^^^^^478^497^if  ( NodeUtil.tryMergeBlock ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^int type = notBranch.getType (  ) ;^504^^^^^489^519^int type = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^int type = notCond.getType (  ) ;^504^^^^^489^519^int type = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node cond = thenBody.getFirstChild (  ) ;^505^^^^^490^520^Node cond = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node cond = thenStmt.getFirstChild (  ) ;^505^^^^^490^520^Node cond = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenBody = notBranch.getNext (  ) ;^506^^^^^491^521^Node thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseBody = notBranch.getNext (  ) ;^507^^^^^492^522^Node elseBody = thenBody.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^boolean changes = true;^509^^^^^494^524^boolean changes = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( result == Token.IF )  {^511^^^^^496^526^if  ( type == Token.IF )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( type != Token.IF )  {^511^^^^^496^526^if  ( type == Token.IF )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( type >= Token.IF )  {^511^^^^^496^526^if  ( type == Token.IF )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isExpressionNode ( secondBranch )  )  {^549^^^^^534^564^if  ( NodeUtil.isExpressionNode ( parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( parent )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( !NodeUtil.mayHaveSideEffects ( notCond )  )  {^571^^^^^556^586^} else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return false;^582^^^^^567^597^return true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( notCond )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^574^^^^^559^589^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenStmt ) ;^575^^^^^560^590^ifNode.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notBranch ) ;^576^^^^^561^591^n.removeChild ( thenBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( not )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( not )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( notBranch, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, notCond ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.getParent (  ) .replaceChild ( ifNode, parent ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( notCond, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( parent )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( !NodeUtil.mayHaveSideEffects ( parent )  )  {^571^^^^^556^586^} else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^574^^^^^559^589^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( notCond ) ;^575^^^^^560^590^ifNode.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^576^^^^^561^591^n.removeChild ( thenBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( notBranch )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( secondBranch, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, thenStmt ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( thenStmt, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( notCond.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  != Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^560^^^^^554^563^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( notCond ) ;^561^^^^^554^563^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( notCond ) ;^562^^^^^554^563^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = secondBranch.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = notBranch.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond.removeChild ( notCond ) ;^556^^^^^541^571^cond.removeChild ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return false;^570^^^^^555^585^return true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( notCond )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( notBranch.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = thenStmt.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond.removeChild ( parent ) ;^556^^^^^541^571^cond.removeChild ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenStmt ) ;^557^^^^^542^572^ifNode.addChildToBack ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^560^^^^^545^575^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( notCond ) ;^561^^^^^546^576^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( parent ) ;^562^^^^^547^577^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^565^^^^^550^580^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( notBranch )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( notBranch, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, notCond ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.getParent (  ) .replaceChild ( ifNode, parent ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( not, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenStmt.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( cond.getType (  )  == Token.1 )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  <= Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenStmt ) ;^562^^^^^554^563^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = thenBody.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( parent )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( not, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( secondBranch )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenStmt )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = notCond.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node not = new Node ( Token.3 ) ;^559^^^^^544^574^Node not = new Node ( Token.NOT ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( parent ) ;^557^^^^^542^572^ifNode.addChildToBack ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^560^^^^^545^575^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( thenStmt ) ;^561^^^^^546^576^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenBody ) ;^562^^^^^547^577^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^565^^^^^550^580^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( secondBranch, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^574^^^^^559^589^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( parent ) ;^575^^^^^560^590^ifNode.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, secondBranch ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( notBranch )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( !NodeUtil.mayHaveSideEffects ( thenStmt )  )  {^571^^^^^556^586^} else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( secondBranch )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( secondBranch ) ;^575^^^^^560^590^ifNode.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^576^^^^^561^591^n.removeChild ( thenBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( notCond )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node ifNode = new Node ( Token.3 ) ;^573^^^^^558^588^Node ifNode = new Node ( Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( secondBranch )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( notBranch )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, thenBody ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( thenBody, ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^560^^^^^554^563^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( thenStmt ) ;^561^^^^^554^563^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( parent ) ;^562^^^^^554^563^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond.removeChild ( thenBody ) ;^556^^^^^541^571^cond.removeChild ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( notCond ) ;^557^^^^^542^572^ifNode.addChildToBack ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node not = new Node ( Token.null ) ;^559^^^^^544^574^Node not = new Node ( Token.NOT ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond.removeChild ( secondBranch ) ;^556^^^^^541^571^cond.removeChild ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^560^^^^^545^575^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( notCond ) ;^562^^^^^547^577^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^565^^^^^550^580^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( notCond )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( thenStmt, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, notBranch ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^560^^^^^554^563^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenStmt )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( result == Token.HOOK ) ;^548^^^^^533^563^Preconditions.checkState ( type == Token.HOOK ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( type >= Token.HOOK ) ;^548^^^^^533^563^Preconditions.checkState ( type == Token.HOOK ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isExpressionNode ( notBranch )  )  {^549^^^^^534^564^if  ( NodeUtil.isExpressionNode ( parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenStmt )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( secondBranch.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond.removeChild ( thenStmt ) ;^556^^^^^541^571^cond.removeChild ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^565^^^^^550^580^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( parent )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( notCond, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, secondBranch ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( !NodeUtil.mayHaveSideEffects ( notBranch )  )  {^571^^^^^556^586^} else if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^576^^^^^561^591^n.removeChild ( thenBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, notBranch ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parent != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( elseBody != thenStmtull && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( n != elseBodyull && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( elseBody != null || !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( elseBody == null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^changes = false;^517^^^^^502^532^changes = true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^514^^^^^499^529^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( parent )  && elseBody != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && secondBranch != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != thenStmtull )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && n != elseBodyull )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( elseBodyhenBody )  && t != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  || elseBody != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond = parent;^527^^^^^512^542^cond = notCond;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^thenBody = thenStmt.getNext (  ) ;^528^^^^^513^543^thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^changes = false;^531^^^^^516^546^changes = true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^522^^^^^507^537^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( thenStmt, elseBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( thenBody, parent ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( cond, secondBranchotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( cond, thenStmt ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( cond, notCondotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( notCond, cond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( cond, n ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^notCond.addChildToFront ( thenStmt ) ;^526^^^^^511^541^notCond.addChildToFront ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^thenBody = secondBranch.getNext (  ) ;^528^^^^^513^543^thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( notCond )  && elseBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && thenBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == notCondull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && n == elseBodyull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( nhenBody )  && elseBody == tull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  || elseBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( thenStmt )  )  {^536^^^^^521^551^if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, thenBody ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^538^^^^^523^553^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( secondBranch, NodeUtil.newExpr ( cond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( cond, NodeUtil.newExpr ( n )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( notBranch )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return false;^545^^^^^530^560^return true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^538^^^^^523^553^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notCond, NodeUtil.newExpr ( cond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( parent )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( thenStmt, n ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, thenStmt ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( notBranch )  )  {^536^^^^^521^551^if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( notCond, n ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, notBranch ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond = not;^527^^^^^512^542^cond = notCond;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( notCond != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^514^^^^^499^529^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( notCond )  && elseBody != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^522^^^^^507^537^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( notBranch, elseBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( elseBody, thenBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( cond, thenStmtotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( cond, parent ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( n, condotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^notCond.addChildToFront ( notBranch ) ;^526^^^^^511^541^notCond.addChildToFront ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^thenBody = notBranch.getNext (  ) ;^528^^^^^513^543^thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenStmt )  && elseBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^538^^^^^523^553^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notBranch, NodeUtil.newExpr ( cond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( notCond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( secondBranch )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( notBranch, n ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( elseBody != notCondull && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^514^^^^^499^529^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( not )  && elseBody != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != parentull )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^522^^^^^507^537^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( thenBody, thenStmt ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( not )  && elseBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && notCond == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  && thenBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( n )  && elseBody == thenBodyull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( elseBodyhenBody )  && t == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( notBranch, n ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^538^^^^^523^553^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^538^^^^^523^553^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( thenBody )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( secondBranch )  )  {^536^^^^^521^551^if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, thenStmt ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, NodeUtil.newExpr ( thenStmt )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( secondBranch )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^574^^^^^559^589^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node ifNode = new Node ( Token.null ) ;^573^^^^^558^588^Node ifNode = new Node ( Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^574^^^^^559^589^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  > Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( parent ) ;^561^^^^^554^563^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( secondBranch ) ;^562^^^^^554^563^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = parent.getFirstChild (  ) ;^555^^^^^540^570^Node expr = cond.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( secondBranch ) ;^557^^^^^542^572^ifNode.addChildToBack ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenBody ) ;^557^^^^^542^572^ifNode.addChildToBack ( expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^560^^^^^545^575^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( secondBranch ) ;^562^^^^^547^577^ifNode.addChildToBack ( not ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( notBranch )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^560^^^^^554^563^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( thenBody ) ;^575^^^^^560^590^ifNode.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( not )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^not.addChildToBack ( thenBody ) ;^561^^^^^546^576^not.addChildToBack ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^565^^^^^550^580^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenStmt )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( parent, thenStmt ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( secondBranch ) ;^576^^^^^561^591^n.removeChild ( thenBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.mayHaveSideEffects ( thenBodyhenBody )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenStmt )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBody.getType (  )  == Token.NOT )  {^554^^^^^539^569^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.getParent (  ) .replaceChild ( thenBody, ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^cond = notBranch;^527^^^^^512^542^cond = notCond;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^thenBody = parent.getNext (  ) ;^528^^^^^513^543^thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^514^^^^^499^529^n.removeChild ( elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( parent, notCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^notCond.addChildToFront ( parent ) ;^526^^^^^511^541^notCond.addChildToFront ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^thenBody = notCond.getNext (  ) ;^528^^^^^513^543^thenBody = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( notCond )  )  {^536^^^^^521^551^if  ( NodeUtil.mayHaveSideEffects ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, NodeUtil.newExpr ( cond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( thenBody, n ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, notCond ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( type > Token.HOOK ) ;^548^^^^^533^563^Preconditions.checkState ( type == Token.HOOK ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isExpressionNode ( thenBody )  )  {^549^^^^^534^564^if  ( NodeUtil.isExpressionNode ( parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  )  {^588^^^^^573^603^if  ( !NodeUtil.isLiteralValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^return condTrue;^589^^^^^574^604^return changes;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( notBranch )  )  {^588^^^^^573^603^if  ( !NodeUtil.isLiteralValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean notCondTrue = NodeUtil.getBooleanValue ( cond ) ;^592^^^^^577^607^boolean condTrue = NodeUtil.getBooleanValue ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean thenStmtTrue = NodeUtil.getBooleanValue ( cond ) ;^592^^^^^577^607^boolean condTrue = NodeUtil.getBooleanValue ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parent.getChildCount (  )  == 2 )  {^594^^^^^579^609^if  ( n.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( n.getChildCount (  )  != 2 )  {^594^^^^^579^609^if  ( n.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^if  ( n.getChildCount (  )  == AND_PRECEDENCE )  {^594^^^^^579^609^if  ( n.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node firstBranch = thenStmt.getFirstChild (  ) .getNext (  ) ;^612^^^^^594^620^Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node secondBranch = thenStmt.getNext (  ) ;^613^^^^^594^620^Node secondBranch = firstBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = changes ? firstBranch : secondBranch;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = condTrue ? notCond : secondBranch;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = condTrue ? firstBranch : notBranch;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node branch = secondBranch ? firstBranch : condTrue;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node branch = condTrue ? secondBranch : firstBranch;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = changes ? secondBranch : firstBranch;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = condTrue ? thenStmt : firstBranch;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = condTrue ? secondBranch : thenBody;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node notBranch = firstBranch ? secondBranch : condTrue;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node notBranch = condTrue ? firstBranch : secondBranch;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node firstBranch = thenBody.getFirstChild (  ) .getNext (  ) ;^612^^^^^594^620^Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node secondBranch = parent.getNext (  ) ;^613^^^^^594^620^Node secondBranch = firstBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( thenBody ) ;^616^^^^^594^620^NodeUtil.redeclareVarsInsideBranch ( notBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^617^^^^^594^620^n.removeChild ( branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notCond, branch ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenBody ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( branch, n ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( changes )  {^597^^^^^582^612^if  ( condTrue )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( thenBody, n ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenStmt = parent.getFirstChild (  ) .getNext (  ) ;^599^^^^^584^614^Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenStmt = secondBranch.getFirstChild (  ) .getNext (  ) ;^599^^^^^584^614^Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenBody ) ;^600^^^^^585^615^n.removeChild ( thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notBranch, thenStmt ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenBody ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenStmt = thenBody.getFirstChild (  ) .getNext (  ) ;^599^^^^^584^614^Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( result == Token.IF ) ;^595^^^^^580^610^Preconditions.checkState ( type == Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( type != Token.IF ) ;^595^^^^^580^610^Preconditions.checkState ( type == Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenStmt = thenStmt.getFirstChild (  ) .getNext (  ) ;^599^^^^^584^614^Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenStmt = notBranch.getFirstChild (  ) .getNext (  ) ;^599^^^^^584^614^Node thenStmt = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( notCond ) ;^600^^^^^585^615^n.removeChild ( thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notCond, thenStmt ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, not ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( thenStmt, n ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( notCond, n ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, notBranch ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( parent ) ;^605^^^^^597^608^NodeUtil.redeclareVarsInsideBranch ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( thenStmt, n ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, notCond ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( secondBranch, thenStmt ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, notCond ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node firstBranch = notCond.getFirstChild (  ) .getNext (  ) ;^612^^^^^597^627^Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node secondBranch = notCond.getNext (  ) ;^613^^^^^598^628^Node secondBranch = firstBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = changes ? firstBranch : secondBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = condTrue ? thenBody : secondBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node branch = condTrue ? firstBranch : notBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node branch = firstBranch ? condTrue : secondBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node branch = condTrue ? secondBranch : firstBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = changes ? secondBranch : firstBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = condTrue ? not : firstBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node notBranch = condTrue ? secondBranch : notCond;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node notBranch = secondBranch ? condTrue : firstBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node notBranch = condTrue ? firstBranch : secondBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( secondBranch.getChildCount (  )  == 2 )  {^594^^^^^579^609^if  ( n.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( newType == Token.IF ) ;^595^^^^^580^610^Preconditions.checkState ( type == Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( notCond ) ;^605^^^^^590^620^NodeUtil.redeclareVarsInsideBranch ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node firstBranch = thenStmt.getFirstChild (  ) .getNext (  ) ;^612^^^^^597^627^Node firstBranch = n.getFirstChild (  ) .getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( thenBody ) ;^616^^^^^601^631^NodeUtil.redeclareVarsInsideBranch ( notBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenStmt ) ;^617^^^^^602^632^n.removeChild ( branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notBranch, branch ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, notBranch ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( branch, n ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return false;^621^^^^^606^636^return true;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node parentotChild = n.getFirstChild (  ) ;^628^^^^^627^653^Node notChild = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return true;^646^^^^^627^653^return false;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^switch  ( parent.getType (  )  )  {^631^^^^^627^653^switch  ( notChild.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node parentewOperator = n.removeFirstChild (  ) ;^648^^^^^627^653^Node newOperator = n.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^newOperator.setType ( type ) ;^649^^^^^627^653^newOperator.setType ( complementOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( notChild, newOperator ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, notChild ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newOperator, n ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return false;^652^^^^^627^653^return true;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node cond = name2.getFirstChild (  ) ;^659^^^^^644^674^Node cond = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node cond = maybeName2.getFirstChild (  ) ;^659^^^^^644^674^Node cond = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenBranch = returnNode.getNext (  ) ;^660^^^^^645^675^Node thenBranch = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenBranch = n.getNext (  ) ;^660^^^^^645^675^Node thenBranch = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseBranch = n.getNext (  ) ;^661^^^^^646^676^Node elseBranch = thenBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2 == null )  {^663^^^^^648^678^if  ( elseBranch == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( elseBranch == name1ull )  {^663^^^^^648^678^if  ( elseBranch == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( elseBranch != null )  {^663^^^^^648^678^if  ( elseBranch == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isExpressBlock ( name1 )  )  {^664^^^^^649^679^if  ( isExpressBlock ( thenBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isPropertyAssignmentInExpression ( t, newExpr )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isPropertyAssignmentInExpression ( expr, t )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1.getType (  )  == Token.NOT )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  != Token.NOT )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, thenExpr, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, name2.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, type )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( expr, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( t, expr, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, cond.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( t, OR_PRECEDENCE, cond )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, name1.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , name2.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node or = new Node ( Token.OR, expr.removeFirstChild (  ) , cond.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( name1 ) ;^683^^^^^668^698^Node newExpr = NodeUtil.newExpr ( or ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, returnNode, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( cond, t, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( OR_PRECEDENCE, cond, t )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, n.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , newType )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( expr, t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( t, OR_PRECEDENCE.getFirstChild (  ) , expr )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, newExpr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, thenAssign.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( maybeName2 ) ;^683^^^^^668^698^Node newExpr = NodeUtil.newExpr ( or ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, newExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newExpr, n ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, name1.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, result )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, newExpr, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, or.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, newType )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( expr, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( t, expr, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, cond.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( AND_PRECEDENCE, cond, t )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, or.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , n.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, name1, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, name1.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node and = new Node ( Token.AND, expr, cond.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, n.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, name2.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( parent ) ;^700^^^^^685^715^Node newExpr = NodeUtil.newExpr ( and ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = getBlockExpression ( newExpr ) ;^665^^^^^650^680^Node expr = getBlockExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isPropertyAssignmentInExpression ( t, n )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.NOT )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, parent, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, or.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , type )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( OR_PRECEDENCE, expr.getFirstChild (  ) , t )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( n ) ;^683^^^^^668^698^Node newExpr = NodeUtil.newExpr ( or ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenAssign, newExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, parent, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, type )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( cond, t, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( t, AND_PRECEDENCE, cond )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, name1.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , type )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( AND_PRECEDENCE, expr.getFirstChild (  ) , t )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( expr, t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^isLowerPrecedenceInExpression ( t, AND_PRECEDENCE.getFirstChild (  ) , expr )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, var.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name2 ) ;^698^^^^^683^713^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, parent.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( name1 ) ;^700^^^^^685^715^Node newExpr = NodeUtil.newExpr ( and ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, newExpr ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, or ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newExpr, n ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isPropertyAssignmentInExpression ( t, name2 )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, returnNode.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( isLowerPrecedenceInExpression ( t, cond, expr )  && isLowerPrecedenceInExpression ( t, OR_PRECEDENCE.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, parent.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , name1.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, name1, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, name2.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( name2 ) ;^683^^^^^668^698^Node newExpr = NodeUtil.newExpr ( or ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( var, newExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, n, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, n.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, name2, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, name2.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , or.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = getBlockExpression ( returnNode ) ;^665^^^^^650^680^Node expr = getBlockExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, parent, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( n ) ;^700^^^^^685^715^Node newExpr = NodeUtil.newExpr ( and ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isExpressBlock ( maybeName2 )  )  {^664^^^^^649^679^if  ( isExpressBlock ( thenBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = getBlockExpression ( maybeName2 ) ;^665^^^^^650^680^Node expr = getBlockExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.getType (  )  == Token.NOT )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, newExpr, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, thenAssign.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, newExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name2 ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, name1, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, result )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, or.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenOp ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isExpressBlock ( n )  )  {^664^^^^^649^679^if  ( isExpressBlock ( thenBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isPropertyAssignmentInExpression ( t, thenAssign )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  >= Token.NOT )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, or, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, newExpr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , parent.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, name1.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, thenBranch, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, n.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = getBlockExpression ( name2 ) ;^665^^^^^650^680^Node expr = getBlockExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, returnNode.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, name2, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isPropertyAssignmentInExpression ( t, name1 )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, name2.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, n.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , result )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, returnNode.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( thenExpr ) ;^700^^^^^685^715^Node newExpr = NodeUtil.newExpr ( and ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( or, newExpr ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, maybeName2 ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( cond.getType (  )  == Token.2 )  {^672^^^^^657^687^if  ( cond.getType (  )  == Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, thenExpr.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, name1.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , result )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, returnNode.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( thenExpr ) ;^683^^^^^668^698^Node newExpr = NodeUtil.newExpr ( or ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isLowerPrecedenceInExpression ( t, cond, newType )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, newExpr.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , var.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , newExpr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, newExpr, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node and = new Node ( Token.AND, cond, or.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node newExpr = NodeUtil.newExpr ( or ) ;^700^^^^^685^715^Node newExpr = NodeUtil.newExpr ( and ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, thenExpr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, maybeName2 ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^isLowerPrecedenceInExpression ( t, newExpr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( or ) ;^698^^^^^683^713^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^tryRemoveRepeatedStatements ( t, maybeName2 ) ;^708^^^^^693^723^tryRemoveRepeatedStatements ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^tryRemoveRepeatedStatements ( n, t ) ;^708^^^^^693^723^tryRemoveRepeatedStatements ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenAssign.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( elseBranch.getType (  )  == Token.NOT && !consumesDanglingElse ( cond )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  == Token.NOT || !consumesDanglingElse ( elseBranch )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( cond.getType (  )  != Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( thenAssign, cond.removeFirstChild (  )  ) ;^713^^^^^698^728^n.replaceChild ( cond, cond.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( name1, cond.removeFirstChild (  )  ) ;^713^^^^^698^728^n.replaceChild ( cond, cond.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( newExpr ) ;^714^^^^^699^729^n.removeChild ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.addChildToBack ( name1 ) ;^715^^^^^700^730^n.addChildToBack ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( newExpr.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( name2 )  )  {^712^^^^^697^727^if  ( cond.getType (  )  == Token.NOT && !consumesDanglingElse ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenOp ) ;^714^^^^^699^729^n.removeChild ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.addChildToBack ( or ) ;^715^^^^^700^730^n.addChildToBack ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( name1 )  )  {^721^^^^^706^736^if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( isReturnExpressBlock ( thenBranch )  || isReturnExpressBlock ( elseBranch )  )  {^721^^^^^706^736^if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, newExpr, thenExpr, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node returnNode = new Node ( Token.RETURN, name1 ) ;^732^^^^^717^747^Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = getBlockReturnExpression ( maybeName2 ) ;^722^^^^^707^737^Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = getBlockReturnExpression ( newExpr ) ;^723^^^^^708^738^Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, newExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = getBlockReturnExpression ( n ) ;^722^^^^^707^737^Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = getBlockReturnExpression ( n ) ;^723^^^^^708^738^Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, var ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, or, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node returnNode = new Node ( Token.RETURN, n ) ;^732^^^^^717^747^Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = getBlockReturnExpression ( parent ) ;^723^^^^^708^738^Node elseExpr = getBlockReturnExpression ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node returnNode = new Node ( Token.RETURN, parent ) ;^732^^^^^717^747^Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( isReturnExpressBlock ( name1 )  && isReturnExpressBlock ( elseBranch )  )  {^721^^^^^706^736^if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = getBlockReturnExpression ( thenAssign ) ;^722^^^^^707^737^Node thenExpr = getBlockReturnExpression ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( newExpr ) ;^724^^^^^709^739^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, returnNode ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( returnNode, n ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean thenExprIsExpressionBlock = isExpressBlock ( thenBranch ) ;^738^^^^^723^753^boolean thenBranchIsExpressionBlock = isExpressBlock ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean maybeName2IsExpressionBlock = isExpressBlock ( thenBranch ) ;^738^^^^^723^753^boolean thenBranchIsExpressionBlock = isExpressBlock ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean nIsExpressionBlock = isExpressBlock ( elseBranch ) ;^739^^^^^724^754^boolean elseBranchIsExpressionBlock = isExpressBlock ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsVar && elseBranchIsExpressionBlock )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsExpressionBlock && thenBranchIsVar )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1IsExpressionBlock && elseBranchIsExpressionBlock )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsExpressionBlock && returnNodeIsExpressionBlock )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( thenBranchIsExpressionBlock || elseBranchIsExpressionBlock )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.getType (  )  == elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenOp.getType (  )  == name1.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( thenOp.getType (  )  <= elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( name1 )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( name1 )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, n ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenOp, cond, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseOp, thenOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, name1 ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name2 ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenExpr ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name1 ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenBranch ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( expr, n ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, or ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseOp, thenOp, cond ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name1, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( thenExpr )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name2 ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( newExpr.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( name1.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  ||^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , n, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( assignName.getType (  ) , thenOp, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( thenOp.getType (  ) , hookNode, assignName ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = n.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name1.getLastChild (  ) ;^758^^^^^748^768^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, parent, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( name2.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , thenAssign, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, newExpr ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( hookNode.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name2 ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name1 ) ;^755^^^^^748^768^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = maybeName2.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( name1 ) ;^759^^^^^748^768^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenAssign.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( newExpr, expr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name2 ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( expr, n ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenAssign, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, returnNode ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( name1.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , n, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, name1 ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( assignName.getType (  ) , thenOp, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( thenOp.getType (  ) , hookNode, assignName ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node assign = new Node ( hookNode.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = n.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = name1.removeFirstChild (  ) ;^756^^^^^741^771^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name1.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, returnNode, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , name2, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( parent ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = name2.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( name2.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( elseOp.checkTreeEqualsSilent ( lhs.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^!NodeUtil.mayEffectMutableState ( n )  )  {^753^^^^^738^768^!NodeUtil.mayEffectMutableState ( lhs )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenAssign ) ;^755^^^^^740^770^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.removeFirstChild (  ) ;^757^^^^^742^772^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( newExpr ) ;^759^^^^^744^774^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name1 ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( or, expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( returnNode.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( returnNode.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenAssign ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , name1, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, name2 ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = newExpr.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = parent.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name1, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, newExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( parent.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, var ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name1 ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = var.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = or.getLastChild (  ) ;^758^^^^^748^768^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( name1.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( or, expr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( n )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, newExpr, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( n ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( or, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, n ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( n.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , name1, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, parent, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, parent ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = n.removeFirstChild (  ) ;^756^^^^^741^771^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name2.removeFirstChild (  ) ;^757^^^^^742^772^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = thenAssign.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, thenAssign, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, or ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( maybeName2 )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( or.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^!NodeUtil.mayEffectMutableState ( name1 )  )  {^753^^^^^738^768^!NodeUtil.mayEffectMutableState ( lhs )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name2 ) ;^755^^^^^740^770^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.removeFirstChild (  ) ;^757^^^^^742^772^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = n.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( name1 ) ;^759^^^^^744^774^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( n ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenAssign, expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, n ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( newExpr ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenAssign, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, n ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( or )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( or )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, name2 ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, newExpr ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name1 ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( maybeName2 )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( thenAssign ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( var, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, returnNode ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( parent.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( n.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = thenExpr.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, or ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , parent, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, name1 ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name2 ) ;^755^^^^^748^768^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = name1.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name1.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( name2 ) ;^759^^^^^748^768^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( maybeName2.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( var ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, newExpr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, parent, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, parent ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = newExpr.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name1, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, or, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, or ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( name2.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , thenBranch, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, newExpr ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( thenOp ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = maybeName2.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( newExpr.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^!NodeUtil.mayEffectMutableState ( name2 )  )  {^753^^^^^738^768^!NodeUtil.mayEffectMutableState ( lhs )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( or ) ;^755^^^^^740^770^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( maybeName2.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( name2 ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, newExpr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( expr, n ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , name2, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = or.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.getLastChild (  ) ;^758^^^^^748^768^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, newExpr, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenAssign, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( or.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, returnNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^755^^^^^748^768^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = thenAssign.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( or ) ;^759^^^^^748^768^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( or ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( returnNode, expr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name2, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, n, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, n, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, thenExpr ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenOp = getBlockExpression ( n ) .getFirstChild (  ) ;^742^^^^^727^757^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseOp = getBlockExpression ( parent ) .getFirstChild (  ) ;^743^^^^^728^758^Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = parent.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = or.removeFirstChild (  ) ;^756^^^^^741^771^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( var.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , thenAssign, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( or ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenOp = getBlockExpression ( thenOp ) .getFirstChild (  ) ;^742^^^^^727^757^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseOp = getBlockExpression ( n ) .getFirstChild (  ) ;^743^^^^^728^758^Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenOp.getType (  )  == or.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( n.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name2 ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name2 ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1.getType (  )  == elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenOp.getType (  )  == thenBranch.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( thenOp.getType (  )  >= elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( newExpr )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isCall ( name2 )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( parent ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenExpr, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenExpr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenOp, thenAssign ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( thenOp ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( returnNode ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, n, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( returnNode.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , or, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name2.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, returnNode, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenBranch.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , newExpr, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( returnNode ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = var.removeFirstChild (  ) ;^757^^^^^748^768^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenBranch, expr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, n ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , var, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, thenExpr ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = thenBranch.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name2.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , or, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, name2 ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( var ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( name1 ) ;^755^^^^^740^770^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = newExpr.removeFirstChild (  ) ;^756^^^^^741^771^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( name2 ) ;^759^^^^^744^774^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lhs.checkTreeEqualsSilent ( thenAssign.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenBranch ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( or ) ;^755^^^^^748^768^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, var, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( or ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( parent.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , returnNode, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, returnNode, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = returnNode.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , newExpr, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenBranch, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^!NodeUtil.mayEffectMutableState ( thenExpr )  )  {^753^^^^^738^768^!NodeUtil.mayEffectMutableState ( lhs )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = maybeName2.removeFirstChild (  ) ;^756^^^^^741^771^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name1.removeFirstChild (  ) ;^757^^^^^742^772^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( newExpr, expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenOp, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( n )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( NodeUtil.isAssignmentOp ( thenOphenOp )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( thenAssign ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( newExpr, expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, thenOp ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( or.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, n ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( newExpr.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = thenAssign.getLastChild (  ) ;^758^^^^^748^768^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assignName = name2.removeFirstChild (  ) ;^756^^^^^748^768^Node assignName = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( n ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenAssign ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenBranch.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, n ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( thenBranch ) ;^765^^^^^750^780^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^!NodeUtil.mayEffectMutableState ( or )  )  {^753^^^^^738^768^!NodeUtil.mayEffectMutableState ( lhs )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = newExpr.removeFirstChild (  ) ;^757^^^^^742^772^Node thenExpr = thenOp.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = parent.getLastChild (  ) ;^758^^^^^743^773^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( var ) ;^759^^^^^744^774^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenExpr.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, maybeName2, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name2.getLastChild (  ) ;^758^^^^^748^768^Node elseExpr = elseOp.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, thenBranch, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , assignName, parent ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( newExpr ) ;^755^^^^^748^768^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( newExpr ) ;^759^^^^^748^768^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( newExpr ) ;^765^^^^^748^768^Node expr = NodeUtil.newExpr ( assign ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^} else if  ( NodeUtil.isCall ( thenOphenOp )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, or, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node expr = NodeUtil.newExpr ( returnNode ) ;^775^^^^^760^790^Node expr = NodeUtil.newExpr ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, or ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, maybeName2, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, parent ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenOp = getBlockExpression ( maybeName2 ) .getFirstChild (  ) ;^742^^^^^727^757^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseOp = getBlockExpression ( name2 ) .getFirstChild (  ) ;^743^^^^^728^758^Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = thenAssign.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( newExpr.getType (  ) , assignName, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node assign = new Node ( thenOp.getType (  ) , thenOp, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenOp = getBlockExpression ( name2 ) .getFirstChild (  ) ;^742^^^^^727^757^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenOp = getBlockExpression ( name1 ) .getFirstChild (  ) ;^742^^^^^727^757^Node thenOp = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseOp = getBlockExpression ( name1 ) .getFirstChild (  ) ;^743^^^^^728^758^Node elseOp = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( or.getType (  )  == elseOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenOp.getType (  )  == name2.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isAssignmentOp ( thenBranch )  )  {^746^^^^^731^761^if  ( NodeUtil.isAssignmentOp ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lhs = name1.getFirstChild (  ) ;^747^^^^^732^762^Node lhs = thenOp.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( newExpr ) ;^755^^^^^740^770^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^elseOp.removeChild ( returnNode ) ;^759^^^^^744^774^elseOp.removeChild ( elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( or ) ;^771^^^^^756^786^n.removeChild ( cond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean name2IsVar = isVarBlock ( thenBranch ) ;^783^^^^^768^798^boolean thenBranchIsVar = isVarBlock ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean orIsVar = isVarBlock ( thenBranch ) ;^783^^^^^768^798^boolean thenBranchIsVar = isVarBlock ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean name1IsVar = isVarBlock ( elseBranch ) ;^784^^^^^769^799^boolean elseBranchIsVar = isVarBlock ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^boolean nIsVar = isVarBlock ( elseBranch ) ;^784^^^^^769^799^boolean elseBranchIsVar = isVarBlock ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsVar && thenBranchIsVar && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsVar && newExprIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( maybeName2IsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssigname1 ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( elseBranchIsExpressionBlockIsVar && thenBranch && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( elseBranchIsExpressionBlockhenBranchIsVar && t && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( thenBranchIsVar || elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( thenBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( elseBranchIsVar && thenBranchIsVar && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( elseBranchIsVar && nIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( orIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^} else if  ( elseBranchIsVar || thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( maybeName2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2ame2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( maybeName1ame2.hasChildren (  ) && n.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  != Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name1, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, var, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, or ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = newExpr.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.removeChildren (  ) ;^823^^^^^810^831^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, parent, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, parent, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name1.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( name1 ) ;^827^^^^^810^831^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( var, var ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, newExpr ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( var, n ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, thenBranch, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( or ) ;^813^^^^^810^831^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( maybeName2 ) .getFirstChild (  ) ;^814^^^^^810^831^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = newExpr.getFirstChild (  ) ;^816^^^^^810^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name2 = maybeName2.getFirstChild (  ) ;^817^^^^^810^831^Node name2 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, newExpr, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( name1 ) ;^813^^^^^810^831^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( n ) .getFirstChild (  ) ;^814^^^^^810^831^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( newExpr ) .getFirstChild (  ) ;^814^^^^^810^831^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = or.getFirstChild (  ) ;^816^^^^^810^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name2 = name1.getFirstChild (  ) ;^817^^^^^810^831^Node name2 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( newExpr.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& name1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^820^821^^^^810^831^&& maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& maybeName1.getString (  ) .equals ( n.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^&& name2.getString (  ) .equals ( maybeName1.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& name1.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& maybeName1.getString (  ) .equals ( name1.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^810^831^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = maybeName2.removeChildren (  ) ;^823^^^^^810^831^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( n ) ;^827^^^^^810^831^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( or, var ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( maybeName2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.hasChildren (  ) && or.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1ame2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( maybeName1.hasChildren (  ) && name2.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name2.hasChildren (  ) || maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  <= Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, n ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = newExpr.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.removeChildren (  ) ;^823^^^^^819^830^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, newExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = maybeName2.removeChildren (  ) ;^823^^^^^819^830^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( newExpr ) ;^827^^^^^819^830^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenOp, var ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( var, n ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, returnNode, thenExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( parent ) ;^813^^^^^798^828^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( n ) .getFirstChild (  ) ;^814^^^^^799^829^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = name2.getFirstChild (  ) ;^816^^^^^801^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name2 = maybeName2.getFirstChild (  ) ;^817^^^^^802^832^Node name2 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^807^837^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = returnNode.removeChildren (  ) ;^823^^^^^808^838^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( maybeName2 ) .getFirstChild (  )  )  )  {^811^^^^^796^826^NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( name1 ) .getFirstChild (  )  )  )  {^811^^^^^796^826^NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( newExpr ) ;^813^^^^^798^828^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( maybeName2 ) .getFirstChild (  ) ;^814^^^^^799^829^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = newExpr.getFirstChild (  ) ;^816^^^^^801^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( newExpr.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& thenOp.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& maybeName1.getString (  ) .equals ( newExpr.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^&& name2.getString (  ) .equals ( maybeName1.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.removeChildren (  ) ;^823^^^^^808^838^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( n ) ;^827^^^^^812^842^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, var ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name2 ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( maybeName2.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1.hasChildren (  ) && newExpr.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( orame1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( maybeName2ame1.hasChildren (  ) && n.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name1.hasChildren (  ) || maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  != Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenOp ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.removeChildren (  ) ;^799^^^^^796^807^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, newExpr, thenExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name2 ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.removeChildren (  ) ;^799^^^^^796^807^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = n.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenOp, var ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name1 ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( var, n ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( n ) ;^790^^^^^775^805^Node var = getBlockVar ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseAssign = getBlockExpression ( thenOp ) .getFirstChild (  ) ;^791^^^^^776^806^Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name1 = maybeName2.getFirstChild (  ) ;^793^^^^^778^808^Node name1 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName2 = name2.getFirstChild (  ) ;^794^^^^^779^809^Node maybeName2 = elseAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = n.removeChildren (  ) ;^799^^^^^784^814^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name1.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^785^815^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, thenExpr, thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( name1 ) ;^790^^^^^775^805^Node var = getBlockVar ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseAssign = getBlockExpression ( newExpr ) .getFirstChild (  ) ;^791^^^^^776^806^Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseAssign = getBlockExpression ( name1 ) .getFirstChild (  ) ;^791^^^^^776^806^Node elseAssign = getBlockExpression ( elseBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name1 = thenAssign.getFirstChild (  ) ;^793^^^^^778^808^Node name1 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& parent.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^797^798^^^^782^812^&& maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& returnNode.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& name1.getString (  ) .equals ( n.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^&& maybeName2.getString (  ) .equals ( name1.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& thenAssign.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& name1.getString (  ) .equals ( name2.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.removeChildren (  ) ;^799^^^^^784^814^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = n.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^785^815^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = parent.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^785^815^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name1.addChildrenToBack ( newExpr ) ;^804^^^^^789^819^name1.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( thenExpr, var ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, n ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( var, n ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( or.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name1.hasChildren (  ) && parent.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  > Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^796^797^798^^^781^811^if  ( name1.hasChildren (  ) && maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name2.removeChildren (  ) ;^799^^^^^796^807^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = newExpr.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = var.removeChildren (  ) ;^799^^^^^796^807^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name1.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^796^807^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name1.addChildrenToBack ( returnNode ) ;^804^^^^^796^807^name1.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, var ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, maybeName2 ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( elseBranchIsVar && maybeName2IsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssignewExpr ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^} else if  ( thenBranchIsExpressionBlock && elseBranchIsVar && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( thenBranch.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.hasChildren (  ) && n.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parentame2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, returnNode, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, n ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = parent.removeChildren (  ) ;^823^^^^^810^831^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name1.removeChildren (  ) ;^823^^^^^810^831^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, var ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, returnNode, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, n, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( n ) ;^813^^^^^810^831^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = n.getFirstChild (  ) ;^816^^^^^810^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name2 = or.getFirstChild (  ) ;^817^^^^^810^831^Node name2 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& name2.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^820^821^^^^810^831^&& maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& or.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& n.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( returnNode ) ;^827^^^^^810^831^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, or ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( name2.hasChildren (  ) && name1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( maybeName2ame2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  != Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, n, thenExpr, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, newExpr, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, name1 ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = or.removeChildren (  ) ;^823^^^^^819^830^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, thenExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = parent.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^819^830^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^name2.addChildrenToBack ( n ) ;^827^^^^^819^830^name2.addChildrenToBack ( hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, var ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, maybeName2 ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, name2, thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, newExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, or, thenExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name1, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name1 = newExpr.getFirstChild (  ) ;^793^^^^^778^808^Node name1 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = name2.removeChildren (  ) ;^799^^^^^784^814^Node thenExpr = name1.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = or.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^785^815^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, parent, thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, name2, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, var ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( n ) ;^813^^^^^798^828^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( newExpr ) .getFirstChild (  ) ;^814^^^^^799^829^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = returnNode.getFirstChild (  ) ;^816^^^^^801^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node name2 = thenExpr.getFirstChild (  ) ;^817^^^^^802^832^Node name2 = var.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = maybeName2.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^807^837^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = n.removeChildren (  ) ;^823^^^^^808^838^Node elseExpr = name2.removeChildren (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, newExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( name1 ) .getFirstChild (  )  )  )  {^788^^^^^773^803^NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( newExpr ) .getFirstChild (  )  )  )  {^788^^^^^773^803^NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( or ) .getFirstChild (  )  )  )  {^788^^^^^773^803^NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( maybeName2 ) ;^790^^^^^775^805^Node var = getBlockVar ( thenBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName2 = n.getFirstChild (  ) ;^794^^^^^779^809^Node maybeName2 = elseAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& n.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^797^798^^^^782^812^&& maybeName2.getType (  )  == Token.NAME && name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& maybeName2.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node elseExpr = name2.getLastChild (  ) .detachFromParent (  ) ;^800^^^^^785^815^Node elseExpr = elseAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( maybeName2, var ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^NodeUtil.isAssign ( getBlockExpression ( thenOp ) .getFirstChild (  )  )  )  {^811^^^^^796^826^NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node var = getBlockVar ( name1 ) ;^813^^^^^798^828^Node var = getBlockVar ( elseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenAssign = getBlockExpression ( thenOp ) .getFirstChild (  ) ;^814^^^^^799^829^Node thenAssign = getBlockExpression ( thenBranch ) .getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node maybeName1 = thenOp.getFirstChild (  ) ;^816^^^^^801^831^Node maybeName1 = thenAssign.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& n.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^820^821^^^^805^835^&& maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& thenBranch.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^&& newExpr.getString (  ) .equals ( name2.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node thenExpr = newExpr.getLastChild (  ) .detachFromParent (  ) ;^822^^^^^807^837^Node thenExpr = thenAssign.getLastChild (  ) .detachFromParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( name1, var ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, maybeName2 ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( lastTrue.getType (  )  == Token.IF ) ;^857^^^^^856^884^Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( n.getType (  )  <= Token.IF ) ;^857^^^^^856^884^Preconditions.checkState ( n.getType (  )  == Token.IF ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node parent = trueBranch.getParent (  ) ;^859^^^^^856^884^Node parent = n.getParent (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isStatementBlock ( lastTrue )  )  {^860^^^^^856^884^if  ( !NodeUtil.isStatementBlock ( parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node cond = lastTrue.getFirstChild (  ) ;^866^^^^^856^884^Node cond = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node trueBranch = parent.getNext (  ) ;^867^^^^^856^884^Node trueBranch = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node trueBranch = trueBranch.getNext (  ) ;^867^^^^^856^884^Node trueBranch = cond.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node falseBranch = parent.getNext (  ) ;^868^^^^^856^884^Node falseBranch = trueBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node falseBranch = n.getNext (  ) ;^868^^^^^856^884^Node falseBranch = trueBranch.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( n ) ;^869^^^^^856^884^Preconditions.checkNotNull ( trueBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( parent ) ;^870^^^^^856^884^Preconditions.checkNotNull ( falseBranch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^while  ( false )  {^872^^^^^856^884^while  ( true )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( trueBranch == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lastTrue == null || trueBranch == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( lastFalse == null || lastTrue == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( lastTrue == null && lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( lastTrue != null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( lastTrue == null || lastFalse != null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lastTrue = parent.getLastChild (  ) ;^873^^^^^856^884^Node lastTrue = trueBranch.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lastFalse = trueBranch.getLastChild (  ) ;^874^^^^^856^884^Node lastFalse = falseBranch.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lastTrue = n.getLastChild (  ) ;^873^^^^^856^884^Node lastTrue = trueBranch.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.addChildAfter ( trueBranch, n ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.addChildAfter ( lastTrue, parent ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^parent.addChildAfter ( n, lastTrue ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( parent == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( lastTrue == null || parent == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node lastFalse = n.getLastChild (  ) ;^874^^^^^856^884^Node lastFalse = falseBranch.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^|| !lastTrue.checkTreeEqualsSilent ( trueBranch )  )  {^876^^^^^856^884^|| !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^parent.addChildAfter ( lastTrue, trueBranch ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node result = operand.getFirstChild (  ) ;^890^^^^^889^909^Node result = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node result = result.getFirstChild (  ) ;^890^^^^^889^909^Node result = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( n != null )  {^891^^^^^889^909^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( result != resultull )  {^891^^^^^889^909^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( n != resultull )  {^891^^^^^889^909^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^if  ( result == null )  {^891^^^^^889^909^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^895^^^^^889^909^if  ( !NodeUtil.mayHaveSideEffects ( operand )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^if  ( resultame.equals ( "undefined" )  )  {^902^^^^^889^909^if  ( name.equals ( "undefined" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( n.equals ( "undefined" )  )  {^902^^^^^889^909^if  ( name.equals ( "undefined" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^if  ( nameame.equals ( "undefined" )  )  {^902^^^^^889^909^if  ( name.equals ( "undefined" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node operand = n.getFirstChild (  ) ;^894^^^^^889^909^Node operand = result.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^switch  ( operand.getType (  )  )  {^892^^^^^889^909^switch  ( result.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^Node operand = operand.getFirstChild (  ) ;^894^^^^^889^909^Node operand = result.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^String name = operand.getString (  ) ;^901^^^^^889^909^String name = result.getString (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^final boolean[] found = { true };^915^^^^^914^923^final boolean[] found = { false };^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.null ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  == Token.GETPROP || parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  != Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^found[AND_PRECEDENCE] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^new NodeTraversal ( n.getCompiler (  ) , tew AbstractShallowCallback (  )  {^916^^^^^914^923^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^new NodeTraversal ( t.getCompiler (  ) , parentew AbstractShallowCallback (  )  {^916^^^^^914^923^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^return found[intVal];^922^^^^^914^923^return found[0];^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Argument_Swapping]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  == Token.GETPROP || parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  >= Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  != Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^found[complementOperator] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Variable_Misuse]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[BugLab_Wrong_Literal]^final boolean[] lower = { true };^931^^^^^929^938^final boolean[] lower = { false };^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^lower[0] |= NodeUtil.precedence ( parent.getType (  )  )  < precedence;^934^^^^^929^938^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < type;^934^^^^^929^938^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Argument_Swapping]^lower[0] |= NodeUtil.precedence ( precedence.getType (  )  )  < n;^934^^^^^929^938^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Wrong_Operator]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  == precedence;^934^^^^^929^938^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Wrong_Literal]^lower[newType] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^934^^^^^929^938^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^new NodeTraversal ( t.getCompiler (  ) , parentew AbstractShallowCallback (  )  {^932^^^^^929^938^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Argument_Swapping]^new NodeTraversal ( n.getCompiler (  ) , tew AbstractShallowCallback (  )  {^932^^^^^929^938^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^lower[0] |= NodeUtil.precedence ( parent.getType (  )  )  < precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < newType;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Wrong_Operator]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  <= precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Wrong_Literal]^lower[newType] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[BugLab_Variable_Misuse]^int type = right.getType (  ) ;^947^^^^^932^962^int type = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^int type = result.getType (  ) ;^947^^^^^932^962^int type = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( right )  )  {^948^^^^^933^963^if  ( NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isLiteralValue ( result )  )  {^962^^^^^947^977^} else if  ( NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( newType == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( right )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == right )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( parent == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( pt )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF && pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt != Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt >= Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt <= Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR || NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt > Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  >= n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  < n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( result == Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( type == Token.OR && !rval || type == Token.AND && lval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( rval == Token.OR && !rval || type == Token.AND && type )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type == Token.OR && !rval && type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type == Token.OR || !rval || type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type != Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^972^990^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = parent;^987^^^^^972^990^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^987^^^^^972^990^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = right;^981^^^^^972^990^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^972^990^boolean rval = NodeUtil.getBooleanValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( result == Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( type == Token.OR && !rval || type == Token.AND && lval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type == Token.OR && !rval && type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type == Token.OR || !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type != Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^979^989^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^987^^^^^979^989^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( right )  )  {^986^^^^^979^989^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^981^^^^^979^989^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( result )  )  {^986^^^^^971^1001^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = parent;^987^^^^^972^1002^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^981^^^^^966^996^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^int pt = right.getType (  ) ;^971^^^^^956^986^int pt = parent.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^boolean rval = NodeUtil.getBooleanValue ( parent ) ;^975^^^^^960^990^boolean rval = NodeUtil.getBooleanValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^( pt == Token.FOR && NodeUtil.getConditionExpression ( result )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^973^974^^^^958^988^( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^( pt == Token.HOOK && right.getFirstChild (  )  == n )  )  {^974^^^^^959^989^( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( right )  )  {^986^^^^^971^1001^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( type == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.IF || pt == Token.this || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( n == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == pt )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt < Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  != n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  <= n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.mayHaveSideEffects ( right )  )  {^986^^^^^972^990^if  ( !NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^981^^^^^972^990^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^boolean rval = NodeUtil.getBooleanValue ( parent ) ;^975^^^^^972^990^boolean rval = NodeUtil.getBooleanValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type <= Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = right;^981^^^^^979^989^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^987^^^^^972^1002^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = right;^981^^^^^966^996^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^boolean rval = NodeUtil.getBooleanValue ( result ) ;^975^^^^^960^990^boolean rval = NodeUtil.getBooleanValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^( pt == Token.FOR && NodeUtil.getConditionExpression ( right )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^973^974^^^^958^988^( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( rval && type == Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( lval && result == Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lval && type == Token.OR && !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lval || type == Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lval && type != Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lval && type <= Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = right;^955^^^^^953^961^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = right;^955^^^^^940^970^result = left;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^960^^^^^945^975^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^boolean lval = NodeUtil.getBooleanValue ( right ) ;^949^^^^^934^964^boolean lval = NodeUtil.getBooleanValue ( left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( type && lval == Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result;^960^^^^^953^961^result = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^} else if  ( NodeUtil.isLiteralValue ( parent )  )  {^962^^^^^947^977^} else if  ( NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == result )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  != n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type > Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( result == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( result )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( n )  == parent )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type >= Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type <= Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^972^990^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( pt == Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( type >= Token.OR && !rval || type == Token.AND && rval )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( result )  )  {^948^^^^^933^963^if  ( NodeUtil.isLiteralValue ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^( pt == Token.HOOK && result.getFirstChild (  )  == n )  )  {^974^^^^^959^989^( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( right != null )  {^997^^^^^982^1012^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( n != resultull )  {^997^^^^^982^1012^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( result == null )  {^997^^^^^982^1012^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^n.removeChild ( right ) ;^999^^^^^984^1014^n.removeChild ( result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, result ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( result, n ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( parent )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( right )  && right.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( NodeUtil.isLiteralValue ( left )  && right.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( NodeUtil.isLiteralValue ( right )  || left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  <= Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  != 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Literal]^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 1 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  != Token.STRING ) return;^1030^1031^^^^1018^1043^if  ( lr.getType (  )  != Token.STRING ) return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lr.getType (  )  > Token.STRING ) return;^1030^1031^^^^1018^1043^if  ( lr.getType (  )  != Token.STRING ) return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( rightString != null && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != null && leftString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != nuright && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != rightull && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( rightString != null && leftString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( leftString != rightull && nString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString != null || rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString == null && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString != null && rightString == null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String result = rightString + rightString;^1037^^^^^1018^1043^String result = leftString + rightString;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String result = leftString + leftString;^1037^^^^^1018^1043^String result = leftString + rightString;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^String result = rightString + leftString;^1037^^^^^1018^1043^String result = leftString + rightString;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^left.removeChild ( right ) ;^1036^^^^^1018^1043^left.removeChild ( ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( right, ll ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( right, Node.newString ( rightString )  ) ;^1039^^^^^1018^1043^n.replaceChild ( right, Node.newString ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^Node ll = right.getFirstChild (  ) ;^1024^^^^^1018^1043^Node ll = left.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^Node lr = right.getNext (  ) ;^1025^^^^^1018^1043^Node lr = ll.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String leftString = NodeUtil.getStringValue ( right ) ;^1033^^^^^1018^1043^String leftString = NodeUtil.getStringValue ( lr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^Node lr = parent.getNext (  ) ;^1025^^^^^1018^1043^Node lr = ll.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String nString = NodeUtil.getStringValue ( right ) ;^1034^^^^^1018^1043^String rightString = NodeUtil.getStringValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( left, right ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( ll, left ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^n.replaceChild ( parent, Node.newString ( result )  ) ;^1039^^^^^1018^1043^n.replaceChild ( right, Node.newString ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^n.replaceChild ( result, Node.newString ( right )  ) ;^1039^^^^^1018^1043^n.replaceChild ( right, Node.newString ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  != Token.STRING ) return;^1030^1031^^^^1018^1043^if  ( lr.getType (  )  != Token.STRING ) return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( lr.getType (  )  < Token.STRING ) return;^1030^1031^^^^1018^1043^if  ( lr.getType (  )  != Token.STRING ) return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != nuparent && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != null && parentString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^left.getType (  )  == Token.ADD && right.getChildCount (  )  == 2 )  {^1021^1022^^^^1018^1043^left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String parentString = NodeUtil.getStringValue ( right ) ;^1034^^^^^1018^1043^String rightString = NodeUtil.getStringValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( left.getType (  )  == Token.STRING || parent.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  == Token.STRING && right.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  <= Token.STRING || right.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  >= Token.STRING || right.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, right, left, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, parent, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, parent, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, n, left, right, right ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( right, n, left, t, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, parent, left, right, n ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, left, n, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, n, right, left, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( t, n, left, parent, right ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != rightull && rightString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( rightString != null && leftString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( leftString != rightStringull && n != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString != null || rightString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString == null && rightString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( leftString != null && rightString == null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newString ( leftString + rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( n, Node.newString ( rightString + leftString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( rightString, Node.newString ( leftString + n )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^parent.replaceChild ( n, Node.newString ( leftString  &  rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^parent.replaceChild ( n, Node.newString ( leftString  >>  rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String rightString = NodeUtil.getStringValue ( left ) ;^1054^^^^^1048^1064^String leftString = NodeUtil.getStringValue ( left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String parentString = NodeUtil.getStringValue ( right ) ;^1055^^^^^1048^1064^String rightString = NodeUtil.getStringValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newString ( leftString + leftString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^parent.replaceChild ( n, Node.newString ( leftString  |  rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( leftString != null && leftString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^parent.replaceChild ( n, Node.newString ( leftString  <  rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^parent.replaceChild ( n, Node.newString ( leftString  >  rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^tryFoldArithmetic ( t, parent, left, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^tryFoldArithmetic ( left, n, t, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( left.getType (  )  == Token.NUMBER && parent.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  <= Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  != Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( result == 0 )  {^1089^^^^^1074^1104^if  ( rval == 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( rval <= 0 )  {^1089^^^^^1074^1104^if  ( rval == 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Literal]^if  ( rval == 1 )  {^1089^^^^^1074^1104^if  ( rval == 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^error ( t, DIVIDE_BY_0_ERROR, parent ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^error ( right, DIVIDE_BY_0_ERROR, t ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^error ( DIVIDE_BY_0_ERROR, t, right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( String.valueOf ( rval ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( result ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( result ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( String.valueOf ( rval ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( result ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( rval ) .length (  )  + String.valueOf ( lval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( String.valueOf ( result ) .length (  )  == String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  &&  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if   instanceof   ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Literal]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )   )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( result )  ) ;^1102^^^^^1100^1104^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1102^^^^^1100^1104^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result + rval;^1080^^^^^1065^1095^result = lval + rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = lval + result;^1080^^^^^1065^1095^result = lval + rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^result = rval + lval;^1080^^^^^1065^1095^result = lval + rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result - rval;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = lval - result;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^result = rval - lval;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^result = lval  >  rval;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result * rval;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = lval * result;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^result = rval * lval;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^result / = lval * rval;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = result / rval;^1093^^^^^1078^1108^result = lval / rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^result = lval / result;^1093^^^^^1078^1108^result = lval / rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^result = rval / lval;^1093^^^^^1078^1108^result = lval / rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^result = lval - rval;^1093^^^^^1078^1108^result = lval / rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^double lval = right.getDouble (  ) ;^1075^^^^^1060^1090^double lval = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^double rval = parent.getDouble (  ) ;^1076^^^^^1061^1091^double rval = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^switch  ( right.getType (  )  )  {^1078^^^^^1063^1093^switch  ( n.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^error ( t, right, DIVIDE_BY_0_ERROR ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String.valueOf ( rval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1101^^^^^1086^1116^String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^String.valueOf ( lval ) .length (  )  + String.valueOf ( result ) .length (  )  + 1 )  {^1101^^^^^1086^1116^String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( result )  ) ;^1102^^^^^1087^1117^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1102^^^^^1087^1117^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1102^^^^^1087^1117^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ( rval != 0 )  {^1089^^^^^1074^1104^if  ( rval == 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( rval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^if  ( String.valueOf ( lval ) .length (  )  <= String.valueOf ( result ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  ||  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^if  <  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1102^^^^^1100^1104^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^result = lval  ==  rval;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Wrong_Operator]^result - = lval * rval;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1099^1129^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( left.getType (  )  == Token.NUMBER && parent.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1099^1129^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1099^1129^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  != Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1099^1129^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  <= Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1114^1115^^^^1099^1129^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( rval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || result < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( lval < Integer.MIN_VALUE || lval > Integer.newType || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( rval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || lval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lval < Integer.MIN_VALUE && lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lval <= Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lval < Integer.MIN_VALUE || lval >= Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lval > Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( rvalInt != lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( lval != lvalInt )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( lvalIntInt != lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lvalInt == lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( newType != rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( resultInt != rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( rval != rvalInt )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( rvalIntInt != rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( rvalInt < rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = pt & rvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt & precedence;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^result = rvalInt & lvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  ^  rvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = type | rvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt | precedence;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^result = rvalInt | lvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result  >=  = lvalInt | rvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^double lval = right.getDouble (  ) ;^1117^^^^^1102^1132^double lval = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^double rval = parent.getDouble (  ) ;^1118^^^^^1103^1133^double rval = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^switch  ( right.getType (  )  )  {^1140^^^^^1125^1155^switch  ( n.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( result )  ) ;^1150^^^^^1135^1165^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1150^^^^^1135^1165^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1150^^^^^1135^1165^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( result < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( lval < Integer.precedence || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( lval < Integer.MIN_VALUE || lval > Integer.type || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lval == Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( pt != lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lvalInt >= lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( result != rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( rvalInt <= rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = precedence & rvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt   instanceof   rvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = result | rvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt | type;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result  &  = lvalInt | rvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1146^1176^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  == Token.NUMBER || right.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1146^1176^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  <= Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1146^1176^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  != Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1146^1176^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( ! ( rval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.precedence )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( lval >= Integer.MIN_VALUE || lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( lval > Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( lval >= Integer.MIN_VALUE && lval < Integer.MAX_VALUE )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, right ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( ! ( result >= 0 && rval < 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( rval >= 0 || rval < 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( rval > 0 && rval < 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( rval >= 0 && rval <= 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Literal]^if  ( ! ( rval >= newType && rval < 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Literal]^if  ( ! ( rval >= 0 && rval < 31 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, parent ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( right, SHIFT_AMOUNT_OUT_OF_BOUNDS, t ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( t, right, SHIFT_AMOUNT_OUT_OF_BOUNDS ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( result != lval )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( rvalInt != lval )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( lval != lvalInt )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( lvalInt == lval )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( pt != rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( resultInt != rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( rval != rvalInt )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( rvalInt == rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, FRACTIONAL_BITWISE_OPERAND, parent ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( FRACTIONAL_BITWISE_OPERAND, t, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( t, right, FRACTIONAL_BITWISE_OPERAND ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = type << rvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt << result;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^result = rvalInt << lvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  |  rvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = pt >> rvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt >> type;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^result = rvalInt >> lvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  <  rvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = precedence >>> rvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = lvalInt >>> pt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^result = rvalInt >>> lvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  <<  rvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^throw rightew AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^1206^1207^^^^1191^1221^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  |  )  )  ) ;^1206^1207^^^^1191^1221^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^double lval = right.getDouble (  ) ;^1165^^^^^1150^1180^double lval = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^double rval = parent.getDouble (  ) ;^1166^^^^^1151^1181^double rval = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  >>  )  )  ) ;^1206^1207^^^^1191^1221^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_GETELEM_INDEX_ERROR, right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( SHIFT_AMOUNT_OUT_OF_BOUNDS, t, right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( right, FRACTIONAL_BITWISE_OPERAND, t ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^switch  ( right.getType (  )  )  {^1195^^^^^1180^1210^switch  ( n.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^Node.tokenToName ( right.getType (  )  )  ) ;^1207^^^^^1192^1222^Node.tokenToName ( n.getType (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, Node.newNumber ( result )  ) ;^1209^^^^^1194^1224^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, Node.newNumber ( rval )  ) ;^1209^^^^^1194^1224^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.result )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( lval >= Integer.MIN_VALUE && lval > Integer.MAX_VALUE )  )  {^1170^^^^^1155^1185^if  ( ! ( lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^if  ( ! ( rval < 0 && rval < 32 )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Literal]^if  ( ! ( rval >= 0 && rval < complementOperator )  )  {^1177^^^^^1162^1192^if  ( ! ( rval >= 0 && rval < 32 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( precedence != lval )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( lvalIntInt != lval )  {^1184^^^^^1169^1199^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^if  ( type != rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Argument_Swapping]^if  ( rvalIntInt != rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = result << rvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  >=  rvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = precedence >> rvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  ^  rvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^result = pt >>> rvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^result = lvalInt  &  rvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Wrong_Operator]^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  ==  )  )  ) ;^1206^1207^^^^1191^1221^throw new AssertionError ( "Unknown shift operator: " + Node.tokenToName ( n.getType (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[BugLab_Variable_Misuse]^int op = right.getType (  ) ;^1221^^^^^1206^1236^int op = n.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean parentLiteral = NodeUtil.isLiteralValue ( right ) ;^1226^^^^^1211^1241^boolean rightLiteral = NodeUtil.isLiteralValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean undefinedRight =  (  ( Token.NAME == parent.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1227^1228^1229^1230^^1212^1242^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) &&  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1227^1228^1229^1230^^1212^1242^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) || right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1227^1228^1229^1230^^1212^1242^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean undefinedRight =  (  ( Token.NAME != right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1227^1228^1229^1230^^1212^1242^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID <= right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1227^1228^1229^1230^^1212^1242^boolean undefinedRight =  (  ( Token.NAME == right.getType (  ) && right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& parent.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1228^1229^1230^^^1213^1243^&& right.getString (  ) .equals ( "undefined" )  ) ||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^||  ( Token.VOID == parent.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^1229^1230^^^^1214^1244^||  ( Token.VOID == right.getType (  ) && NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isLiteralValue ( parent.getFirstChild (  )  )  )  ) ;^1230^^^^^1215^1245^&& NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( right.getFirstChild (  )  )  )  {^1234^^^^^1219^1249^if  ( !NodeUtil.isLiteralValue ( left.getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^} else if  ( !undefinedRight )  {^1236^^^^^1221^1251^} else if  ( !rightLiteral )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedRight;^1244^^^^^1236^1264^result = equivalent;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedLeft;^1250^^^^^1236^1264^result = undefinedRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1259^^^^^1236^1264^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean nullRight =  ( Token.NULL == parent.getType (  )  ) ;^1239^^^^^1236^1264^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean nullRight =  ( Token.this == right.getType (  )  ) ;^1239^^^^^1236^1264^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1239^^^^^1236^1264^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean equivalent = undefinedLeft || nullRight;^1240^^^^^1236^1264^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean equivalent = undefinedRight || undefinedRight;^1240^^^^^1236^1264^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^boolean equivalent = nullRight || undefinedRight;^1240^^^^^1236^1264^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean equivalent = undefinedRight && nullRight;^1240^^^^^1236^1264^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedLeft;^1244^^^^^1229^1259^result = equivalent;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = rightLiteral;^1250^^^^^1235^1265^result = undefinedRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1259^^^^^1244^1274^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean nullRight =  ( Token.NULL == parent.getType (  )  ) ;^1239^^^^^1224^1254^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1239^^^^^1224^1254^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean equivalent = undefinedLeft || nullRight;^1240^^^^^1225^1255^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^boolean equivalent = nullRight || undefinedRight;^1240^^^^^1225^1255^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean equivalent = undefinedRight && nullRight;^1240^^^^^1225^1255^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = rightLiteral;^1250^^^^^1236^1264^result = undefinedRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedLeft )  {^1268^^^^^1253^1283^if  ( undefinedRight )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result =  ( precedence == Token.EQ ) ;^1269^^^^^1254^1284^result =  ( op == Token.EQ ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^result =  ( op <= Token.EQ ) ;^1269^^^^^1254^1284^result =  ( op == Token.EQ ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedLeft )  {^1275^^^^^1260^1290^if  ( undefinedRight )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1276^^^^^1261^1291^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( precedence != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^1282^1283^1284^1285^^1267^1297^if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( tt != Token.THIS || tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^1282^1283^1284^1285^^1267^1297^if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( tt >= Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^1282^1283^1284^1285^^1267^1297^if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( tt == Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^1282^1283^1284^1285^^1267^1297^if  ( tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedLeft )  {^1302^^^^^1287^1317^if  ( undefinedRight )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1303^^^^^1288^1318^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( Token.STRING != parent.getType (  )  )  {^1306^^^^^1291^1321^if  ( Token.STRING != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( Token.null != right.getType (  )  )  {^1306^^^^^1291^1321^if  ( Token.STRING != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( Token.STRING == right.getType (  )  )  {^1306^^^^^1291^1321^if  ( Token.STRING != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedLeft )  {^1324^^^^^1309^1339^if  ( undefinedRight )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1325^^^^^1310^1340^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( Token.NUMBER != parent.getType (  )  )  {^1328^^^^^1313^1343^if  ( Token.NUMBER != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( Token.NUMBER >= right.getType (  )  )  {^1328^^^^^1313^1343^if  ( Token.NUMBER != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedRight )  {^1347^^^^^1332^1362^if  ( rightLiteral )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parentLiteral )  {^1347^^^^^1332^1362^if  ( rightLiteral )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( undefinedRight )  {^1349^^^^^1334^1364^if  ( undefinedLeft )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedRight;^1355^^^^^1340^1370^result = equivalent;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedLeft;^1361^^^^^1346^1376^result = undefinedRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1370^^^^^1355^1385^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean nullRight =  ( Token.NULL == parent.getType (  )  ) ;^1350^^^^^1335^1365^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean nullRight =  ( Token.NULL != right.getType (  )  ) ;^1350^^^^^1335^1365^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean equivalent = undefinedLeft || nullRight;^1351^^^^^1336^1366^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean equivalent = undefinedRight || undefinedRight;^1351^^^^^1336^1366^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^boolean equivalent = nullRight || undefinedRight;^1351^^^^^1336^1366^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^boolean equivalent = undefinedRight && nullRight;^1351^^^^^1336^1366^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedLeft;^1355^^^^^1340^1370^result = equivalent;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean undefinedLeft =  ( right.getString (  ) .equals ( "undefined" )  ) ;^1348^^^^^1333^1363^boolean undefinedLeft =  ( left.getString (  ) .equals ( "undefined" )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( Token.NAME != parent.getType (  )  )  {^1379^^^^^1364^1394^if  ( Token.NAME != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( Token.NAME <= right.getType (  )  )  {^1379^^^^^1364^1394^if  ( Token.NAME != right.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = undefinedRight;^1244^^^^^1229^1259^result = equivalent;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result =  ( pt == Token.EQ ) ;^1269^^^^^1254^1284^result =  ( op == Token.EQ ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^result =  ( op > Token.EQ ) ;^1269^^^^^1254^1284^result =  ( op == Token.EQ ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = parent.getType (  )  == right.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = left.getType (  )  == parent.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^result = right.getType (  )  == left.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^result = left.getType (  )  != right.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = parent.getType (  )  != right.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = left.getType (  )  != parent.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^result = right.getType (  )  != left.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^result = left.getType (  )  < right.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = parent.getString (  ) .equals ( right.getString (  )  ) ;^1311^^^^^1296^1326^result = left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = left.getString (  ) .equals ( parent.getString (  )  ) ;^1311^^^^^1296^1326^result = left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^result = right.getString (  ) .equals ( left.getString (  )  ) ;^1311^^^^^1296^1326^result = left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = !left.getString (  ) .equals ( parent.getString (  )  ) ;^1315^^^^^1300^1330^result = !left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.EQ: result = rv == lv; break;^1335^^^^^1320^1350^case Token.EQ: result = lv == rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.EQ: result = lv != rv; break;^1335^^^^^1320^1350^case Token.EQ: result = lv == rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.NE: result = rv != lv; break;^1336^^^^^1321^1351^case Token.NE: result = lv != rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.NE: result = lv >= rv; break;^1336^^^^^1321^1351^case Token.NE: result = lv != rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.LE: result = rv <= lv; break;^1337^^^^^1322^1352^case Token.LE: result = lv <= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.LE: result = lv < rv; break;^1337^^^^^1322^1352^case Token.LE: result = lv <= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.LT: result = rv <  lv; break;^1338^^^^^1323^1353^case Token.LT: result = lv <  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.LT: result = lv <=  rv; break;^1338^^^^^1323^1353^case Token.LT: result = lv <  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.GE: result = rv >= lv; break;^1339^^^^^1324^1354^case Token.GE: result = lv >= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.GE: result = lv > rv; break;^1339^^^^^1324^1354^case Token.GE: result = lv >= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^case Token.GT: result = rv >  lv; break;^1340^^^^^1325^1355^case Token.GT: result = lv >  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^case Token.GT: result = lv >=  rv; break;^1340^^^^^1325^1355^case Token.GT: result = lv >  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^result = true;^1393^^^^^1378^1408^result = false;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int tt = parent.getType (  ) ;^1281^^^^^1266^1296^int tt = right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^double lv = right.getDouble (  ) ;^1331^^^^^1316^1346^double lv = left.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^double rv = parent.getDouble (  ) ;^1332^^^^^1317^1347^double rv = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean nullRight =  ( Token.2 == right.getType (  )  ) ;^1350^^^^^1335^1365^boolean nullRight =  ( Token.NULL == right.getType (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String ln = right.getString (  ) ;^1382^^^^^1367^1397^String ln = left.getString (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( right.getType (  )  )  {^1232^^^^^1217^1247^switch  ( left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = right.getType (  )  == right.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = right.getType (  )  != right.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^result = right.getString (  ) .equals ( right.getString (  )  ) ;^1311^^^^^1296^1326^result = left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String rn = parent.getString (  ) ;^1383^^^^^1368^1398^String rn = right.getString (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( undefinedLeft ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1390^1420^parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1390^1420^parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( result ? Token.null : Token.FALSE )  ) ;^1405^1406^^^^1390^1420^parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( newNode )  || !NodeUtil.isImmutableValue ( right )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( secondArg )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.isGetProp ( right )  || !NodeUtil.isImmutableValue ( left )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isGetProp ( left )  && !NodeUtil.isImmutableValue ( right )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( secondArg )  || !NodeUtil.isImmutableValue ( right )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( parent )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node functionName = parent.getNext (  ) ;^1422^^^^^1407^1437^Node functionName = lstringNode.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( parent.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1409^1439^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( lstringNode.getType (  )  != Token.STRING )  && ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1409^1439^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( lstringNode.getType (  )  >= Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1409^1439^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  || !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1409^1439^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( newNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^1424^1425^1426^^^1409^1439^if  (  ( lstringNode.getType (  )  != Token.STRING )  || ( !functionName.getString (  ) .equals ( "indexOf" )  && !functionName.getString (  ) .equals ( "lastIndexOf" )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String lstring = NodeUtil.getStringValue ( right ) ;^1430^^^^^1415^1445^String lstring = NodeUtil.getStringValue ( lstringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String lstring = NodeUtil.getStringValue ( secondArg ) ;^1430^^^^^1415^1445^String lstring = NodeUtil.getStringValue ( lstringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean isIndexOf = right.getString (  ) .equals ( "indexOf" ) ;^1431^^^^^1416^1446^boolean isIndexOf = functionName.getString (  ) .equals ( "indexOf" ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean isIndexOf = newNode.getString (  ) .equals ( "indexOf" ) ;^1431^^^^^1416^1446^boolean isIndexOf = functionName.getString (  ) .equals ( "indexOf" ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node firstArg = newNode;^1432^^^^^1417^1447^Node firstArg = right;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node secondArg = parent.getNext (  ) ;^1433^^^^^1418^1448^Node secondArg = right.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node secondArg = secondArg.getNext (  ) ;^1433^^^^^1418^1448^Node secondArg = right.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String searchValue = NodeUtil.getStringValue ( secondArg ) ;^1434^^^^^1419^1449^String searchValue = NodeUtil.getStringValue ( firstArg ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String searchValue = NodeUtil.getStringValue ( parent ) ;^1434^^^^^1419^1449^String searchValue = NodeUtil.getStringValue ( firstArg ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( lstring == null )  {^1436^^^^^1421^1451^if  ( searchValue == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( searchValue != null )  {^1436^^^^^1421^1451^if  ( searchValue == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int fromIndex = isIndexOf ? 0 : searchValue.length (  ) ;^1439^^^^^1424^1454^int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^int fromIndex = lstring ? 0 : isIndexOf.length (  ) ;^1439^^^^^1424^1454^int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int fromIndex = isIndexOf ? -1 : lstring.length (  ) ;^1439^^^^^1424^1454^int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( right != null )  {^1440^^^^^1425^1455^if  ( secondArg != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( secondArg == null )  {^1440^^^^^1425^1455^if  ( secondArg != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( newNode.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1427^1457^if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( secondArg.getNext (  )  != null )  && ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1427^1457^if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( secondArg.getNext (  )  == null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1427^1457^if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^fromIndex =  ( int )  right.getDouble (  ) ;^1446^^^^^1442^1447^fromIndex =  ( int )  secondArg.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^fromIndex =  ( int )  newNode.getDouble (  ) ;^1446^^^^^1442^1447^fromIndex =  ( int )  secondArg.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^fromIndex =  ( int )  newNode.getDouble (  ) ;^1446^^^^^1431^1461^fromIndex =  ( int )  secondArg.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( right.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^1442^1443^^^^1427^1457^if  (  ( secondArg.getNext (  )  != null )  || ( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^( n.getType (  )  != Token.NUMBER )  )  {^1443^^^^^1428^1458^( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^fromIndex =  ( int )  n.getDouble (  ) ;^1446^^^^^1431^1461^fromIndex =  ( int )  secondArg.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^fromIndex =  ( int )  parent.getDouble (  ) ;^1446^^^^^1442^1447^fromIndex =  ( int )  secondArg.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^( parent.getType (  )  != Token.NUMBER )  )  {^1443^^^^^1428^1458^( secondArg.getType (  )  != Token.NUMBER )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int indexVal = isIndexOf ? searchValue.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int indexVal = isIndexOf ? lstring.indexOf ( lstring, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, precedence ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^int indexVal = lstring ? isIndexOf.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^int indexVal = isIndexOf ? searchValue.indexOf ( lstring, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^int indexVal = isIndexOf ? fromIndex.indexOf ( searchValue, lstring ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^int indexVal = isIndexOf ? lstring.indexOf ( fromIndex, searchValue ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^: lstring.lastIndexOf ( searchValue, pt ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^: searchValue.lastIndexOf ( lstring, fromIndex ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^: lstring.lastIndexOf ( fromIndex, searchValue ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newNode = Node.newNumber ( type ) ;^1451^^^^^1436^1466^Node newNode = Node.newNumber ( indexVal ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newNode = Node.newNumber ( rvalInt ) ;^1451^^^^^1436^1466^Node newNode = Node.newNumber ( indexVal ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, newNode ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newNode, n ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( parent )  || !NodeUtil.isImmutableValue ( right )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( n )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( !NodeUtil.isGetProp ( right )  || !NodeUtil.isImmutableValue ( left )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isGetProp ( left )  && !NodeUtil.isImmutableValue ( right )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( node )  || !NodeUtil.isImmutableValue ( right )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( replacement )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node arrayNode = parent.getFirstChild (  ) ;^1467^^^^^1452^1482^Node arrayNode = left.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node functionName = right.getNext (  ) ;^1468^^^^^1453^1483^Node functionName = arrayNode.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node functionName = replacement.getNext (  ) ;^1468^^^^^1453^1483^Node functionName = arrayNode.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( n.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^1470^1471^^^^1455^1485^if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  && !functionName.getString (  ) .equals ( "join" )  )  {^1470^1471^^^^1455^1485^if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  (  ( arrayNode.getType (  )  <= Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^1470^1471^^^^1455^1485^if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  (  ( right.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^1470^1471^^^^1455^1485^if  (  ( arrayNode.getType (  )  != Token.ARRAYLIT )  || !functionName.getString (  ) .equals ( "join" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String joinString = NodeUtil.getStringValue ( n ) ;^1475^^^^^1460^1490^String joinString = NodeUtil.getStringValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String joinString = NodeUtil.getStringValue ( replacement ) ;^1475^^^^^1460^1490^String joinString = NodeUtil.getStringValue ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node elem = replacement.getFirstChild (  ) ;^1479^^^^^1464^1494^Node elem = arrayNode.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node elem = n.getFirstChild (  ) ;^1479^^^^^1464^1494^Node elem = arrayNode.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( node != null )  {^1481^^^^^1466^1496^while  ( elem != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( elem == null )  {^1481^^^^^1466^1496^while  ( elem != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isImmutableValue ( right )  )  {^1482^^^^^1467^1497^if  ( NodeUtil.isImmutableValue ( elem )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( sb.length (  )  < 0 )  {^1488^^^^^1482^1496^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( sb.length (  )  > originalSize )  {^1488^^^^^1482^1496^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  !=  )  + 2;^1490^^^^^1482^1496^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  ;^1490^^^^^1482^1496^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  <<  )  + 2;^1490^^^^^1482^1496^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( right ) ;^1494^^^^^1482^1496^foldedSize += InlineCostEstimator.getCost ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( n ) ;^1494^^^^^1482^1496^foldedSize += InlineCostEstimator.getCost ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^arrayFoldedChildren.add ( right ) ;^1495^^^^^1482^1496^arrayFoldedChildren.add ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( sb.length (  )  >= 0 )  {^1483^^^^^1468^1498^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( sb.length (  )  > -1 )  {^1483^^^^^1468^1498^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( NodeUtil.getStringValue ( replacement )  ) ;^1486^^^^^1471^1501^sb.append ( NodeUtil.getStringValue ( elem )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( NodeUtil.getStringValue ( right )  ) ;^1486^^^^^1471^1501^sb.append ( NodeUtil.getStringValue ( elem )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( sb.length (  )  > fromIndex )  {^1483^^^^^1468^1498^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( sb.length (  )  >= 0 )  {^1488^^^^^1473^1503^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( sb.length (  )  > type )  {^1488^^^^^1473^1503^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  <=  )  + 2;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  + complementOperator;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  >  )  + 2;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  + foldedSize;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( replacement ) ;^1494^^^^^1479^1509^foldedSize += InlineCostEstimator.getCost ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^elem = n.getNext (  ) ;^1497^^^^^1482^1512^elem = elem.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( NodeUtil.getStringValue ( n )  ) ;^1486^^^^^1471^1501^sb.append ( NodeUtil.getStringValue ( elem )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^arrayFoldedChildren.add ( right ) ;^1495^^^^^1480^1510^arrayFoldedChildren.add ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isImmutableValue ( n )  )  {^1482^^^^^1467^1497^if  ( NodeUtil.isImmutableValue ( elem )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  <=  )  + 2;^1490^^^^^1482^1496^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  &  )  + 2;^1490^^^^^1482^1496^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( node ) ;^1494^^^^^1482^1496^foldedSize += InlineCostEstimator.getCost ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^arrayFoldedChildren.add ( n ) ;^1495^^^^^1482^1496^arrayFoldedChildren.add ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( sb.length (  )  < 0 )  {^1483^^^^^1468^1498^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  <  )  + 2;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  ;^1490^^^^^1475^1505^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isImmutableValue ( node )  )  {^1482^^^^^1467^1497^if  ( NodeUtil.isImmutableValue ( elem )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( NodeUtil.getStringValue ( node )  ) ;^1486^^^^^1471^1501^sb.append ( NodeUtil.getStringValue ( elem )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( right ) ;^1494^^^^^1479^1509^foldedSize += InlineCostEstimator.getCost ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^arrayFoldedChildren.add ( n ) ;^1495^^^^^1480^1510^arrayFoldedChildren.add ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^elem = right.getNext (  ) ;^1497^^^^^1482^1512^elem = elem.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( sb.length (  )  >= 0 )  {^1500^^^^^1485^1515^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( sb.length (  )  >  )  {^1500^^^^^1485^1515^if  ( sb.length (  )  > 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  &  )  + 2;^1502^^^^^1487^1517^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  ;^1502^^^^^1487^1517^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += sb.length (  <  )  + 2;^1502^^^^^1487^1517^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += sb.length (  )  + complementOperator;^1502^^^^^1487^1517^foldedSize += sb.length (  )  + 2;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += null.size (  )  - 1;^1506^^^^^1491^1521^foldedSize += arrayFoldedChildren.size (  )  - 1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^foldedSize += arrayFoldedChildren.size (  )    instanceof   1;^1506^^^^^1491^1521^foldedSize += arrayFoldedChildren.size (  )  - 1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^foldedSize += arrayFoldedChildren.size (  )  ;^1506^^^^^1491^1521^foldedSize += arrayFoldedChildren.size (  )  - 1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int originalSize = InlineCostEstimator.getCost ( left ) ;^1508^^^^^1493^1523^int originalSize = InlineCostEstimator.getCost ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( precedence > originalSize )  {^1517^^^^^1502^1532^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( foldedSize > precedence )  {^1517^^^^^1502^1532^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( originalSize > foldedSize )  {^1517^^^^^1502^1532^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( foldedSize >= originalSize )  {^1517^^^^^1502^1532^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  != Token.STRING )  {^1521^^^^^1506^1536^if  ( foldedStringNode.getType (  )  != Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( foldedStringNode.getType (  )  == Token.STRING )  {^1521^^^^^1506^1536^if  ( foldedStringNode.getType (  )  != Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedStringNode = parent;^1526^^^^^1511^1541^foldedStringNode = replacement;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , parent ) ;^1524^1525^^^^1509^1539^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( this.size (  )  == arrayNode.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( arrayFoldedChildren.size (  )  == replacement.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( arrayNode.size (  )  == arrayFoldedChildren.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( arrayFoldedChildren.size (  )  != arrayNode.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( pt > originalSize )  {^1539^^^^^1524^1554^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( foldedSize > op )  {^1539^^^^^1524^1554^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( originalSize > foldedSize )  {^1539^^^^^1524^1554^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( foldedSize >= originalSize )  {^1539^^^^^1524^1554^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( node ) ;^1538^^^^^1523^1553^foldedSize += InlineCostEstimator.getCost ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , node ) ;^1524^1525^^^^1509^1539^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^Node foldedStringNode = arrayFoldedChildren.remove ( indexVal ) ;^1516^^^^^1501^1531^Node foldedStringNode = arrayFoldedChildren.remove ( 0 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( node, emptyStringNode ) ;^1512^^^^^1497^1527^parent.replaceChild ( n, emptyStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, node ) ;^1512^^^^^1497^1527^parent.replaceChild ( n, emptyStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( emptyStringNode, n ) ;^1512^^^^^1497^1527^parent.replaceChild ( n, emptyStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^Node foldedStringNode = arrayFoldedChildren.remove ( 1 ) ;^1516^^^^^1501^1531^Node foldedStringNode = arrayFoldedChildren.remove ( 0 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( replacement.getType (  )  != Token.STRING )  {^1521^^^^^1506^1536^if  ( foldedStringNode.getType (  )  != Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, foldedStringNode ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, node ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( foldedStringNode, n ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( arrayFoldedChildren.size (  )  == parent.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^foldedSize += InlineCostEstimator.getCost ( replacement ) ;^1538^^^^^1523^1553^foldedSize += InlineCostEstimator.getCost ( right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^arrayNode.addChildToBack ( n ) ;^1544^^^^^1529^1559^arrayNode.addChildToBack ( node ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  == Token.ARRAYLIT )  {^1556^^^^^1541^1571^if  ( left.getType (  )  == Token.ARRAYLIT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( left.getType (  )  == Token.1 )  {^1556^^^^^1541^1571^if  ( left.getType (  )  == Token.ARRAYLIT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( left.getType (  )  != Token.ARRAYLIT )  {^1556^^^^^1541^1571^if  ( left.getType (  )  == Token.ARRAYLIT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  != Token.NUMBER )  {^1558^^^^^1543^1573^if  ( right.getType (  )  != Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  >= Token.NUMBER )  {^1558^^^^^1543^1573^if  ( right.getType (  )  != Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( newType != index )  {^1566^^^^^1551^1581^if  ( intIndex != index )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( intIndex == index )  {^1566^^^^^1551^1581^if  ( intIndex != index )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, right, NEGATING_A_NON_NUMBER_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( INVALID_GETELEM_INDEX_ERROR, right, t, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, INVALID_GETELEM_INDEX_ERROR, right, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, right, index, String.valueOf ( INVALID_GETELEM_INDEX_ERROR )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, parent, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_REGULAR_EXPRESSION_FLAGS, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( index, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( t )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( right, t, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( originalSize < 0 )  {^1572^^^^^1557^1587^if  ( intIndex < 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( intIndex == 0 )  {^1572^^^^^1557^1587^if  ( intIndex < 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( intIndex < foldedSize )  {^1572^^^^^1557^1587^if  ( intIndex < 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, right, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( newType )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( intIndex, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( t )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, intIndex, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( n )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, n, intIndex, String.valueOf ( INDEX_OUT_OF_BOUNDS_ERROR )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( INDEX_OUT_OF_BOUNDS_ERROR, n, t, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( originalSize )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, SHIFT_AMOUNT_OUT_OF_BOUNDS, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( op )  )  ) ;^1574^^^^^1559^1589^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( right == null )  {^1583^^^^^1568^1598^if  ( elem == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( elem == parentull )  {^1583^^^^^1568^1598^if  ( elem == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( elem != null )  {^1583^^^^^1568^1598^if  ( elem == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, right, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( type )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, SHIFT_AMOUNT_OUT_OF_BOUNDS, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( INDEX_OUT_OF_BOUNDS_ERROR, n, t, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, INDEX_OUT_OF_BOUNDS_ERROR, n, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, n, intIndex, String.valueOf ( INDEX_OUT_OF_BOUNDS_ERROR )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( precedence )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INVALID_REGULAR_EXPRESSION_FLAGS, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( intIndex, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( t )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, intIndex, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( n )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( rvalInt )  )  ) ;^1585^^^^^1570^1600^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( int i = 0; parent != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( int i = 0; elem != null && i < pt; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^for  ( int i = 0; intIndex != null && i < elem; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^for  ( intIndexnt i = 0; elem != null && i < i; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = 0; elem != null || i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = 0; elem == null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = 0; elem != null && i <= intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -1; elem != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^elem = parent.getNext (  ) ;^1580^^^^^1565^1595^elem = elem.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^elem = right.getNext (  ) ;^1580^^^^^1565^1595^elem = elem.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^double index = parent.getDouble (  ) ;^1564^^^^^1549^1579^double index = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node elem = right.getFirstChild (  ) ;^1578^^^^^1563^1593^Node elem = left.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  != Token.NUMBER )  {^1558^^^^^1543^1573^if  ( right.getType (  )  != Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^double index = n.getDouble (  ) ;^1564^^^^^1549^1579^double index = right.getDouble (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, index, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( right )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, right, diagnostic, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( n, t, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( t, INDEX_OUT_OF_BOUNDS_ERROR, n, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, NEGATING_A_NON_NUMBER_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( newType )  )  ) ;^1574^^^^^1559^1589^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, parent, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( newType )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( originalSize )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( newType )  )  ) ;^1585^^^^^1570^1600^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^left.removeChild ( right ) ;^1590^^^^^1575^1605^left.removeChild ( elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, elem ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( elem, n ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( originalSize != index )  {^1566^^^^^1551^1581^if  ( intIndex != index )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( index != intIndex )  {^1566^^^^^1551^1581^if  ( intIndex != index )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( precedence < 0 )  {^1572^^^^^1557^1587^if  ( intIndex < 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( intIndex <= 0 )  {^1572^^^^^1557^1587^if  ( intIndex < 0 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( precedence )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INVALID_REGULAR_EXPRESSION_FLAGS, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( op )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, NEGATING_A_NON_NUMBER_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^t.getCompiler (  ) .report ( JSError.make ( n, t, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( pt )  )  ) ;^1585^^^^^1570^1600^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( ttnt i = 0; elem != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( int i = 0; elem != null && i < result; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = 1; elem != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = kJoinOverhead; elem != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( type )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String.valueOf ( originalSize )  )  ) ;^1585^^^^^1570^1600^String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^1601^1602^^^^1600^1625^if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  == Token.STRING || right.getString (  ) .equals ( "length" )  )  {^1601^1602^^^^1600^1625^if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( right.getType (  )  != Token.STRING && right.getString (  ) .equals ( "length" )  )  {^1601^1602^^^^1600^1625^if  ( right.getType (  )  == Token.STRING && right.getString (  ) .equals ( "length" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( parent )  )  {^1606^^^^^1600^1625^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^knownLength = right.getChildCount (  ) ;^1610^^^^^1600^1625^knownLength = left.getChildCount (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^knownLength = right.getString (  ) .length (  ) ;^1613^^^^^1600^1625^knownLength = left.getString (  ) .length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int knownLength = -;^1603^^^^^1600^1625^int knownLength = -1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node lengthNode = Node.newNumber ( lvalInt ) ;^1621^^^^^1600^1625^Node lengthNode = Node.newNumber ( knownLength ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( originalSize != -1 ) ;^1620^^^^^1600^1625^Preconditions.checkState ( knownLength != -1 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( knownLength <= -1 ) ;^1620^^^^^1600^1625^Preconditions.checkState ( knownLength != -1 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^Preconditions.checkState ( knownLength != -fromIndex ) ;^1620^^^^^1600^1625^Preconditions.checkState ( knownLength != -1 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node lengthNode = Node.newNumber ( pt ) ;^1621^^^^^1600^1625^Node lengthNode = Node.newNumber ( knownLength ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( right, lengthNode ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( lengthNode, n ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.mayHaveSideEffects ( right )  )  {^1606^^^^^1600^1625^if  ( NodeUtil.mayHaveSideEffects ( left )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^knownLength = parent.getChildCount (  ) ;^1610^^^^^1600^1625^knownLength = left.getChildCount (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^knownLength = parent.getString (  ) .length (  ) ;^1613^^^^^1600^1625^knownLength = left.getString (  ) .length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int knownLength = -0;^1603^^^^^1600^1625^int knownLength = -1;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( parent.getType (  )  )  {^1604^^^^^1600^1625^switch  ( left.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( type != -1 ) ;^1620^^^^^1600^1625^Preconditions.checkState ( knownLength != -1 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( knownLength == -1 ) ;^1620^^^^^1600^1625^Preconditions.checkState ( knownLength != -1 ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node constructor = regexLiteral.getFirstChild (  ) ;^1632^^^^^1617^1647^Node constructor = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node constructor = pattern.getFirstChild (  ) ;^1632^^^^^1617^1647^Node constructor = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node pattern = regexLiteral.getNext (  ) ;^1633^^^^^1618^1648^Node pattern = constructor.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node flags = null != regexLiteral ? pattern.getNext (  )  : null;^1634^^^^^1619^1649^Node flags = null != pattern ? pattern.getNext (  )  : null;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Node flags = null == pattern ? pattern.getNext (  )  : null;^1634^^^^^1619^1649^Node flags = null != pattern ? pattern.getNext (  )  : null;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( null == regexLiteral ||  ( null != flags && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( null == pattern ||  ( null != regexLiteral && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( null == flags ||  ( null != pattern && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == pattern &&  ( null != flags && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null != pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == pattern ||  ( null != flags || null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == pattern ||  ( null == flags && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == pattern ||  ( null != flags && null == flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( pattern.getType (  )  == Token.STRING  || !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( pattern.getType (  )  < Token.STRING  && !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( pattern.getType (  )  != Token.STRING  && !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( pattern.getType (  )  >= Token.STRING  && !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( pattern.getType (  )  <= Token.STRING  && !"".equals ( pattern.getString (  )  )^1641^1642^1643^1644^^1626^1656^if  ( pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( null == regexLiteral || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( regexLiteralull == flags || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( flagsull == n || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == flags && "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null != flags || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, regexLiteral ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, NEGATING_A_NON_NUMBER_ERROR, flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( flags, INVALID_REGULAR_EXPRESSION_FLAGS, t ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( t, flags, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areSafeFlagsToFold ( regexLiteral.getString (  )  )  )  {^1669^^^^^1660^1674^if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, regexLiteral, flags ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, pattern, regexLiteral ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^regexLiteral = new Node ( Token.REGEXP, flags, pattern ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areValidRegexpFlags ( regexLiteral.getString (  )  )  )  {^1665^^^^^1660^1674^if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areValidRegexpFlags ( pattern.getString (  )  )  )  {^1665^^^^^1660^1674^if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( INVALID_REGULAR_EXPRESSION_FLAGS, t, flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^n.removeChild ( regexLiteral ) ;^1672^^^^^1660^1674^n.removeChild ( flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, regexLiteral ) ;^1662^^^^^1647^1677^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areValidRegexpFlags ( regexLiteral.getString (  )  )  )  {^1665^^^^^1650^1680^if  ( !areValidRegexpFlags ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, regexLiteral ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_GETELEM_INDEX_ERROR, flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( INVALID_REGULAR_EXPRESSION_FLAGS, t, flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( t, flags, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areSafeFlagsToFold ( regexLiteral.getString (  )  )  )  {^1669^^^^^1654^1684^if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^pattern = makeForwardSlashBracketSafe ( regexLiteral ) ;^1657^^^^^1642^1672^pattern = makeForwardSlashBracketSafe ( pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, pattern, regexLiteral ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, parent ) ;^1662^^^^^1647^1677^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^regexLiteral = new Node ( Token.REGEXP, regexLiteral, flags ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^regexLiteral = new Node ( Token.REGEXP, flags, pattern ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^pattern = makeForwardSlashBracketSafe ( parent ) ;^1657^^^^^1642^1672^pattern = makeForwardSlashBracketSafe ( pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( null == pattern || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, pattern ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^error ( flags, INVALID_REGULAR_EXPRESSION_FLAGS, t ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^n.removeChild ( regexLiteral ) ;^1672^^^^^1657^1687^n.removeChild ( flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( regexLiteral, regexLiteral ) ;^1676^^^^^1661^1691^parent.replaceChild ( n, regexLiteral ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, pattern ) ;^1676^^^^^1661^1691^parent.replaceChild ( n, regexLiteral ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, diagnostic, flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areSafeFlagsToFold ( pattern.getString (  )  )  )  {^1669^^^^^1660^1674^if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^pattern.getType (  )  == Token.STRING  && !"".equals ( regexLiteral.getString (  )  )^1642^1643^1644^1645^^1627^1657^pattern.getType (  )  == Token.STRING  && !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& !"".equals ( parent.getString (  )  )^1644^1645^1646^1647^^1629^1659^&& !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& !"".equals ( regexLiteral.getString (  )  )^1644^1645^1646^1647^^1629^1659^&& !"".equals ( pattern.getString (  )  )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& parent.getString (  ) .length (  )  < 100  &&  ( null == flags || flags.getType (  )  == Token.STRING )^1648^1649^1650^1651^^1633^1663^&& pattern.getString (  ) .length (  )  < 100  &&  ( null == flags || flags.getType (  )  == Token.STRING )^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&&  ( null == regexLiteral || flags.getType (  )  == Token.STRING )   && !containsUnicodeEscape ( pattern.getString (  )  )  )  {^1650^1651^1652^1653^^1635^1665^&&  ( null == flags || flags.getType (  )  == Token.STRING )   && !containsUnicodeEscape ( pattern.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^&& !containsUnicodeEscape ( parent.getString (  )  )  )  {^1653^^^^^1638^1668^&& !containsUnicodeEscape ( pattern.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !areSafeFlagsToFold ( pattern.getString (  )  )  )  {^1669^^^^^1654^1684^if  ( !areSafeFlagsToFold ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^return flags.matcher ( REGEXP_FLAGS_RE ) .matches (  ) ;^1691^^^^^1690^1692^return REGEXP_FLAGS_RE.matcher ( flags ) .matches (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] areValidRegexpFlags [RETURN_TYPE] boolean   String flags [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  flags  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^return flags.indexOf ( 'g' )  <= 0;^1703^^^^^1702^1704^return flags.indexOf ( 'g' )  < 0;^[CLASS] FoldConstants 1 2  [METHOD] areSafeFlagsToFold [RETURN_TYPE] boolean   String flags [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  flags  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^return flags.indexOf ( 'g' )  < -1;^1703^^^^^1702^1704^return flags.indexOf ( 'g' )  < 0;^[CLASS] FoldConstants 1 2  [METHOD] areSafeFlagsToFold [RETURN_TYPE] boolean   String flags [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  flags  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int pos = OR_PRECEDENCE;^1713^^^^^1709^1732^int pos = 0;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( null == s )  { sbb = new StringBuilder ( s.length (  )  + 16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( null == sbb )  { s = new StringBuilder ( s.length (  )  + 16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null != sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   &&  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + foldedSize ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   <=  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   ^  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  +  ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( newTypent i = 0; i < s.length (  ) ; ++i )  {^1714^^^^^1709^1732^for  ( int i = 0; i < s.length (  ) ; ++i )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = 0; i > s.length (  ) ; ++i )  {^1714^^^^^1709^1732^for  ( int i = 0; i < s.length (  ) ; ++i )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  |  ( int i = 0; i < s.length (  ) ; ++i )  {^1714^^^^^1709^1732^for  ( int i = 0; i < s.length (  ) ; ++i )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = 1; i < s.length (  ) ; ++i )  {^1714^^^^^1709^1732^for  ( int i = 0; i < s.length (  ) ; ++i )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   >  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + indexVal ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   |  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + rvalInt ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   <<  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   ||  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^pos = pt;^1722^^^^^1709^1732^pos = i;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   ==  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + AND_PRECEDENCE ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( s.charAt ( newType )  )  {^1715^^^^^1709^1732^switch  ( s.charAt ( i )  )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^switch  ( i.charAt ( s )  )  {^1715^^^^^1709^1732^switch  ( s.charAt ( i )  )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, newType, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, pos, newType ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^sb.append ( i, pos, s ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^sb.append ( s, i, pos ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, lvalInt, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^sb.append ( pos, s, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )   >=  16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^pos = newType;^1722^^^^^1709^1732^pos = i;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + originalSize ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( s.charAt ( originalSize )  )  {^1715^^^^^1709^1732^switch  ( s.charAt ( i )  )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, precedence, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, pos, originalSize ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, type, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, pos, precedence ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( sbull == n )  { return n.cloneTree (  ) ; }^1728^^^^^1709^1732^if  ( null == sb )  { return n.cloneTree (  ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( null != sb )  { return n.cloneTree (  ) ; }^1728^^^^^1709^1732^if  ( null == sb )  { return n.cloneTree (  ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^sb.append ( s, lvalInt, s.length (  )  ) ;^1730^^^^^1709^1732^sb.append ( s, pos, s.length (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^Scope.Var var = className.getScope (  ) .getVar ( t ) ;^1746^^^^^1743^1754^Scope.Var var = t.getScope (  ) .getVar ( className ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( var != null || var.isLocal (  )  )  {^1747^^^^^1743^1754^if  ( var != null && var.isLocal (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( var == null && var.isLocal (  )  )  {^1747^^^^^1743^1754^if  ( var != null && var.isLocal (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( 0 != null && var.isLocal (  )  )  {^1747^^^^^1743^1754^if  ( var != null && var.isLocal (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node literalNode = new Node ( result ) ;^1751^^^^^1743^1754^Node literalNode = new Node ( type ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node literalNode = new Node ( op ) ;^1751^^^^^1743^1754^Node literalNode = new Node ( type ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( literalNode, literalNode ) ;^1752^^^^^1743^1754^parent.replaceChild ( n, literalNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, n ) ;^1752^^^^^1743^1754^parent.replaceChild ( n, literalNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^String esc = CodeGenerator.regexpEscape ( esc ) ;^1761^^^^^1760^1772^String esc = CodeGenerator.regexpEscape ( s ) ;^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( i - op > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( i - nSlashes > 0 && '\\' == s.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^while  ( nSlashes - i > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^while  ( i - esc > 0 && '\\' == nSlashes.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 || '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes >= 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i  >>  nSlashes > 0 && '\\' == esc.charAt ( i  >>  nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' > esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i  >>  nSlashes  >>  1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i  &  nSlashes > 0 && '\\' == esc.charAt ( i  &  nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes  )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( 0 ==  ( lvalInt & 1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( 0 !=  ( nSlashes & 1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( 0 ==  ( nSlashes  <  1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( 1 ==  ( nSlashes & 1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( 0 ==  ( nSlashes & 0 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^if  ( 0 ==  ( nSlashes & 1 )  )  { return false; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( nSlashesnt i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  > 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i  |  1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -i;  ( i = esc.indexOf ( "\\u", i + i )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i  )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= result; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 1; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -lvalInt;  ( i = esc.indexOf ( "\\u", i + lvalInt )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= -1; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( originalSize - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( i - type > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^while  ( esc - nSlashes > 0 && '\\' == i.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes < 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i  >=  nSlashes > 0 && '\\' == esc.charAt ( i  >=  nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' <= esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i  &&  nSlashes  &&  1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i  ||  nSlashes > 0 && '\\' == esc.charAt ( i  ||  nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^while  ( i - nSlashes > 1 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( 0 ==  ( originalSize & 1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( 0 >=  ( nSlashes & 1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( 0 ==  ( nSlashes  !=  1 )  )  { return true; }^1769^^^^^1760^1772^if  ( 0 ==  ( nSlashes & 1 )  )  { return true; }^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( precedence - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( i - originalSize > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i  ==  nSlashes  ==  1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( int i = -1;  ( i = s.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( originalSizent i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^for  ( escnt i = -1;  ( i = i.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i  <=  1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -AND_PRECEDENCE;  ( i = esc.indexOf ( "\\u", i + AND_PRECEDENCE )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^for  ( int i = -knownLength;  ( i = esc.indexOf ( "\\u", i + knownLength )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i  <  1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^while  ( i - newType > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i   instanceof   nSlashes   instanceof   1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^return true;^1771^^^^^1760^1772^return false;^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( parent.getType (  )  == Token.WHILE ) ;^1778^^^^^1777^1786^Preconditions.checkArgument ( n.getType (  )  == Token.WHILE ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( n.getType (  )  != Token.WHILE ) ;^1778^^^^^1777^1786^Preconditions.checkArgument ( n.getType (  )  == Token.WHILE ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1779^^^^^1777^1786^Node cond = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  || NodeUtil.getBooleanValue ( cond )  )  {^1780^^^^^1777^1786^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isLiteralValue ( cond )  && NodeUtil.getBooleanValue ( cond )  )  {^1780^^^^^1777^1786^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( parent ) ;^1783^^^^^1777^1786^NodeUtil.redeclareVarsInsideBranch ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( cond, n ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, cond ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( parent.getType (  )  == Token.FOR ) ;^1792^^^^^1791^1805^Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( n.getType (  )  == Token.null ) ;^1792^^^^^1791^1805^Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( n.getType (  )  > Token.FOR ) ;^1792^^^^^1791^1805^Preconditions.checkArgument ( n.getType (  )  == Token.FOR ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parent.getChildCount (  )  != 4 )  return;^1794^^^^^1791^1805^if  ( n.getChildCount (  )  != 4 )  return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( n.getChildCount (  )  == 4 )  return;^1794^^^^^1791^1805^if  ( n.getChildCount (  )  != 4 )  return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( n.getFirstChild (  ) .getType (  )  >= Token.EMPTY )  return;^1796^^^^^1791^1805^if  ( n.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parent.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return;^1796^^^^^1791^1805^if  ( n.getFirstChild (  ) .getType (  )  != Token.EMPTY )  return;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1798^^^^^1791^1805^Node cond = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isLiteralValue ( cond )  && NodeUtil.getBooleanValue ( cond )  )  {^1799^^^^^1791^1805^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  || NodeUtil.getBooleanValue ( cond )  )  {^1799^^^^^1791^1805^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.redeclareVarsInsideBranch ( parent ) ;^1802^^^^^1791^1805^NodeUtil.redeclareVarsInsideBranch ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.removeChild ( parent, cond ) ;^1803^^^^^1791^1805^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^NodeUtil.removeChild ( n, parent ) ;^1803^^^^^1791^1805^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( parent.getType (  )  == Token.DO ) ;^1813^^^^^1812^1832^Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( n.getType (  )  != Token.DO ) ;^1813^^^^^1812^1832^Preconditions.checkArgument ( n.getType (  )  == Token.DO ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node cond = NodeUtil.getConditionExpression ( parent ) ;^1815^^^^^1812^1832^Node cond = NodeUtil.getConditionExpression ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isLiteralValue ( parent )  || NodeUtil.getBooleanValue ( cond )  )  {^1816^^^^^1812^1832^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isLiteralValue ( cond )  && NodeUtil.getBooleanValue ( cond )  )  {^1816^^^^^1812^1832^if  ( !NodeUtil.isLiteralValue ( cond )  || NodeUtil.getBooleanValue ( cond )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( hasBreakOrContinue ( parent )  )  {^1822^^^^^1812^1832^if  ( hasBreakOrContinue ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( parent, n.getFirstChild (  )  )  ) ;^1826^1827^^^^1812^1832^Preconditions.checkState ( NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^NodeUtil.isControlStructureCodeBlock ( parent, n.getFirstChild (  )  )  ) ;^1827^^^^^1812^1832^NodeUtil.isControlStructureCodeBlock ( n, n.getFirstChild (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node block = parent.removeFirstChild (  ) ;^1828^^^^^1812^1832^Node block = n.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, block ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( block, n ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Predicates.<Node>or ( new NodeUtil.MatchNodeType ( Token.2 ) , new NodeUtil.MatchNodeType ( Token.CONTINUE )  ) , Predicates.<Node>not ( new NodeUtil.MatchNodeType ( Token.FUNCTION )  )  ) ;^1843^1844^1845^1846^^1837^1847^Predicates.<Node>or ( new NodeUtil.MatchNodeType ( Token.BREAK ) , new NodeUtil.MatchNodeType ( Token.CONTINUE )  ) , Predicates.<Node>not ( new NodeUtil.MatchNodeType ( Token.FUNCTION )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] hasBreakOrContinue [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  
[BugLab_Variable_Misuse]^if  ( right.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( leftParent.getType (  )  != Token.NOT || right.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^if  ( rightParent.getType (  )  != Token.NOT || leftParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( leftParent.getType (  )  != Token.NOT && rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( leftParent.getType (  )  == Token.NOT || rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( leftParent.getType (  )  <= Token.NOT || rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( rightParent )  )  {^1910^^^^^1895^1925^if  ( NodeUtil.isLiteralValue ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean result = NodeUtil.getBooleanValue ( rightParent ) ;^1911^^^^^1896^1926^boolean result = NodeUtil.getBooleanValue ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int equivalentResult = result ?  : 0;^1912^^^^^1897^1927^int equivalentResult = result ? 1 : 0;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Literal]^int equivalentResult = result ? 1 : i;^1912^^^^^1897^1927^int equivalentResult = result ? 1 : 0;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^boolean result = NodeUtil.getBooleanValue ( next ) ;^1911^^^^^1896^1926^boolean result = NodeUtil.getBooleanValue ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^maybeReplaceChildWithNumber ( t, next, parent, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^maybeReplaceChildWithNumber ( t, n, next, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^maybeReplaceChildWithNumber ( t, n, parent, newOp ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^maybeReplaceChildWithNumber ( equivalentResult, n, parent, t ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^maybeReplaceChildWithNumber ( t, parent, n, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^maybeReplaceChildWithNumber ( t, equivalentResult, parent, n ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^n = right;^1892^^^^^1877^1907^n = newRoot;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = new Node ( op, left, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = new Node ( newOp, parent, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = new Node ( newOp, left, newRoot ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^Node newRoot = new Node ( right, left, newOp ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^Node newRoot = new Node ( newOp, right, left ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node first = right.getFirstChild (  ) ;^1865^^^^^1850^1880^Node first = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = rightParent.removeFirstChild (  ) ;^1868^^^^^1853^1883^Node newRoot = first.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node leftParent = rightParent.getFirstChild (  ) ;^1879^^^^^1864^1894^Node leftParent = first.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node rightParent = next.getLastChild (  ) ;^1880^^^^^1865^1895^Node rightParent = first.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node left = rightParent.removeFirstChild (  ) ;^1886^^^^^1871^1901^Node left = leftParent.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node right = newRoot.removeFirstChild (  ) ;^1887^^^^^1872^1902^Node right = rightParent.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^int newOp =  ( rightParent.getType (  )  == Token.AND )  ? Token.OR : Token.AND;^1889^^^^^1874^1904^int newOp =  ( first.getType (  )  == Token.AND )  ? Token.OR : Token.AND;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^int newOp =  ( first.getType (  )  >= Token.AND )  ? Token.OR : Token.AND;^1889^^^^^1874^1904^int newOp =  ( first.getType (  )  == Token.AND )  ? Token.OR : Token.AND;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = new Node ( originalSize, left, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = new Node ( newOp, left, parent ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^Node newRoot = new Node ( left, newOp, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( next.getType (  )  )  {^1863^^^^^1848^1878^switch  ( n.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^switch  ( next.getType (  )  )  {^1866^^^^^1851^1881^switch  ( first.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node newRoot = next.removeFirstChild (  ) ;^1868^^^^^1853^1883^Node newRoot = first.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, newRoot ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, right ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newRoot, n ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, next, parent ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, n, next ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( parent, n, t ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( t, parent, n ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node leftParent = next.getFirstChild (  ) ;^1879^^^^^1864^1894^Node leftParent = first.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node rightParent = rightParent.getLastChild (  ) ;^1880^^^^^1865^1895^Node rightParent = first.getLastChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^|| next.getType (  )  != Token.NOT )  {^1882^^^^^1867^1897^|| rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node right = next.removeFirstChild (  ) ;^1887^^^^^1872^1902^Node right = rightParent.removeFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( rightParent, newRoot ) ;^1891^^^^^1876^1906^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, rightParent ) ;^1891^^^^^1876^1906^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newRoot, n ) ;^1891^^^^^1876^1906^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( right )  )  {^1910^^^^^1895^1925^if  ( NodeUtil.isLiteralValue ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^maybeReplaceChildWithNumber ( t, right, parent, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^maybeReplaceChildWithNumber ( parent, n, t, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( Node c = right.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( Node rightParent = n.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^for  ( Node n = c.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^for  ( Node c = n.getFirstChild (  ) ; c == null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^c = rightParent;^1922^^^^^1907^1937^c = next;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^Node next = rightParent.getNext (  ) ;^1920^^^^^1905^1935^Node next = c.getNext (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, rightParent, n ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( n, c, t ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( t, n, c ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^c = parent;^1922^^^^^1907^1937^c = next;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^for  ( Node c = rightParent.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^tryMinimizeCondition ( t, c, right ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^tryMinimizeCondition ( c, t, n ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( Token.3 )  ) ;^1933^^^^^1929^1937^parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[BugLab_Variable_Misuse]^boolean result = NodeUtil.getBooleanValue ( parent ) ;^1931^^^^^1929^1937^boolean result = NodeUtil.getBooleanValue ( n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, new Node ( Token.EMPTY )  ) ;^1933^^^^^1929^1937^parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, new Node ( Token.this )  ) ;^1933^^^^^1929^1937^parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isLiteralValue ( parent )  )  {^1930^^^^^1929^1937^if  ( NodeUtil.isLiteralValue ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[BugLab_Variable_Misuse]^Node newNode = Node.newNumber ( rvalInt ) ;^1945^^^^^1943^1950^Node newNode = Node.newNumber ( num ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^if ( !newNode.isEquivalentTo ( parent )  )  {^1946^^^^^1943^1950^if ( !newNode.isEquivalentTo ( n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( newNode, newNode ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( newNode, n ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, newNode ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  >= Token.BLOCK )  {^1957^^^^^1956^1964^if  ( n.getType (  )  == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] isExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  
[BugLab_Wrong_Literal]^return true;^1963^^^^^1956^1964^return false;^[CLASS] FoldConstants 1 2  [METHOD] isExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  < Token.BLOCK )  {^1979^^^^^1978^1989^if  ( n.getType (  )  == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  <= Token.BLOCK )  {^1979^^^^^1978^1989^if  ( n.getType (  )  == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.RETURN )  {^1982^^^^^1978^1989^if  ( first.getType (  )  == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( first.getType (  )  == Token.0 )  {^1982^^^^^1978^1989^if  ( first.getType (  )  == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  != Token.RETURN )  {^1982^^^^^1978^1989^if  ( first.getType (  )  == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^return n.hasOneChild (  ) ;^1983^^^^^1978^1989^return first.hasOneChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^Node first = first.getFirstChild (  ) ;^1981^^^^^1978^1989^Node first = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( first.hasOneChild (  )  )  {^1980^^^^^1978^1989^if  ( n.hasOneChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  <= Token.RETURN )  {^1982^^^^^1978^1989^if  ( first.getType (  )  == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  < Token.RETURN )  {^1982^^^^^1978^1989^if  ( first.getType (  )  == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Literal]^return true;^1988^^^^^1978^1989^return false;^[CLASS] FoldConstants 1 2  [METHOD] isReturnExpressBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  != Token.BLOCK )  {^2004^^^^^2003^2014^if  ( n.getType (  )  == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( n.getType (  )  == Token.VAR )  {^2007^^^^^2003^2014^if  ( first.getType (  )  == Token.VAR )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  <= Token.VAR )  {^2007^^^^^2003^2014^if  ( first.getType (  )  == Token.VAR )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^return n.hasOneChild (  ) ;^2008^^^^^2003^2014^return first.hasOneChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^Node first = first.getFirstChild (  ) ;^2006^^^^^2003^2014^Node first = n.getFirstChild (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  != Token.VAR )  {^2007^^^^^2003^2014^if  ( first.getType (  )  == Token.VAR )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( first.hasOneChild (  )  )  {^2005^^^^^2003^2014^if  ( n.hasOneChild (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Operator]^if  ( first.getType (  )  >= Token.VAR )  {^2007^^^^^2003^2014^if  ( first.getType (  )  == Token.VAR )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^if  ( first.getType (  )  == Token.BLOCK )  {^2004^^^^^2003^2014^if  ( n.getType (  )  == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Wrong_Literal]^return true;^2013^^^^^2003^2014^return false;^[CLASS] FoldConstants 1 2  [METHOD] isVarBlock [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  first  n  
[BugLab_Variable_Misuse]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  == Token.GETPROP || parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  < Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^found[0] |=  ( n.getType (  )  >= Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^lower[0] |= NodeUtil.precedence ( parent.getType (  )  )  < precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  <= precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Literal]^lower[] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
