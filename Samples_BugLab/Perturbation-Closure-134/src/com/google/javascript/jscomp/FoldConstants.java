[buglab_swap_variables]^NodeTraversal.traverse ( jsRoot, compiler, this ) ;^87^^^^^86^88^NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[CLASS] FoldConstants 1 2  [METHOD] process [RETURN_TYPE] void   Node externs Node jsRoot [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  int  AND_PRECEDENCE  OR_PRECEDENCE  Node  externs  jsRoot  
[buglab_swap_variables]^NodeTraversal.traverse ( compiler,  this ) ;^87^^^^^86^88^NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[CLASS] FoldConstants 1 2  [METHOD] process [RETURN_TYPE] void   Node externs Node jsRoot [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  int  AND_PRECEDENCE  OR_PRECEDENCE  Node  externs  jsRoot  
[buglab_swap_variables]^NodeTraversal.traverse (  jsRoot, this ) ;^87^^^^^86^88^NodeTraversal.traverse ( compiler, jsRoot, this ) ;^[CLASS] FoldConstants 1 2  [METHOD] process [RETURN_TYPE] void   Node externs Node jsRoot [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  int  AND_PRECEDENCE  OR_PRECEDENCE  Node  externs  jsRoot  
[buglab_swap_variables]^if  ( typeype == Token.BLOCK )  {^93^^^^^78^108^if  ( type == Token.BLOCK )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock ( parent, n, t ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock (  n, parent ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock ( n, t, parent ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock ( t,  parent ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock ( t, parent, n ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBlock ( t, n ) ;^94^^^^^79^109^tryFoldBlock ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild ( newValue, Node.newString ( n )  ) ;^132^^^^^117^147^parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  Node.newString ( newValue )  ) ;^132^^^^^117^147^parent.replaceChild ( n, Node.newString ( newValue )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^} else if  ( t == Token.NEW )  {^216^^^^^201^231^} else if  ( type == Token.NEW )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^} else if  ( n.getNext (  )  == leftull )  {^221^^^^^206^236^} else if  ( left.getNext (  )  == null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( n, t, parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor (  n, parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, className, parent, n, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t,  parent, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, parent, n, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n,  className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n, parent,  Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( parent, n, t, className, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( n, t, parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor (  n, parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, parent, n, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t,  parent, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n, className, parent, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n,  className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( className, n, parent, t, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n, parent,  Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( className, n, parent, t, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, n, className, parent, Token.OBJECTLIT ) ;^226^227^^^^211^241^tryFoldLiteralConstructor ( t, n, parent, className, Token.OBJECTLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( parent, n, t, className, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLiteralConstructor ( t, className, parent, n, Token.ARRAYLIT ) ;^223^224^^^^208^238^tryFoldLiteralConstructor ( t, n, parent, className, Token.ARRAYLIT ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor ( n, t, parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor (  n, parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor ( t, parent, n ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor ( t,  parent ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor ( t, n ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldRegularExpressionConstructor ( parent, n, t ) ;^220^^^^^205^235^tryFoldRegularExpressionConstructor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  n.removeFirstChild (  )  ) ;^147^^^^^132^162^parent.replaceChild ( n, n.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( t == Token.NOT && typeryMinimizeNot ( t, n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.NOT && tryMinimizeNot (  n, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.NOT && tryMinimizeNot ( t, parent, n )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.NOT && tryMinimizeNot ( t,  parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.NOT && tryMinimizeNot ( t, n )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  left ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild ( left, n ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^178^^^^^163^193^parent.replaceChild ( n, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( val == intVal )  {^199^^^^^184^214^if  ( intVal == val )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  FRACTIONAL_BITWISE_OPERAND, left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( ~intVal )  ) ;^200^^^^^185^215^parent.replaceChild ( n, Node.newNumber ( ~intVal )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  FRACTIONAL_BITWISE_OPERAND, left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( negNum )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild ( negNum, Node.newNumber ( n )  ) ;^185^^^^^170^200^parent.replaceChild ( n, Node.newNumber ( negNum )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^206^^^^^197^207^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^203^^^^^188^218^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^203^^^^^199^204^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^206^^^^^191^221^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( parentype == Token.NOT && tryMinimizeNot ( t, n, t )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( nype == Token.NOT && tryMinimizeNot ( t, t, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( result )  ) ;^165^^^^^150^180^parent.replaceChild ( n, new Node ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, NEGATING_A_NON_NUMBER_ERROR, t ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  NEGATING_A_NON_NUMBER_ERROR, left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, NEGATING_A_NON_NUMBER_ERROR ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( NEGATING_A_NON_NUMBER_ERROR, t, left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( NEGATING_A_NON_NUMBER_ERROR, t, left ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error (  NEGATING_A_NON_NUMBER_ERROR, left ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( left, NEGATING_A_NON_NUMBER_ERROR, t ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, NEGATING_A_NON_NUMBER_ERROR ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t,  left ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( n == Token.NOT && tryMinimizeNot ( t, type, parent )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( parent == Token.NOT && tryMinimizeNot ( t, n, type )  )  {^153^^^^^138^168^if  ( type == Token.NOT && tryMinimizeNot ( t, n, parent )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^} else if  ( typeype == Token.NEW )  {^216^^^^^201^231^} else if  ( type == Token.NEW )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild ( result, new Node ( n )  ) ;^165^^^^^150^180^parent.replaceChild ( n, new Node ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, NEGATING_A_NON_NUMBER_ERROR ) ;^190^^^^^175^205^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^error ( t, left, NEGATING_A_NON_NUMBER_ERROR ) ;^211^^^^^196^226^error ( t, NEGATING_A_NON_NUMBER_ERROR, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( t == Token.EXPR_RESULT )  {^233^^^^^218^248^if  ( type == Token.EXPR_RESULT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( typeype == Token.EXPR_RESULT )  {^233^^^^^218^248^if  ( type == Token.EXPR_RESULT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( left, t, n ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition (  left, n ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, n, left ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t,  n ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, left ) ;^234^^^^^219^249^tryMinimizeCondition ( t, left, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( t == Token.RETURN )  {^238^^^^^223^253^if  ( type == Token.RETURN )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryReduceReturn ( n, t ) ;^239^^^^^224^254^tryReduceReturn ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryReduceReturn (  n ) ;^239^^^^^224^254^tryReduceReturn ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryReduceReturn ( t ) ;^239^^^^^224^254^tryReduceReturn ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( right ) && !NodeUtil.mayHaveSideEffects ( left )  )  {^250^251^252^^^235^265^if  ( type == Token.INSTANCEOF && NodeUtil.isLiteralValue ( left ) && !NodeUtil.mayHaveSideEffects ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.FALSE )  ) ;^255^^^^^250^266^parent.replaceChild ( n, new Node ( Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.TRUE )  ) ;^262^^^^^250^266^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.FALSE )  ) ;^255^^^^^240^270^parent.replaceChild ( n, new Node ( Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.TRUE )  ) ;^262^^^^^260^265^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.TRUE )  ) ;^262^^^^^247^277^parent.replaceChild ( n, new Node ( Token.TRUE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf ( n, t, parent ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf (  n, parent ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf ( t, parent, n ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf ( t,  parent ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf ( parent, n, t ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeIf ( t, n ) ;^275^^^^^260^290^tryMinimizeIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = parentryFoldHookIf ( t, n, t ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = tryFoldHookIf (  n, parent ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = nryFoldHookIf ( t, t, parent ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = tryFoldHookIf ( t,  parent ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = tryFoldHookIf ( t, parent, n ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^boolean changes = tryFoldHookIf ( t, n ) ;^270^^^^^255^285^boolean changes = tryFoldHookIf ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( n, t.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition (  n.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t.getFirstChild (  ) , n ) ;^269^^^^^254^284^tryMinimizeCondition ( t, n.getFirstChild (  ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( typeype == Token.DO )  {^280^^^^^265^295^if  ( type == Token.DO )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( n, NodeUtil.getConditionExpression ( t ) , n ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition (  NodeUtil.getConditionExpression ( n ) , n ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n )  ) ;^281^^^^^266^296^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo ( parent, n, t ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo (  n, parent ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo ( t, parent, n ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo ( t,  parent ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo ( t, n ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldDo ( n, t, parent ) ;^282^^^^^267^297^tryFoldDo ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( n, NodeUtil.getConditionExpression ( t ) , n ) ;^287^^^^^272^302^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition (  NodeUtil.getConditionExpression ( n ) , n ) ;^287^^^^^272^302^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n )  ) ;^287^^^^^272^302^tryMinimizeCondition ( t, NodeUtil.getConditionExpression ( n ) , n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldWhile ( n, t, parent ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldWhile (  n, parent ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldWhile ( t, parent, n ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldWhile ( t,  parent ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldWhile ( t, n ) ;^288^^^^^273^303^tryFoldWhile ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( n != conditionull )  {^294^^^^^279^309^if  ( condition != null )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( condition, t, n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition (  condition, n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, n, condition ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t,  n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( t, conditio n ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^this.tryFoldForCondition ( n, condition ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^this.tryFoldForCondition (  n ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^this.tryFoldForCondition ( conditio n ) ;^298^^^^^283^313^this.tryFoldForCondition ( condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryMinimizeCondition ( n, condition, t ) ;^295^^^^^280^310^tryMinimizeCondition ( t, condition, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor ( parent, n, t ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor (  n, parent ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor ( t, parent, n ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor ( t,  parent ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor ( t, n ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldFor ( n, t, parent ) ;^301^^^^^286^316^tryFoldFor ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( typeype == Token.AND || t == Token.OR )  {^305^306^^^^290^320^if  ( type == Token.AND || type == Token.OR )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( parent, n, left, right, t ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr (  n, left, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, right, left, n, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t,  left, right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, right, left, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n,  right, parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, left,  parent ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, left, parent, right ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, left, right ) ;^307^^^^^305^309^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( left, n, t, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr (  n, left, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, right, left, n, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t,  left, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, left, n, right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n,  right, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, right, left, parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, left,  parent ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, parent, left, right, n ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAndOr ( t, n, left, right ) ;^307^^^^^292^322^tryFoldAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( parent, n, left, right, t ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr (  n, left, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, left, n, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t,  left, right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, parent, right, left ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n,  right, parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, left, parent, right ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, left,  parent ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, left, right ) ;^313^^^^^311^315^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( n, t, left, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr (  n, left, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, left, n, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t,  left, right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, right, left, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n,  right, parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, left,  parent ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, parent, left, right, n ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldBitAndOr ( t, n, left, right ) ;^313^^^^^298^328^tryFoldBitAndOr ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( right, n, left, t, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift (  n, left, right, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, parent, left, right, n ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t,  left, right, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, parent, right, left ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n,  right, parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left, parent, right ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left,  parent ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( parent, n, left, right, t ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left, right ) ;^320^^^^^317^322^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( parent, n, left, right, t ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift (  n, left, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( n, t, left, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t,  left, right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, parent, right, left ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n,  right, parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left, parent, right ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left,  parent ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldShift ( t, n, left, right ) ;^320^^^^^305^335^tryFoldShift ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( typeype == Token.GETPROP )  {^324^^^^^309^339^if  ( type == Token.GETPROP )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( left, n, t, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp (  n, left, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, left, n, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t,  left, right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n,  right, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n, right, left, parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n, left,  parent ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n, parent, right, left ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n, left, right ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, parent, left, right, n ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetProp ( t, n, left, parent, right ) ;^325^^^^^310^340^tryFoldGetProp ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( right, n, left, t, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin (  n, left, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, right, left, n, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t,  left, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n, parent, right, left ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n,  right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n, right, left, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n, left,  parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, parent, left, right, n ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n, left, right ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( left, n, t, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf (  n, left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( n, t, left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t,  left, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, left, n, right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, n,  right, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, n, right, left, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, n, left,  parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, parent, left, right, n ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, n, left, right ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( n, t, left, right, parent ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringJoin ( t, n, left, parent, right ) ;^330^^^^^315^345^tryFoldStringJoin ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, right, left, n, parent ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldStringIndexOf ( t, n, left, parent, right ) ;^331^^^^^316^346^tryFoldStringIndexOf ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( n, t, left, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign (  n, left, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( t, right, left, n ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( t,  left, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( t, left, n, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( t, n,  right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( right, n, left, t ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( t, n, left ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAssign ( left, n, t, right ) ;^336^^^^^321^351^tryFoldAssign ( t, n, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( !NodeUtil.isLiteralValue ( right )  || !NodeUtil.isLiteralValue ( left )  )  {^339^340^^^^324^354^if  ( !NodeUtil.isLiteralValue ( left )  || !NodeUtil.isLiteralValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( parent == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, type ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd (  n, left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t,  left, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( leftype == Token.ADD ) tryFoldLeftChildAdd ( t, n, t, right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n,  right, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, right, left, n, parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left,  parent ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right ) ;^342^343^^^^339^351^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( n, t, left, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd (  n, left, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t,  left, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, right, left, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n,  right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left,  parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left, right ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( t == Token.LT || typeype == Token.GT )  {^345^346^^^^339^351^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( left, n, t, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison (  n, left, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, parent, left, right, n ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t,  left, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, parent, right, left ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n,  right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, right, left, n, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left,  parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, parent, right ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, right ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( left, n, t, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, parent, left, right, n ) ;^343^^^^^339^351^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( right, n, left, t, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( n, t, left, right, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, right, left, parent ) ;^347^^^^^339^351^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( n == Token.ADD ) tryFoldLeftChildAdd ( t, type, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( leftype == Token.ADD ) tryFoldLeftChildAdd ( t, n, t, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd (  n, left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t,  left, right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, parent, right, left ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n,  right, parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left,  parent ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right ) ;^342^343^^^^327^357^if  ( type == Token.ADD ) tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( right, n, left, t, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd (  n, left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, left, n, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t,  left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, parent, right, left ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n,  right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, right, left, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left,  parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left, right ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^if  ( typeype == Token.LT || t == Token.GT )  {^345^346^^^^330^360^if  ( type == Token.LT || type == Token.GT )  {^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( n, t, left, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison (  n, left, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, right, left, n, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t,  left, right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, right, left, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n,  right, parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, parent, right ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left,  parent ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, parent, left, right, n ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, right ) ;^347^^^^^345^348^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( n, t, left, right, parent ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, n, left, parent, right ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldLeftChildAdd ( t, parent, left, right, n ) ;^343^^^^^328^358^tryFoldLeftChildAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( parent, n, left, right, t ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison (  n, left, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, right, left, n, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t,  left, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, left, n, right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n,  right, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( right, n, left, t, parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left,  parent ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, parent, left, right, n ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, right ) ;^347^^^^^332^362^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( left, n, t, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd (  n, left, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, right, left, n, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t,  left, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n, parent, right, left ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n,  right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n, left,  parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n, left, parent, right ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n, left, right ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( right, n, left, t, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, left, n, right, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldAdd ( t, n, right, left, parent ) ;^354^^^^^339^369^tryFoldAdd ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( parent, n, left, right, t ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic (  n, left, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, parent, left, right, n ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t,  left, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, left, n, right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n,  right, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, right, left, parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left,  parent ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, parent, right, left ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left, right ) ;^360^^^^^357^362^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( parent, n, left, right, t ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic (  n, left, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, parent, left, right, n ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t,  left, right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, parent, right, left ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n,  right, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, right, left, parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left,  parent ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left, right ) ;^360^^^^^345^375^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( parent, n, left, right, t ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison (  n, left, right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, right, left, n, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t,  left, right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, left, n, right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n,  right, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, right, left, parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left,  parent ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, right ) ;^372^^^^^364^374^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( left, n, t, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison (  n, left, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, left, n, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t,  left, right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n,  right, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, right, left, n, parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left,  parent ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, parent, left, right, n ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldComparison ( t, n, left, right ) ;^372^^^^^357^387^tryFoldComparison ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( right, n, left, t, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem (  n, left, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, parent, left, right, n ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t,  left, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, left, n, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, n,  right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, n, left, parent, right ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, n, left,  parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, n, parent, right, left ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( t, n, left, right ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^tryFoldGetElem ( left, n, t, right, parent ) ;^377^^^^^362^392^tryFoldGetElem ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  double  negNum  val  Node  condition  left  n  parent  right  String  className  newValue  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  UnsupportedOperationException  ex  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( n, t, diagnostic, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make (  n, diagnostic, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t,  diagnostic, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( diagnostic, n, t, n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, n,  n.toString (  )  )  ) ;^385^^^^^384^386^t.getCompiler (  ) .report ( JSError.make ( t, n, diagnostic, n.toString (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] error [RETURN_TYPE] void   NodeTraversal t DiagnosticType diagnostic Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  result  type  
[buglab_swap_variables]^if  ( !left.checkTreeEqualsSilent ( leftChildChild )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !left.checkTreeEqualsSilent ( left )  )  {^427^^^^^412^442^if  ( !left.checkTreeEqualsSilent ( leftChild )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( n, new Node ( left, newType.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( n, new Node (  left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( n, new Node ( newType, right.detachFromParent (  ) , left.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( n, new Node ( newType.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) .getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild ( right, new Node ( newType, left.detachFromParent (  ) , n.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.getParent (  ) .replaceChild (  new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^470^471^^^^455^485^n.getParent (  ) .replaceChild ( n, new Node ( newType, left.detachFromParent (  ) , right.getLastChild (  ) .detachFromParent (  )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAssign [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  leftChild  n  right  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^for  ( Node n = c.getFirstChild (  ) ; c != null;  )  {^480^^^^^478^497^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( parent.isSyntheticBlock (  )  || n == null )  {^489^^^^^478^497^if  ( n.isSyntheticBlock (  )  || parent == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBlock [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  n  next  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( thenBodyhenBody )  )  {^551^^^^^536^566^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^new Node ( Token. NodeUtil.newExpr ( thenBody )  )  ) ;^579^^^^^564^594^new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^ifNode.addChildToBack ( new Node ( Token. NodeUtil.newExpr ( thenBody )  )  ) ;^578^579^^^^563^593^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( thenBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild ( ifNode, parent ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild (  ifNode ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild ( parent ) ;^580^^^^^565^595^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^new Node ( Token. NodeUtil.newExpr ( elseBody )  )  ) ;^567^^^^^552^582^new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^ifNode.addChildToBack ( new Node ( Token. NodeUtil.newExpr ( elseBody )  )  ) ;^566^567^^^^551^581^ifNode.addChildToBack ( new Node ( Token.BLOCK, NodeUtil.newExpr ( elseBody )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild ( ifNode, parent ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild (  ifNode ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.getParent (  ) .replaceChild ( parent ) ;^568^^^^^553^583^parent.getParent (  ) .replaceChild ( parent, ifNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( n != elseBodyull && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^513^^^^^498^528^if  ( elseBody != null && !NodeUtil.mayHaveSideEffects ( elseBody )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && n != elseBodyull )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild (  elseBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( thenBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( n, condotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( condotCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( notCond, cond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild (  notCond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( cond, n ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( cond ) ;^525^^^^^510^540^n.replaceChild ( cond, notCond ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  && thenBody == null )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^542^^^^^536^543^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  NodeUtil.newExpr ( cond )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( cond, NodeUtil.newExpr ( n )  ) ;^539^^^^^524^554^parent.replaceChild ( n, NodeUtil.newExpr ( cond )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^542^^^^^527^557^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild ( elseBody, thenBody ) ;^523^^^^^508^538^n.replaceChild ( thenBody, elseBody ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( elseBody )  && thenBody != null )  {^521^^^^^506^536^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( n )  && elseBody == thenBodyull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^if  ( !NodeUtil.mayHaveSideEffects ( nhenBody )  && elseBody == tull )  {^535^^^^^520^550^if  ( !NodeUtil.mayHaveSideEffects ( thenBody )  && elseBody == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node branch = secondBranch ? firstBranch : condTrue;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node branch = condTrue ? secondBranch : firstBranch;^614^^^^^594^620^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node notBranch = firstBranch ? secondBranch : condTrue;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node notBranch = condTrue ? firstBranch : secondBranch;^615^^^^^594^620^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  branch ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( branch, n ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^618^^^^^594^620^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^606^^^^^597^608^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( thenStmt, n ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  thenStmt ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^601^^^^^586^616^parent.replaceChild ( n, thenStmt ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^606^^^^^591^621^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node branch = secondBranch ? firstBranch : condTrue;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node branch = condTrue ? secondBranch : firstBranch;^614^^^^^599^629^Node branch = condTrue ? firstBranch : secondBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node notBranch = secondBranch ? condTrue : firstBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^Node notBranch = condTrue ? firstBranch : secondBranch;^615^^^^^600^630^Node notBranch = condTrue ? secondBranch : firstBranch;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( branch, n ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  branch ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^618^^^^^603^633^parent.replaceChild ( n, branch ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldHookIf [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  changes  condTrue  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  branch  cond  elseBody  expr  firstBranch  ifNode  n  not  notBranch  notCond  parent  secondBranch  thenBody  thenStmt  int  AND_PRECEDENCE  OR_PRECEDENCE  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  newOperator ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( newOperator, n ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^650^^^^^627^653^parent.replaceChild ( n, newOperator ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeNot [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newOperator  notChild  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isPropertyAssignmentInExpression ( expr, t )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isPropertyAssignmentInExpression (  expr )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isPropertyAssignmentInExpression ( t )  )  {^666^^^^^651^681^if  ( isPropertyAssignmentInExpression ( t, expr )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( cond, t, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression (  cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, expr, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, cond.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t,  OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond, expr )  && isLowerPrecedenceInExpression ( t, OR_PRECEDENCE.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, OR_PRECEDENCE, cond )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node or = new Node ( Token.OR, expr.removeFirstChild (  ) , cond.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node or = new Node ( Token.OR.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) .removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node or = new Node ( Token. cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^681^682^^^^666^696^Node or = new Node ( Token.OR, cond.removeFirstChild (  ) , expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( OR_PRECEDENCE, expr.getFirstChild (  ) , t )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression (  expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t, OR_PRECEDENCE.getFirstChild (  ) , expr )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  )  )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( newExpr, n ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  newExpr ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^684^^^^^669^699^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( OR_PRECEDENCE, cond, t )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( expr, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression (  cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, AND_PRECEDENCE, cond )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t,  AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond, expr )  || isLowerPrecedenceInExpression ( t, AND_PRECEDENCE.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( AND_PRECEDENCE, cond, t )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, cond )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node and = new Node ( Token.AND, expr, cond.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node and = new Node ( Token.AND,  expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node and = new Node ( Token.AND, cond.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node and = new Node ( Token. cond, expr.removeFirstChild (  )  ) ;^699^^^^^684^714^Node and = new Node ( Token.AND, cond, expr.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( expr, t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^675^676^^^^660^690^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( cond, t, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( expr, t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression (  expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t.getFirstChild (  ) , AND_PRECEDENCE )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t, AND_PRECEDENCE.getFirstChild (  ) , expr )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  )  )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  newExpr ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( newExpr, n ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^701^^^^^686^716^parent.replaceChild ( n, newExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( t, expr, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, cond.getFirstChild (  ) , AND_PRECEDENCE )  )  {^691^692^693^^^676^706^if  ( isLowerPrecedenceInExpression ( t, cond, AND_PRECEDENCE )  || isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isLowerPrecedenceInExpression ( expr, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, t.getFirstChild (  ) , OR_PRECEDENCE )  )  {^674^675^676^^^659^689^if  ( isLowerPrecedenceInExpression ( t, cond, OR_PRECEDENCE )  && isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , OR_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^isLowerPrecedenceInExpression ( AND_PRECEDENCE, expr.getFirstChild (  ) , t )  )  {^692^693^^^^677^707^isLowerPrecedenceInExpression ( t, expr.getFirstChild (  ) , AND_PRECEDENCE )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^tryRemoveRepeatedStatements ( n, t ) ;^708^^^^^693^723^tryRemoveRepeatedStatements ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^tryRemoveRepeatedStatements (  n ) ;^708^^^^^693^723^tryRemoveRepeatedStatements ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^tryRemoveRepeatedStatements ( t ) ;^708^^^^^693^723^tryRemoveRepeatedStatements ( t, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^n.replaceChild (  cond.removeFirstChild (  )  ) ;^713^^^^^698^728^n.replaceChild ( cond, cond.removeFirstChild (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( isReturnExpressBlock ( elseBranch )  && isReturnExpressBlock ( thenBranch )  )  {^721^^^^^706^736^if  ( isReturnExpressBlock ( thenBranch )  && isReturnExpressBlock ( elseBranch )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node returnNode = new Node ( Token.RETURN ) ;^732^^^^^717^747^Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node returnNode = new Node ( Token. hookNode ) ;^732^^^^^717^747^Node returnNode = new Node ( Token.RETURN, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^731^^^^^716^746^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( returnNode, n ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  returnNode ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^733^^^^^718^748^parent.replaceChild ( n, returnNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( elseBranch && thenBranchIsExpressionBlockIsExpressionBlock )  {^741^^^^^726^756^if  ( thenBranchIsExpressionBlock && elseBranchIsExpressionBlock )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( elseOp.getType (  )  == thenOp.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( elseOphenOp.getType (  )  == t.getType (  )  )  {^744^^^^^729^759^if  ( thenOp.getType (  )  == elseOp.getType (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseOp, thenOp, cond ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenOp, cond, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseOp, thenOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenOp, elseOp ) ;^774^^^^^759^789^Node hookNode = new Node ( Token.HOOK, cond, thenOp, elseOp ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  expr ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( expr, n ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^776^^^^^761^791^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( hookNode.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) , hookNode, assignName ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) ,  hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) , assignName ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^761^762^^^^748^768^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( assignName.getType (  ) , thenOp, hookNode ) ;^763^764^^^^748^768^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  expr ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( hookNode.getType (  ) , assignName, thenOp ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) , hookNode, assignName ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) ,  hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( thenOp.getType (  ) , assignName ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^761^762^^^^746^776^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node assign = new Node ( assignName.getType (  ) , thenOp, hookNode ) ;^763^764^^^^748^778^Node assign = new Node ( thenOp.getType (  ) , assignName, hookNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( elseOp.checkTreeEqualsSilent ( lhs.getFirstChild (  )  )  &&^748^749^750^751^^733^763^if  ( lhs.checkTreeEqualsSilent ( elseOp.getFirstChild (  )  )  &&^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( expr, n ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  expr ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^766^^^^^751^781^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( expr, n ) ;^766^^^^^748^768^parent.replaceChild ( n, expr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^} else if  ( NodeUtil.isCall ( thenOphenOp )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^} else if  ( NodeUtil.isCall ( t )  )  {^769^^^^^754^784^} else if  ( NodeUtil.isCall ( thenOp )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( thenBranchhenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^787^788^^^^772^802^if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( elseBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^} else if  ( thenBranchIsExpressionBlock && elseBranchIsVar && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^} else if  ( thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^810^811^^^^795^825^} else if  ( elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign ( getBlockExpression ( thenBranch ) .getFirstChild (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( maybeName1.hasChildren (  ) && name2.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^810^831^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^825^^^^^810^831^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( var, n ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  var ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^828^^^^^810^831^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^&& name2.getString (  ) .equals ( maybeName1.getString (  )  )  )  {^821^^^^^810^831^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^819^830^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( var, n ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  var ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^828^^^^^819^830^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^825^^^^^810^840^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^&& name2.getString (  ) .equals ( maybeName1.getString (  )  )  )  {^821^^^^^806^836^&& maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( var, n ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  var ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^828^^^^^813^843^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^802^^^^^796^807^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  var ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, elseExpr, thenExpr, cond ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK,  thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, thenExpr, cond, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond,  elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, elseExpr, thenExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token.HOOK, cond, thenExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^Node hookNode = new Node ( Token. cond, thenExpr, elseExpr ) ;^802^^^^^787^817^Node hookNode = new Node ( Token.HOOK, cond, thenExpr, elseExpr ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^&& maybeName2.getString (  ) .equals ( name1.getString (  )  )  )  {^798^^^^^783^813^&& name1.getString (  ) .equals ( maybeName2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild (  var ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^805^^^^^790^820^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.replaceChild ( var, n ) ;^805^^^^^796^807^parent.replaceChild ( n, var ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( maybeName1.hasChildren (  ) && name2.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( name2ame2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( n.getString (  )  )  )  {^819^820^821^^^804^834^if  ( name2.hasChildren (  ) && maybeName1.getType (  )  == Token.NAME && maybeName1.getString (  ) .equals ( name2.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeIf [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  thenBranchIsExpressionBlock  thenBranchIsVar  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( lastFalse == null || lastTrue == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^875^876^^^^856^884^if  ( lastTrue == null || lastFalse == null || !lastTrue.checkTreeEqualsSilent ( lastFalse )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.addChildAfter ( n, lastTrue ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.addChildAfter (  n ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^parent.addChildAfter ( lastTrue ) ;^881^^^^^856^884^parent.addChildAfter ( lastTrue, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryRemoveRepeatedStatements [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  falseBranch  lastFalse  lastTrue  n  parent  trueBranch  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( n != resultull )  {^891^^^^^889^909^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( n.equals ( "undefined" )  )  {^902^^^^^889^909^if  ( name.equals ( "undefined" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^if  ( nameame.equals ( "undefined" )  )  {^902^^^^^889^909^if  ( name.equals ( "undefined" )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryReduceReturn [RETURN_TYPE] void   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  operand  result  String  name  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^914^923^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^new NodeTraversal ( t.getCompiler (  ) ew AbstractShallowCallback (  )  {^916^^^^^914^923^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^new NodeTraversal ( n.getCompiler (  ) , tew AbstractShallowCallback (  )  {^916^^^^^914^923^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isPropertyAssignmentInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  found  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  result  type  
[buglab_swap_variables]^new NodeTraversal ( n.getCompiler (  ) , tew AbstractShallowCallback (  )  {^932^^^^^929^938^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[buglab_swap_variables]^new NodeTraversal ( t.getCompiler (  ) ew AbstractShallowCallback (  )  {^932^^^^^929^938^new NodeTraversal ( t.getCompiler (  ) , new AbstractShallowCallback (  )  {^[CLASS] FoldConstants 1 2  [METHOD] isLowerPrecedenceInExpression [RETURN_TYPE] boolean   NodeTraversal t Node n final int precedence [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  boolean[]  lower  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[buglab_swap_variables]^lower[0] |= NodeUtil.precedence ( precedence.getType (  )  )  < n;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] FoldConstants 1 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  result  type  
[buglab_swap_variables]^if  ( parent == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( pt )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( n )  == parent )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^972^973^974^^^957^987^if  ( pt == Token.IF || pt == Token.WHILE || pt == Token.DO || ( pt == Token.FOR && NodeUtil.getConditionExpression ( parent )  == n )  || ( pt == Token.HOOK && parent.getFirstChild (  )  == n )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( type && lval == Token.OR || !lval && type == Token.AND )  {^953^954^^^^938^968^if  ( lval && type == Token.OR || !lval && type == Token.AND )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( rval == Token.OR && !rval || type == Token.AND && type )  {^979^980^^^^964^994^if  ( type == Token.OR && !rval || type == Token.AND && rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( n != resultull )  {^997^^^^^982^1012^if  ( result != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( result, n ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild (  result ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1000^^^^^985^1015^parent.replaceChild ( n, result ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  lval  rval  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  result  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( NodeUtil.isLiteralValue ( left )  && right.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^1020^1021^1022^^^1018^1043^if  ( NodeUtil.isLiteralValue ( right )  && left.getType (  )  == Token.ADD && left.getChildCount (  )  == 2 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( rightString != null && leftString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( nString != leftull && rightString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^String result = rightString + leftString;^1037^^^^^1018^1043^String result = leftString + rightString;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^n.replaceChild (  ll ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^n.replaceChild ( ll, left ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^n.replaceChild ( left ) ;^1038^^^^^1018^1043^n.replaceChild ( left, ll ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^n.replaceChild (  Node.newString ( result )  ) ;^1039^^^^^1018^1043^n.replaceChild ( right, Node.newString ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( rightStringString != null && left != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( leftString != rightull && nString != null )  {^1035^^^^^1018^1043^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^n.replaceChild ( result, Node.newString ( right )  ) ;^1039^^^^^1018^1043^n.replaceChild ( right, Node.newString ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLeftChildAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  ll  lr  n  parent  right  String  leftString  result  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( right.getType (  )  == Token.STRING || left.getType (  )  == Token.STRING )  {^1050^1051^^^^1048^1064^if  ( left.getType (  )  == Token.STRING || right.getType (  )  == Token.STRING )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( parent, n, left, right, t ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic (  n, left, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, parent, left, right, n ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t,  left, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, left, n, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n,  right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, right, left, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left,  parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, parent, right, left ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left, right ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( rightString != null && leftString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( n != leftStringull && rightString != null )  {^1056^^^^^1048^1064^if  ( leftString != null && rightString != null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild (  Node.newString ( leftString + rightString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( n, Node.newString ( rightString + leftString )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( rightString, Node.newString ( leftString + n )  ) ;^1057^^^^^1048^1064^parent.replaceChild ( n, Node.newString ( leftString + rightString )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( left, n, t, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( n, t, left, right, parent ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^tryFoldArithmetic ( t, n, left, parent, right ) ;^1062^^^^^1048^1064^tryFoldArithmetic ( t, n, left, right, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldAdd [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  n  parent  right  String  leftString  rightString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( right.getType (  )  == Token.NUMBER && left.getType (  )  == Token.NUMBER )  {^1072^1073^^^^1057^1087^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error ( DIVIDE_BY_0_ERROR, t, right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error (  DIVIDE_BY_0_ERROR, right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error ( t, right, DIVIDE_BY_0_ERROR ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error ( t, DIVIDE_BY_0_ERROR ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error ( t,  right ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( String.valueOf ( lval ) .length (  )  <= String.valueOf ( result ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( rval ) .length (  )  + String.valueOf ( lval ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( result )  ) ;^1102^^^^^1100^1104^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1102^^^^^1100^1104^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^result = rval + lval;^1080^^^^^1065^1095^result = lval + rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^result = rval - lval;^1083^^^^^1068^1098^result = lval - rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^result = rval * lval;^1086^^^^^1071^1101^result = lval * rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^result = rval / lval;^1093^^^^^1078^1108^result = lval / rval;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( result )  ) ;^1102^^^^^1087^1117^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^error ( right, DIVIDE_BY_0_ERROR, t ) ;^1090^^^^^1075^1105^error ( t, DIVIDE_BY_0_ERROR, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( String.valueOf ( rval ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( result ) .length (  )  + 1 )  {^1100^1101^^^^1085^1115^if  ( String.valueOf ( result ) .length (  )  <= String.valueOf ( lval ) .length (  )  + String.valueOf ( rval ) .length (  )  + 1 )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1102^^^^^1087^1117^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldArithmetic [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  newType  precedence  pt  result  type  
[buglab_swap_variables]^if  ( rval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || lval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^1122^1123^^^^1107^1137^if  ( lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE || rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( lval != lvalInt )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( lvalIntInt != lval )  {^1131^^^^^1116^1146^if  ( lvalInt != lval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( rval != rvalInt )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( rvalIntInt != rval )  {^1136^^^^^1121^1151^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^result = rvalInt & lvalInt;^1142^^^^^1127^1157^result = lvalInt & rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^result = rvalInt | lvalInt;^1145^^^^^1130^1160^result = lvalInt | rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( result )  ) ;^1150^^^^^1135^1165^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1150^^^^^1135^1165^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldBitAndOr [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( right.getType (  )  == Token.NUMBER && left.getType (  )  == Token.NUMBER )  {^1161^1162^^^^1146^1176^if  ( left.getType (  )  == Token.NUMBER && right.getType (  )  == Token.NUMBER )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( left, BITWISE_OPERAND_OUT_OF_RANGE, t ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error (  BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, left, BITWISE_OPERAND_OUT_OF_RANGE ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, BITWISE_OPERAND_OUT_OF_RANGE ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t,  left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( right, SHIFT_AMOUNT_OUT_OF_BOUNDS, t ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error (  SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( SHIFT_AMOUNT_OUT_OF_BOUNDS, t, right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t,  right ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( left, FRACTIONAL_BITWISE_OPERAND, t ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error (  FRACTIONAL_BITWISE_OPERAND, left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, left, FRACTIONAL_BITWISE_OPERAND ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, FRACTIONAL_BITWISE_OPERAND ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( FRACTIONAL_BITWISE_OPERAND, t, left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t,  left ) ;^1185^^^^^1170^1200^error ( t, FRACTIONAL_BITWISE_OPERAND, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( FRACTIONAL_BITWISE_OPERAND, t, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error (  FRACTIONAL_BITWISE_OPERAND, right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( right, FRACTIONAL_BITWISE_OPERAND, t ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, FRACTIONAL_BITWISE_OPERAND ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t,  right ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^result = rvalInt << lvalInt;^1197^^^^^1182^1212^result = lvalInt << rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^result = rvalInt >> lvalInt;^1200^^^^^1185^1215^result = lvalInt >> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^result = rvalInt >>> lvalInt;^1203^^^^^1188^1218^result = lvalInt >>> rvalInt;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( BITWISE_OPERAND_OUT_OF_RANGE, t, left ) ;^1171^^^^^1156^1186^error ( t, BITWISE_OPERAND_OUT_OF_RANGE, left ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, right, SHIFT_AMOUNT_OUT_OF_BOUNDS ) ;^1178^^^^^1163^1193^error ( t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^error ( t, right, FRACTIONAL_BITWISE_OPERAND ) ;^1191^^^^^1176^1206^error ( t, FRACTIONAL_BITWISE_OPERAND, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^parent.replaceChild (  Node.newNumber ( result )  ) ;^1209^^^^^1194^1224^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^parent.replaceChild ( result, Node.newNumber ( n )  ) ;^1209^^^^^1194^1224^parent.replaceChild ( n, Node.newNumber ( result )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^if  ( rvalIntInt != rval )  {^1190^^^^^1175^1205^if  ( rvalInt != rval )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldShift [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lval  result  rval  Node  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  precedence  pt  result  rvalInt  type  
[buglab_swap_variables]^boolean equivalent = nullRight || undefinedRight;^1240^^^^^1236^1264^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^boolean equivalent = nullRight || undefinedRight;^1240^^^^^1225^1255^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^boolean equivalent = nullRight || undefinedRight;^1351^^^^^1336^1366^boolean equivalent = undefinedRight || nullRight;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^result = right.getType (  )  == left.getType (  ) ;^1289^^^^^1274^1304^result = left.getType (  )  == right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^result = right.getType (  )  != left.getType (  ) ;^1293^^^^^1278^1308^result = left.getType (  )  != right.getType (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^result = right.getString (  ) .equals ( left.getString (  )  ) ;^1311^^^^^1296^1326^result = left.getString (  ) .equals ( right.getString (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.EQ: result = rv == lv; break;^1335^^^^^1320^1350^case Token.EQ: result = lv == rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.NE: result = rv != lv; break;^1336^^^^^1321^1351^case Token.NE: result = lv != rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.LE: result = rv <= lv; break;^1337^^^^^1322^1352^case Token.LE: result = lv <= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.LT: result = rv <  lv; break;^1338^^^^^1323^1353^case Token.LT: result = lv <  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.GE: result = rv >= lv; break;^1339^^^^^1324^1354^case Token.GE: result = lv >= rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^case Token.GT: result = rv >  lv; break;^1340^^^^^1325^1355^case Token.GT: result = lv >  rv; break;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1390^1420^parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( result, new Node ( n ? Token.TRUE : Token.FALSE )  ) ;^1405^1406^^^^1390^1420^parent.replaceChild ( n, new Node ( result ? Token.TRUE : Token.FALSE )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldComparison [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  equivalent  nullRight  result  rightLiteral  undefinedLeft  undefinedRight  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  lv  rv  Node  left  n  parent  right  String  ln  rn  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( !NodeUtil.isGetProp ( right )  || !NodeUtil.isImmutableValue ( left )  )  {^1417^^^^^1402^1432^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int fromIndex = lstring ? 0 : isIndexOf.length (  ) ;^1439^^^^^1424^1454^int fromIndex = isIndexOf ? 0 : lstring.length (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = lstring ? isIndexOf.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = isIndexOf ? searchValue.indexOf ( lstring, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = isIndexOf ? lstring.indexOf (  fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = fromIndex ? lstring.indexOf ( searchValue, isIndexOf ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = isIndexOf ? lstring.indexOf ( searchValue ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = isIndexOf ? lstring.indexOf ( fromIndex, searchValue ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^int indexVal = isIndexOf ? fromIndex.indexOf ( searchValue, lstring ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^1449^1450^^^^1434^1464^int indexVal = isIndexOf ? lstring.indexOf ( searchValue, fromIndex ) : lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^: searchValue.lastIndexOf ( lstring, fromIndex ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^: lstring.lastIndexOf (  fromIndex ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^: fromIndex.lastIndexOf ( searchValue, lstring ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^: lstring.lastIndexOf ( searchValue ) ;^1450^^^^^1435^1465^: lstring.lastIndexOf ( searchValue, fromIndex ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( newNode, n ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  newNode ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1452^^^^^1437^1467^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringIndexOf [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  isIndexOf  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  firstArg  functionName  left  lstringNode  n  newNode  parent  right  secondArg  String  lstring  searchValue  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  fromIndex  indexVal  intVal  lvalInt  newType  op  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( !NodeUtil.isGetProp ( right )  || !NodeUtil.isImmutableValue ( left )  )  {^1463^^^^^1448^1478^if  ( !NodeUtil.isGetProp ( left )  || !NodeUtil.isImmutableValue ( right )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( originalSize > foldedSize )  {^1517^^^^^1502^1532^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node replacement = new Node ( Token.ADD, Node.newString ( "" )  ) ;^1524^1525^^^^1509^1539^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node replacement = new Node ( Token. Node.newString ( "" ) , foldedStringNode ) ;^1524^1525^^^^1509^1539^Node replacement = new Node ( Token.ADD, Node.newString ( "" ) , foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( arrayNode.size (  )  == arrayFoldedChildren.getChildCount (  )  )  {^1533^^^^^1518^1548^if  ( arrayFoldedChildren.size (  )  == arrayNode.getChildCount (  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( originalSize > foldedSize )  {^1539^^^^^1524^1554^if  ( foldedSize > originalSize )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  emptyStringNode ) ;^1512^^^^^1497^1527^parent.replaceChild ( n, emptyStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1512^^^^^1497^1527^parent.replaceChild ( n, emptyStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( foldedStringNode, n ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  foldedStringNode ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1528^^^^^1513^1543^parent.replaceChild ( n, foldedStringNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldStringJoin [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  List  arrayFoldedChildren  String  joinString  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  indexVal  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( index, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( t )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make (  right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, INVALID_GETELEM_INDEX_ERROR, right, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t,  INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, right, index, String.valueOf ( INVALID_GETELEM_INDEX_ERROR )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, right,  String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( INVALID_GETELEM_INDEX_ERROR, right, t, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, index, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( right )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( n, t, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make (  n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, INDEX_OUT_OF_BOUNDS_ERROR, n, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t,  INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( intIndex, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( t )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, n,  String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, intIndex, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( n )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( n == elemull )  {^1583^^^^^1568^1598^if  ( elem == null )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( INDEX_OUT_OF_BOUNDS_ERROR, n, t, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make (  n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, INDEX_OUT_OF_BOUNDS_ERROR, n, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t,  INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( intIndex, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( t )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, n,  String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( n, t, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, intIndex, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( n )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, n, intIndex, String.valueOf ( INDEX_OUT_OF_BOUNDS_ERROR )  )  ) ;^1584^1585^^^^1569^1599^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( int i = 0; intIndex != null && i < elem; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( intIndexnt i = 0; elem != null && i < i; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( right, t, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^1567^1568^^^^1552^1582^t.getCompiler (  ) .report ( JSError.make ( t, right, INVALID_GETELEM_INDEX_ERROR, String.valueOf ( index )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( t, n, intIndex, String.valueOf ( INDEX_OUT_OF_BOUNDS_ERROR )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  elem ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( elem, n ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1591^^^^^1576^1606^parent.replaceChild ( n, elem ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( index != intIndex )  {^1566^^^^^1551^1581^if  ( intIndex != index )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^t.getCompiler (  ) .report ( JSError.make ( INDEX_OUT_OF_BOUNDS_ERROR, n, t, String.valueOf ( intIndex )  )  ) ;^1573^1574^^^^1558^1588^t.getCompiler (  ) .report ( JSError.make ( t, n, INDEX_OUT_OF_BOUNDS_ERROR, String.valueOf ( intIndex )  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( elemnt i = 0; i != null && i < intIndex; i++ )  {^1579^^^^^1564^1594^for  ( int i = 0; elem != null && i < intIndex; i++ )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetElem [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  double  index  Node  elem  left  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  lengthNode ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( lengthNode, n ) ;^1622^^^^^1600^1625^parent.replaceChild ( n, lengthNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldGetProp [RETURN_TYPE] void   NodeTraversal t Node n Node left Node right Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  left  lengthNode  n  parent  right  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( null == flags ||  ( null != pattern && null != flags.getNext (  )  )  )  {^1636^^^^^1621^1651^if  ( null == pattern ||  ( null != flags && null != flags.getNext (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( flagsull == n || "".equals ( flags.getString (  )  )  )  {^1660^^^^^1645^1675^if  ( null == flags || "".equals ( flags.getString (  )  )  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( flags, INVALID_REGULAR_EXPRESSION_FLAGS, t ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error (  INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t, flags, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( INVALID_REGULAR_EXPRESSION_FLAGS, t, flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t,  flags ) ;^1666^^^^^1660^1674^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP, flags, pattern ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP,  flags ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token. pattern, flags ) ;^1673^^^^^1660^1674^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP ) ;^1662^^^^^1647^1677^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token. pattern ) ;^1662^^^^^1647^1677^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( flags, INVALID_REGULAR_EXPRESSION_FLAGS, t ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error (  INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t, flags, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( INVALID_REGULAR_EXPRESSION_FLAGS, t, flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^error ( t,  flags ) ;^1666^^^^^1651^1681^error ( t, INVALID_REGULAR_EXPRESSION_FLAGS, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP,  flags ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP, flags, pattern ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token.REGEXP, pattern ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^regexLiteral = new Node ( Token. pattern, flags ) ;^1673^^^^^1658^1688^regexLiteral = new Node ( Token.REGEXP, pattern, flags ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  regexLiteral ) ;^1676^^^^^1661^1691^parent.replaceChild ( n, regexLiteral ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( regexLiteral, n ) ;^1676^^^^^1661^1691^parent.replaceChild ( n, regexLiteral ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1676^^^^^1661^1691^parent.replaceChild ( n, regexLiteral ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldRegularExpressionConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  constructor  flags  n  parent  pattern  regexLiteral  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^return flags.matcher ( REGEXP_FLAGS_RE ) .matches (  ) ;^1691^^^^^1690^1692^return REGEXP_FLAGS_RE.matcher ( flags ) .matches (  ) ;^[CLASS] FoldConstants 1 2  [METHOD] areValidRegexpFlags [RETURN_TYPE] boolean   String flags [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  flags  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( null == s )  { sbb = new StringBuilder ( s.length (  )  + 16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( null == sbb )  { s = new StringBuilder ( s.length (  )  + 16 ) ; }^1720^^^^^1709^1732^if  ( null == sb )  { sb = new StringBuilder ( s.length (  )  + 16 ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^switch  ( i.charAt ( s )  )  {^1715^^^^^1709^1732^switch  ( s.charAt ( i )  )  {^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( i, pos, s ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append (  pos, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( s, i, pos ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( s,  i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( s, pos ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( pos, s, i ) .append ( '\\' ) ;^1721^^^^^1709^1732^sb.append ( s, pos, i ) .append ( '\\' ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^if  ( sbull == n )  { return n.cloneTree (  ) ; }^1728^^^^^1709^1732^if  ( null == sb )  { return n.cloneTree (  ) ; }^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( pos, s, s.length (  )  ) ;^1730^^^^^1709^1732^sb.append ( s, pos, s.length (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append (  pos, s.length (  )  ) ;^1730^^^^^1709^1732^sb.append ( s, pos, s.length (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^sb.append ( s,  s.length (  )  ) ;^1730^^^^^1709^1732^sb.append ( s, pos, s.length (  )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] makeForwardSlashBracketSafe [RETURN_TYPE] Node   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  StringBuilder  sb  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  String  s  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Scope.Var var = className.getScope (  ) .getVar ( t ) ;^1746^^^^^1743^1754^Scope.Var var = t.getScope (  ) .getVar ( className ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( literalNode, n ) ;^1752^^^^^1743^1754^parent.replaceChild ( n, literalNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  literalNode ) ;^1752^^^^^1743^1754^parent.replaceChild ( n, literalNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1752^^^^^1743^1754^parent.replaceChild ( n, literalNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldLiteralConstructor [RETURN_TYPE] void   NodeTraversal t Node n Node parent String className int type [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Var  var  Node  literalNode  n  parent  String  className  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^while  ( nSlashes - i > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^while  ( esc - nSlashes > 0 && '\\' == i.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( escnt i = -1;  ( i = i.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( int i = -1;  ( i = esc.indexOf ( "\\u" + 1 )  )  >= 0; )  {^1762^^^^^1760^1772^for  ( int i = -1;  ( i = esc.indexOf ( "\\u", i + 1 )  )  >= 0; )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^while  ( i - esc > 0 && '\\' == nSlashes.charAt ( i - nSlashes - 1 )  )  {^1764^^^^^1760^1772^while  ( i - nSlashes > 0 && '\\' == esc.charAt ( i - nSlashes - 1 )  )  {^[CLASS] FoldConstants 1 2  [METHOD] containsUnicodeEscape [RETURN_TYPE] boolean   String s [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  String  esc  s  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^1784^^^^^1777^1786^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldWhile [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild ( n, parent ) ;^1803^^^^^1791^1805^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild (  n ) ;^1803^^^^^1791^1805^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^NodeUtil.removeChild ( parent ) ;^1803^^^^^1791^1805^NodeUtil.removeChild ( parent, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldFor [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( block, n ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  block ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1830^^^^^1812^1832^parent.replaceChild ( n, block ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldDo [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  block  cond  n  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^return NodeUtil.has (  Predicates.<Node>or ( new NodeUtil.MatchNodeType ( Token.BREAK ) ,^1841^1842^1843^1844^^1837^1847^return NodeUtil.has ( n, Predicates.<Node>or ( new NodeUtil.MatchNodeType ( Token.BREAK ) ,^[CLASS] FoldConstants 1 2  [METHOD] hasBreakOrContinue [RETURN_TYPE] boolean   Node n [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  
[buglab_swap_variables]^if  ( rightParent.getType (  )  != Token.NOT || leftParent.getType (  )  != Token.NOT )  {^1881^1882^^^^1866^1896^if  ( leftParent.getType (  )  != Token.NOT || rightParent.getType (  )  != Token.NOT )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( equivalentResult, n, parent, t ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber (  n, parent, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( n, t, parent, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( t,  parent, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( t, parent, n, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( t, n,  equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( t, n, parent ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node ( left, newOp, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node (  left, right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node ( newOp, right, left ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node ( newOp,  right ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node ( newOp, left ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^Node newRoot = new Node ( right, left, newOp ) ;^1890^^^^^1875^1905^Node newRoot = new Node ( newOp, left, right ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( newRoot, n ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  newRoot ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1869^^^^^1854^1884^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( n, t, parent ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition (  n, parent ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t,  parent ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t, parent, n ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t, n ) ;^1874^^^^^1859^1889^tryMinimizeCondition ( t, n, parent ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  newRoot ) ;^1891^^^^^1876^1906^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1891^^^^^1876^1906^parent.replaceChild ( n, newRoot ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^maybeReplaceChildWithNumber ( parent, n, t, equivalentResult ) ;^1913^^^^^1898^1928^maybeReplaceChildWithNumber ( t, n, parent, equivalentResult ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^for  ( Node n = c.getFirstChild (  ) ; c != null;  )  {^1919^^^^^1904^1934^for  ( Node c = n.getFirstChild (  ) ; c != null;  )  {^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( c, t, n ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition (  c, n ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t, n, c ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t,  n ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( n, c, t ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^tryMinimizeCondition ( t, c ) ;^1921^^^^^1906^1936^tryMinimizeCondition ( t, c, n ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryMinimizeCondition [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  c  first  left  leftParent  n  newRoot  next  parent  right  rightParent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  new Node ( Token.EMPTY )  ) ;^1933^^^^^1929^1937^parent.replaceChild ( n, new Node ( Token.EMPTY )  ) ;^[CLASS] FoldConstants 1 2  [METHOD] tryFoldForCondition [RETURN_TYPE] void   Node n Node parent [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  result  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  Node  n  parent  
[buglab_swap_variables]^parent.replaceChild ( newNode, n ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild (  newNode ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^parent.replaceChild ( n ) ;^1947^^^^^1943^1950^parent.replaceChild ( n, newNode ) ;^[CLASS] FoldConstants 1 2  [METHOD] maybeReplaceChildWithNumber [RETURN_TYPE] void   NodeTraversal t Node n Node parent int num [VARIABLES] Pattern  REGEXP_FLAGS_RE  AbstractCompiler  compiler  boolean  NodeTraversal  t  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  diagnostic  Node  n  newNode  parent  int  AND_PRECEDENCE  OR_PRECEDENCE  complementOperator  equivalentResult  foldedSize  fromIndex  i  indexVal  intIndex  intVal  kJoinOverhead  knownLength  lvalInt  nSlashes  newOp  newType  num  op  originalSize  pos  precedence  pt  result  rvalInt  tt  type  
[buglab_swap_variables]^found[0] |=  ( parent.getType (  )  == Token.GETPROP && n.getType (  )  == Token.ASSIGN ) ;^918^919^^^^917^920^found[0] |=  ( n.getType (  )  == Token.GETPROP && parent.getType (  )  == Token.ASSIGN ) ;^[CLASS] 1  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
[buglab_swap_variables]^lower[0] |= NodeUtil.precedence ( precedence.getType (  )  )  < n;^934^^^^^933^935^lower[0] |= NodeUtil.precedence ( n.getType (  )  )  < precedence;^[CLASS] 2  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  
