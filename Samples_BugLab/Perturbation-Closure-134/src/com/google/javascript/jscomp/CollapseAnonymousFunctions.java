[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, new Callback (  )  ) ;^50^^^^^49^51^NodeTraversal.traverse ( compiler, root, new Callback (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Node  externs  root  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( root, compiler, new Callback (  )  ) ;^50^^^^^49^51^NodeTraversal.traverse ( compiler, root, new Callback (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Node  externs  root  boolean  
[BugLab_Variable_Misuse]^if  ( value.getType (  )  != Token.VAR )  {^56^^^^^41^71^if  ( n.getType (  )  != Token.VAR )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  == Token.VAR )  {^56^^^^^41^71^if  ( n.getType (  )  != Token.VAR )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  != Token.VAR )  {^56^^^^^41^71^if  ( n.getType (  )  != Token.VAR )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node grandparent = value.getParent (  ) ;^66^^^^^51^81^Node grandparent = parent.getParent (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( ! ( value.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || value != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^if  ( ! ( grandparent.getType (  )  == Token.SCRIPT || parent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT && grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  != Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null || grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent == null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Preconditions.checkState ( parent.hasOneChild (  )  ) ;^76^^^^^61^91^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node valueame = n.getFirstChild (  ) ;^77^^^^^62^92^Node name = n.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node value = parent.getFirstChild (  ) ;^78^^^^^63^93^Node value = name.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node value = value.getFirstChild (  ) ;^78^^^^^63^93^Node value = name.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( parent != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( value != valueull && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^if  ( n != valueull && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value != null || value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value == null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value != null && value.getType (  )  != Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = parent.getFirstChild (  ) ;^82^^^^^79^88^Node fnName = value.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = name.getFirstChild (  ) ;^82^^^^^79^88^Node fnName = value.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^fnName.setString ( value.getString (  )  ) ;^83^^^^^79^88^fnName.setString ( name.getString (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^NodeUtil.copyNameAnnotations ( value, fnName ) ;^84^^^^^79^88^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^NodeUtil.copyNameAnnotations ( fnName, name ) ;^84^^^^^79^88^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, value ) ;^86^^^^^79^88^parent.replaceChild ( n, value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name ) ;^86^^^^^79^88^parent.replaceChild ( n, value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^parent.replaceChild ( value, n ) ;^86^^^^^79^88^parent.replaceChild ( n, value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^!isRecursiveFunction ( parent )  )  {^81^^^^^66^96^!isRecursiveFunction ( value )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = parent.getFirstChild (  ) ;^82^^^^^67^97^Node fnName = value.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^fnName.setString ( value.getString (  )  ) ;^83^^^^^68^98^fnName.setString ( name.getString (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^NodeUtil.copyNameAnnotations ( value, fnName ) ;^84^^^^^69^99^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^NodeUtil.copyNameAnnotations ( fnName, name ) ;^84^^^^^69^99^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^name.removeChild ( parent ) ;^85^^^^^70^100^name.removeChild ( value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, value ) ;^86^^^^^71^101^parent.replaceChild ( n, value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, parent ) ;^86^^^^^71^101^parent.replaceChild ( n, value ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node name = name.getFirstChild (  ) ;^92^^^^^91^99^Node name = function.getFirstChild (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^if  ( function.getString (  ) .isEmpty (  )  )  {^93^^^^^91^99^if  ( name.getString (  ) .isEmpty (  )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Wrong_Literal]^return true;^94^^^^^91^99^return false;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^Node args = function.getNext (  ) ;^96^^^^^91^99^Node args = name.getNext (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^Node body = name.getNext (  ) ;^97^^^^^91^99^Node body = args.getNext (  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^return containsName ( function, name.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^return containsName ( body, function.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Argument_Swapping]^return containsName ( name, body.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] AbstractCompiler  compiler  Node  args  body  function  name  boolean  
[BugLab_Variable_Misuse]^if  ( child.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Argument_Swapping]^if  ( name.getType (  )  == Token.NAME && n.getString (  ) .equals ( n )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  == Token.NAME || n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  != Token.NAME && n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Wrong_Literal]^return false;^103^^^^^101^112^return true;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Variable_Misuse]^if  ( containsName ( n, name )  )  {^107^^^^^101^112^if  ( containsName ( child, name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Argument_Swapping]^if  ( containsName ( name, child )  )  {^107^^^^^101^112^if  ( containsName ( child, name )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Wrong_Literal]^return false;^108^^^^^101^112^return true;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Variable_Misuse]^for  ( Node child : child.children (  )  )  {^106^^^^^101^112^for  ( Node child : n.children (  )  )  {^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Wrong_Literal]^return true;^111^^^^^101^112^return false;^[CLASS] CollapseAnonymousFunctions Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] AbstractCompiler  compiler  String  name  boolean  Node  child  n  
[BugLab_Variable_Misuse]^if  ( value.getType (  )  != Token.VAR )  {^56^^^^^41^71^if  ( n.getType (  )  != Token.VAR )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  <= Token.VAR )  {^56^^^^^41^71^if  ( n.getType (  )  != Token.VAR )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node grandparent = value.getParent (  ) ;^66^^^^^51^81^Node grandparent = parent.getParent (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( ! ( value.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || value != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^if  ( ! ( grandparent.getType (  )  == Token.SCRIPT || parent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT && grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  != Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null || grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent == null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^67^68^69^70^^52^82^if  ( ! ( parent.getType (  )  == Token.SCRIPT || grandparent != null && grandparent.getType (  )  == Token.FUNCTION && parent.getType (  )  == Token.BLOCK )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Preconditions.checkState ( value.hasOneChild (  )  ) ;^76^^^^^61^91^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node valueame = n.getFirstChild (  ) ;^77^^^^^62^92^Node name = n.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node parentame = n.getFirstChild (  ) ;^77^^^^^62^92^Node name = n.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node value = parent.getFirstChild (  ) ;^78^^^^^63^93^Node value = name.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( parent != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^if  ( value != valueull && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value != null || value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value == null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Wrong_Operator]^if  ( value != null && value.getType (  )  != Token.FUNCTION && !isRecursiveFunction ( value )  )  {^79^80^81^^^64^94^if  ( value != null && value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = parent.getFirstChild (  ) ;^82^^^^^79^88^Node fnName = value.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = name.getFirstChild (  ) ;^82^^^^^79^88^Node fnName = value.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^fnName.setString ( value.getString (  )  ) ;^83^^^^^79^88^fnName.setString ( name.getString (  )  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^NodeUtil.copyNameAnnotations ( value, fnName ) ;^84^^^^^79^88^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^NodeUtil.copyNameAnnotations ( name, value ) ;^84^^^^^79^88^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^NodeUtil.copyNameAnnotations ( fnName, name ) ;^84^^^^^79^88^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^name.removeChild ( parent ) ;^85^^^^^79^88^name.removeChild ( value ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name ) ;^86^^^^^79^88^parent.replaceChild ( n, value ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = parent.getFirstChild (  ) ;^82^^^^^67^97^Node fnName = value.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( parent )  )  {^80^81^^^^65^95^value.getType (  )  == Token.FUNCTION && !isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^!isRecursiveFunction ( parent )  )  {^81^^^^^66^96^!isRecursiveFunction ( value )  )  {^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node fnName = name.getFirstChild (  ) ;^82^^^^^67^97^Node fnName = value.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^fnName.setString ( value.getString (  )  ) ;^83^^^^^68^98^fnName.setString ( name.getString (  )  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^fnName.setString ( parent.getString (  )  ) ;^83^^^^^68^98^fnName.setString ( name.getString (  )  ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^NodeUtil.copyNameAnnotations ( name, value ) ;^84^^^^^69^99^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Argument_Swapping]^NodeUtil.copyNameAnnotations ( fnName, name ) ;^84^^^^^69^99^NodeUtil.copyNameAnnotations ( name, fnName ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^name.removeChild ( parent ) ;^85^^^^^70^100^name.removeChild ( value ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( parent, value ) ;^86^^^^^71^101^parent.replaceChild ( n, value ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^parent.replaceChild ( n, name ) ;^86^^^^^71^101^parent.replaceChild ( n, value ) ;^[CLASS] Callback  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  fnName  grandparent  n  name  parent  value  
[BugLab_Variable_Misuse]^Node name = body.getFirstChild (  ) ;^92^^^^^91^99^Node name = function.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^Node name = name.getFirstChild (  ) ;^92^^^^^91^99^Node name = function.getFirstChild (  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^if  ( function.getString (  ) .isEmpty (  )  )  {^93^^^^^91^99^if  ( name.getString (  ) .isEmpty (  )  )  {^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Wrong_Literal]^return true;^94^^^^^91^99^return false;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^Node args = function.getNext (  ) ;^96^^^^^91^99^Node args = name.getNext (  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^return containsName ( function, name.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^return containsName ( body, function.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Argument_Swapping]^return containsName ( name, body.getString (  )  ) ;^98^^^^^91^99^return containsName ( body, name.getString (  )  ) ;^[CLASS] Callback  [METHOD] isRecursiveFunction [RETURN_TYPE] boolean   Node function [VARIABLES] boolean  Node  args  body  function  name  
[BugLab_Variable_Misuse]^if  ( child.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Argument_Swapping]^if  ( name.getType (  )  == Token.NAME && n.getString (  ) .equals ( n )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  == Token.NAME || n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  <= Token.NAME && n.getString (  ) .equals ( name )  )  {^102^^^^^101^112^if  ( n.getType (  )  == Token.NAME && n.getString (  ) .equals ( name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Wrong_Literal]^return false;^103^^^^^101^112^return true;^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Variable_Misuse]^if  ( containsName ( n, name )  )  {^107^^^^^101^112^if  ( containsName ( child, name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Argument_Swapping]^if  ( containsName ( name, child )  )  {^107^^^^^101^112^if  ( containsName ( child, name )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Wrong_Literal]^return false;^108^^^^^101^112^return true;^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Variable_Misuse]^for  ( Node child : child.children (  )  )  {^106^^^^^101^112^for  ( Node child : n.children (  )  )  {^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
[BugLab_Wrong_Literal]^return true;^111^^^^^101^112^return false;^[CLASS] Callback  [METHOD] containsName [RETURN_TYPE] boolean   Node n String name [VARIABLES] boolean  Node  child  n  String  name  
