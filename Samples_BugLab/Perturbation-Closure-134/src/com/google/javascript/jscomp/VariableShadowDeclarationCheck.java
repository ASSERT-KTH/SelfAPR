[BugLab_Wrong_Operator]^static final DiagnosticType SHADOW_VAR_ERROR = DiagnosticType.error ( "JSC_REDECL_NOSHADOW_VARIABLE", "Highly error prone shadowing of variable name {0}."   instanceof   "Consider using a different local variable name." ) ;^40^41^42^43^^40^43^static final DiagnosticType SHADOW_VAR_ERROR = DiagnosticType.error ( "JSC_REDECL_NOSHADOW_VARIABLE", "Highly error prone shadowing of variable name {0}." + "Consider using a different local variable name." ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback   [VARIABLES] 
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, root, new NoShadowAnnotationGatheringCallback (  )  ) ;^59^60^^^^58^63^NodeTraversal.traverse ( compiler, externs, new NoShadowAnnotationGatheringCallback (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  externs  root  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( externs, compiler, new NoShadowAnnotationGatheringCallback (  )  ) ;^59^60^^^^58^63^NodeTraversal.traverse ( compiler, externs, new NoShadowAnnotationGatheringCallback (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  externs  root  
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, new ShadowDeclarationCheckingCallback (  )  ) ;^61^62^^^^58^63^NodeTraversal.traverse ( compiler, root, new ShadowDeclarationCheckingCallback (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  externs  root  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( root, compiler, new ShadowDeclarationCheckingCallback (  )  ) ;^61^62^^^^58^63^NodeTraversal.traverse ( compiler, root, new ShadowDeclarationCheckingCallback (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  externs  root  
[BugLab_Variable_Misuse]^for  ( Iterator<Var> 0 = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^73^^^^^71^79^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  var  Iterator  vars  
[BugLab_Argument_Swapping]^for  ( Iterator<Var> scopes = var.getVars (  ) ; vars.hasNext (  ) ; )  {^73^^^^^71^79^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  var  Iterator  vars  
[BugLab_Argument_Swapping]^for  ( Iterator<Var> var = scope.getVars (  ) ; varss.hasNext (  ) ; )  {^73^^^^^71^79^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  var  Iterator  vars  
[BugLab_Wrong_Literal]^return false;^88^^^^^86^89^return true;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] shouldTraverse [RETURN_TYPE] boolean   NodeTraversal nodeTraversal Node n Node parent [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  NodeTraversal  nodeTraversal  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  n  parent  
[BugLab_Variable_Misuse]^Scope parentScope = parentScope.getParent (  ) ;^108^^^^^102^128^Scope parentScope = scope.getParent (  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar != null )  || ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar == null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  && shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var shadowedVar = scope.getVar ( var.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Argument_Swapping]^Var shadowedVar = var.getVar ( parentScope.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^if  ( externalNoShadowVariableNames.contains ( shadowedVar.getName (  )  )  )  {^112^^^^^102^128^if  ( externalNoShadowVariableNames.contains ( var.getName (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Argument_Swapping]^if  ( var.contains ( externalNoShadowVariableNames.getName (  )  )  )  {^112^^^^^102^128^if  ( externalNoShadowVariableNames.contains ( var.getName (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var shadowedVar = parentScope.getVar ( shadowedVar.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^( var.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^121^^^^^102^128^( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^for  ( Iterator<Var> vars = parentScope.getVars (  ) ; vars.hasNext (  ) ; )  {^109^^^^^102^128^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  Scope  parentScope  scope  NodeTraversal  t  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Literal]^return false;^137^^^^^135^138^return true;^[CLASS] VariableShadowDeclarationCheck NoShadowAnnotationGatheringCallback ShadowDeclarationCheckingCallback  [METHOD] shouldTraverse [RETURN_TYPE] boolean   NodeTraversal nodeTraversal Node n Node parent [VARIABLES] AbstractCompiler  compiler  Set  externalNoShadowVariableNames  boolean  NodeTraversal  nodeTraversal  DiagnosticType  SHADOW_VAR_ERROR  CheckLevel  checkLevel  Node  n  parent  
[BugLab_Argument_Swapping]^for  ( Iterator<Var> scopes = var.getVars (  ) ; vars.hasNext (  ) ; )  {^73^^^^^71^79^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] NoShadowAnnotationGatheringCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  scope  NodeTraversal  t  Var  var  Iterator  vars  
[BugLab_Argument_Swapping]^for  ( Iterator<Var> scope = vars.getVars (  ) ; vars.hasNext (  ) ; )  {^73^^^^^71^79^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] NoShadowAnnotationGatheringCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  scope  NodeTraversal  t  Var  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var var = 2.next (  ) ;^74^^^^^71^79^Var var = vars.next (  ) ;^[CLASS] NoShadowAnnotationGatheringCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  scope  NodeTraversal  t  Var  var  Iterator  vars  
[BugLab_Wrong_Literal]^return false;^88^^^^^86^89^return true;^[CLASS] NoShadowAnnotationGatheringCallback  [METHOD] shouldTraverse [RETURN_TYPE] boolean   NodeTraversal nodeTraversal Node n Node parent [VARIABLES] boolean  NodeTraversal  nodeTraversal  Node  n  parent  
[BugLab_Variable_Misuse]^Scope parentScope = parentScope.getParent (  ) ;^108^^^^^102^128^Scope parentScope = scope.getParent (  ) ;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar != null )  || ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar == null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Operator]^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  && shadowedVar.isLocal (  )  )  )  {^120^121^^^^102^128^if  (  ( shadowedVar != null )  && ( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var var = 3.next (  ) ;^110^^^^^102^128^Var var = vars.next (  ) ;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var shadowedVar = scope.getVar ( var.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Argument_Swapping]^Var shadowedVar = var.getVar ( parentScope.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^if  ( externalNoShadowVariableNames.contains ( shadowedVar.getName (  )  )  )  {^112^^^^^102^128^if  ( externalNoShadowVariableNames.contains ( var.getName (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^if  ( 4.contains ( var.getName (  )  )  )  {^112^^^^^102^128^if  ( externalNoShadowVariableNames.contains ( var.getName (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Argument_Swapping]^if  ( var.contains ( externalNoShadowVariableNames.getName (  )  )  )  {^112^^^^^102^128^if  ( externalNoShadowVariableNames.contains ( var.getName (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^Var shadowedVar = parentScope.getVar ( shadowedVar.getName (  )  ) ;^119^^^^^102^128^Var shadowedVar = parentScope.getVar ( var.getName (  )  ) ;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^( var.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^121^^^^^102^128^( shadowedVar.isNoShadow (  )  || shadowedVar.isLocal (  )  )  )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Variable_Misuse]^for  ( Iterator<Var> vars = parentScope.getVars (  ) ; vars.hasNext (  ) ; )  {^109^^^^^102^128^for  ( Iterator<Var> vars = scope.getVars (  ) ; vars.hasNext (  ) ; )  {^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] enterScope [RETURN_TYPE] void   NodeTraversal t [VARIABLES] boolean  Scope  parentScope  scope  NodeTraversal  t  Var  shadowedVar  var  Iterator  vars  
[BugLab_Wrong_Literal]^return false;^137^^^^^135^138^return true;^[CLASS] ShadowDeclarationCheckingCallback  [METHOD] shouldTraverse [RETURN_TYPE] boolean   NodeTraversal nodeTraversal Node n Node parent [VARIABLES] boolean  NodeTraversal  nodeTraversal  Node  n  parent  
