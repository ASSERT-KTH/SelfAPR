[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( 2 ) ;^62^^^^^56^66^Preconditions.checkNotNull ( constNames ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] <init> [RETURN_TYPE] Set)   AbstractCompiler compiler String> safeNameIdSupplier String> constNames [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  
[BugLab_Variable_Misuse]^while  ( DecompositionType.DECOMPOSABLE == canExposeExpression ( extractBeforeStatement )  )  {^78^^^^^75^86^while  ( DecompositionType.DECOMPOSABLE == canExposeExpression ( expression )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^while  ( DecompositionType.UNDECOMPOSABLE == canExposeExpression ( expression )  )  {^78^^^^^75^86^while  ( DecompositionType.DECOMPOSABLE == canExposeExpression ( expression )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^while  ( DecompositionType.DECOMPOSABLE >= canExposeExpression ( expression )  )  {^78^^^^^75^86^while  ( DecompositionType.DECOMPOSABLE == canExposeExpression ( expression )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^if  ( MAX_INTERATIONS > MAX_INTERATIONS )  {^80^^^^^75^86^if  ( i > MAX_INTERATIONS )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^if  ( i > i )  {^80^^^^^75^86^if  ( i > MAX_INTERATIONS )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Argument_Swapping]^if  ( MAX_INTERATIONS > i )  {^80^^^^^75^86^if  ( i > MAX_INTERATIONS )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^if  ( i >= MAX_INTERATIONS )  {^80^^^^^75^86^if  ( i > MAX_INTERATIONS )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + extractBeforeStatement.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  &  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  <<  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  >  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  &&  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^exposeExpression ( extractBeforeStatement ) ;^79^^^^^75^86^exposeExpression ( expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^if  ( i == MAX_INTERATIONS )  {^80^^^^^75^86^if  ( i > MAX_INTERATIONS )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  <  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n"  <=  expression.toStringTree (  )  ) ;^81^82^83^^^75^86^throw new IllegalStateException ( "DecomposeExpression depth exceeded on :\n" + expression.toStringTree (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeDecomposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node extractBeforeStatementRoot = findExpressionRoot ( expression ) ;^94^^^^^93^98^Node expressionRoot = findExpressionRoot ( expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Wrong_Operator]^Preconditions.checkState ( expressionRoot == null ) ;^95^^^^^93^98^Preconditions.checkState ( expressionRoot != null ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^exposeExpression ( extractBeforeStatement, expression ) ;^96^^^^^93^98^exposeExpression ( expressionRoot, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^exposeExpression ( extractBeforeStatementRoot, expression ) ;^96^^^^^93^98^exposeExpression ( expressionRoot, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Argument_Swapping]^exposeExpression ( expression, expressionRoot ) ;^96^^^^^93^98^exposeExpression ( expressionRoot, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Argument_Swapping]^exposeExpression ( expressionRootRoot, expression ) ;^96^^^^^93^98^exposeExpression ( expressionRoot, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionRoot  extractBeforeStatement  Supplier  safeNameIdSupplier  String  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node injectionPoint = findInjectionPoint ( newExpressionRoot ) ;^110^^^^^108^125^Node injectionPoint = findInjectionPoint ( expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node injectionPoint = findInjectionPoint ( injectionPointParent ) ;^110^^^^^108^125^Node injectionPoint = findInjectionPoint ( expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( newExpressionRoot ) ;^111^^^^^108^125^Preconditions.checkNotNull ( injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node extractBeforeStatementParent = injectionPoint.getParent (  ) ;^112^^^^^108^125^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node newExpressionRootParent = injectionPoint.getParent (  ) ;^112^^^^^108^125^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( newExpressionRoot ) ;^113^^^^^108^125^Preconditions.checkNotNull ( injectionPointParent ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isStatementBlock ( newExpressionRoot )  ) ;^114^^^^^108^125^Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isStatementBlock ( extractBeforeStatement )  ) ;^114^^^^^108^125^Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPointParent )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node injectionPointParentParent = expression.getParent (  ) ;^117^^^^^108^125^Node expressionParent = expression.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node newExpressionRootParent = expression.getParent (  ) ;^117^^^^^108^125^Node expressionParent = expression.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^expressionParent.replaceChild ( newExpressionRoot, Node.newString ( Token.NAME, resultName )  ) ;^118^119^^^^108^125^expressionParent.replaceChild ( expression, Node.newString ( Token.NAME, resultName )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^expressionParent.replaceChild ( expression, Node.newString ( Token.NAME, tempNamePrefix )  ) ;^118^119^^^^108^125^expressionParent.replaceChild ( expression, Node.newString ( Token.NAME, resultName )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^expression, Node.newString ( Token.NAME, tempNamePrefix )  ) ;^119^^^^^108^125^expression, Node.newString ( Token.NAME, resultName )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node newExpressionRoot = NodeUtil.newVarNode ( tempNamePrefix, expression ) ;^122^^^^^108^125^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, injectionPointParent ) ;^122^^^^^108^125^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Argument_Swapping]^Node newExpressionRoot = NodeUtil.newVarNode ( expression, resultName ) ;^122^^^^^108^125^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, newExpressionRoot ) ;^122^^^^^108^125^Node newExpressionRoot = NodeUtil.newVarNode ( resultName, expression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( injectionPointParent, injectionPoint ) ;^123^^^^^108^125^injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( newExpressionRoot, newExpressionRoot ) ;^123^^^^^108^125^injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Argument_Swapping]^injectionPointParent.addChildBefore ( injectionPoint, newExpressionRoot ) ;^123^^^^^108^125^injectionPointParent.addChildBefore ( newExpressionRoot, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] moveExpression [RETURN_TYPE] void   Node expression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  sideEffects  Node  expression  expressionParent  expressionRoot  extractBeforeStatement  injectionPoint  injectionPointParent  newExpressionRoot  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  
[BugLab_Variable_Misuse]^Node nonconditionalExpr = findNonconditionalParent ( parent, expressionRoot ) ;^143^144^^^^128^158^Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nonconditionalExpr = findNonconditionalParent ( subExpression, newExpressionRoot ) ;^143^144^^^^128^158^Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node nonconditionalExpr = findNonconditionalParent ( expressionRoot, subExpression ) ;^143^144^^^^128^158^Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nonconditionalExpr = findNonconditionalParent ( left, expressionRoot ) ;^143^144^^^^128^158^Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nonconditionalExpr = findNonconditionalParent ( subExpression, parent ) ;^143^144^^^^128^158^Node nonconditionalExpr = findNonconditionalParent ( subExpression, expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^146^147^^^^131^161^boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( nonconditionalExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( parent ) ;^146^147^^^^131^161^boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects ( nonconditionalExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node exprInjectionPoint = findInjectionPoint ( subExpression ) ;^149^^^^^134^164^Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node exprInjectionPoint = findInjectionPoint ( newExpressionRoot ) ;^149^^^^^134^164^Node exprInjectionPoint = findInjectionPoint ( nonconditionalExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.sideEffects = sideEffects;^151^^^^^136^166^state.sideEffects = hasFollowingSideEffects;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( type == Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( injectionPointParentType == Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( parentType > Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( parentType >= Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( parentType != Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^} else if  ( type == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^} else if  ( leftType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^} else if  ( parentTypeType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^} else if  ( parentType == Token.CALL || NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^} else if  ( parentType <= Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , replacement, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( child.getFirstChild (  ) , parent, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( parent.getFirstChild (  ) , state, child ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( nonconditionalExpr.getFirstChild (  )  )  )  {^189^^^^^185^211^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( left, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( functionExpression, sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^state.sideEffects = false;^200^^^^^189^207^state.sideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = subExpression;^205^^^^^189^207^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node replacement = rewriteCallExpression ( state, parent ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = injectionPointParent;^205^^^^^189^207^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = left.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPointParent, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = subExpression.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , parent, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( child.getNext (  ) , functionExpression, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( functionExpression.getNext (  ) , state, child ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getNext (  ) , child, functionExpression ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( parent, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state.sideEffects, functionExpression )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPoint, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( left, state.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( functionExpression, sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state, functionExpression.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^state.sideEffects = false;^200^^^^^185^211^state.sideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = nonconditionalExpr;^205^^^^^185^211^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node replacement = rewriteCallExpression ( state, parent ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPointParent, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = injectionPointParent;^205^^^^^185^211^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = replacement.getFirstChild (  ) ;^193^^^^^185^211^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( injectionPoint.getFirstChild (  )  )  )  {^189^^^^^185^211^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( injectionPointParent.getFirstChild (  )  )  )  {^189^^^^^185^211^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = newExpressionRoot.getFirstChild (  ) ;^193^^^^^185^211^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( left.getNext (  ) , child, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , parent, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( child.getNext (  ) , functionExpression, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( functionExpression.getNext (  ) , state, child ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getNext (  ) , child, functionExpression ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPoint, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state, functionExpression.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = injectionPoint;^205^^^^^189^207^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = newExpressionRoot.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , left, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( newExpressionRoot, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, state.sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( functionExpression, sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^state.sideEffects = false;^200^^^^^185^215^state.sideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = subExpression;^205^^^^^190^220^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPoint, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node replacement = rewriteCallExpression ( state, parent ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = newExpressionRoot;^205^^^^^190^220^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = left.getFirstChild (  ) ;^193^^^^^178^208^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( nonconditionalExpr, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( injectionPoint.getFirstChild (  )  )  )  {^186^^^^^171^201^&& NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( subExpression.getFirstChild (  )  )  )  {^186^^^^^171^201^&& NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( injectionPoint.getFirstChild (  )  )  )  {^189^^^^^174^204^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPoint.getFirstChild (  ) ;^193^^^^^178^208^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getNext (  ) , child, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , left, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( child.getNext (  ) , functionExpression, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( functionExpression.getNext (  ) , state, child ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getNext (  ) , child, functionExpression ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state.sideEffects, functionExpression )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state, functionExpression.sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( left.getFirstChild (  ) , child, state ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , subExpression, state ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( child.getFirstChild (  ) , parent, state ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( parent.getFirstChild (  ) , state, child ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( newExpressionRoot, state.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( parent, sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isSafeAssign ( state, parent.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( injectionPointParent != child )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != newExpressionRoot )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( left == child )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( parentType == Token.GETELEM )  {^179^^^^^162^184^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type <= Token.GETELEM )  {^179^^^^^162^184^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPoint.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getLastChild (  ) , null, left ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( nonconditionalExpr.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( parent )  ) ;^178^^^^^162^184^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( injectionPointParent )  ) ;^178^^^^^162^184^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getFirstChild (  ) , null, left ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = nonconditionalExpr.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = subExpression.getType (  ) ;^176^^^^^162^184^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = left.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( injectionPoint )  ) ;^178^^^^^162^184^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( newExpressionRoot )  ) ;^178^^^^^162^184^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPoint.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( newExpressionRoot != child )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != injectionPointParent )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( left == child )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( parentType == Token.GETELEM )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type != Token.GETELEM )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getLastChild (  ) , null, left ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( injectionPointParent )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( nonconditionalExpr )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getFirstChild (  ) , null, state ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getFirstChild (  ) , null, left ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( type == Token.null )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type <= Token.GETELEM )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = subExpression.getFirstChild (  ) ;^175^^^^^160^190^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( injectionPointParent, state.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isSafeAssign ( parent, state.sideEffects.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isSafeAssign ( parent, state )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = replacement.getFirstChild (  ) ;^175^^^^^160^190^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = replacement.getType (  ) ;^176^^^^^161^191^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( newExpressionRoot )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( parent )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getFirstChild (  ) , null, state ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( injectionPoint, state.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != parent )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( child != left )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( left <= child )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type != Token.GETELEM )  {^179^^^^^162^184^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = injectionPoint.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = injectionPointParent.getType (  ) ;^176^^^^^162^184^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( injectionPointParent != child )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( child != left )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPoint.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( injectionPoint )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( replacement.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type < Token.GETELEM )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^} else if  ( subExpressionType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^} else if  ( parentType < Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , injectionPointParent, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = left;^205^^^^^189^207^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPointParent.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPoint.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( left.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , newExpressionRoot, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = parent;^205^^^^^185^211^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = subExpression;^205^^^^^185^211^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPointParent.getFirstChild (  ) ;^193^^^^^185^211^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( nonconditionalExpr, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , subExpression, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( injectionPointParent, state.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( functionExpression, needResult )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state.sideEffects, functionExpression )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = nonconditionalExpr.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( injectionPointParent, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( functionExpression, needResult )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects.sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( functionExpression, state )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( subExpression, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( newExpressionRoot, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node child = injectionPointParent, parent = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node parent = nonconditionalExpr, parent = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node child = nonconditionalExpr, newExpressionRoot = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^for  ( Node parent = nonconditionalExpr, child = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( nonconditionalExprType == Token.ASSIGN )  {^161^^^^^146^176^if  ( parentType == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( nonconditionalExpr.getFirstChild (  ) , child, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , subExpression, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getFirstChild (  ) , child, parent ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( left.getFirstChild (  )  )  )  {^189^^^^^185^211^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = replacement.getFirstChild (  ) ;^193^^^^^189^207^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( nonconditionalExpr, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( replacement.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = injectionPoint;^205^^^^^185^211^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = left.getFirstChild (  ) ;^193^^^^^185^211^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPoint.getFirstChild (  ) ;^193^^^^^185^211^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getNext (  ) , child, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , injectionPointParent, state ) ;^194^195^^^^185^211^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, state.sideEffects )  )  {^197^^^^^185^211^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( replacement.getFirstChild (  )  )  )  {^189^^^^^174^204^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( newExpressionRoot, state.sideEffects )  )  {^197^^^^^189^207^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( nonconditionalExpr.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( replacement, state ) ;^203^^^^^189^207^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = parent;^205^^^^^190^220^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = injectionPointParent.getFirstChild (  ) ;^193^^^^^178^208^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( left.getFirstChild (  )  )  )  {^186^^^^^171^201^&& NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = subExpression.getFirstChild (  ) ;^193^^^^^178^208^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( subExpression.getNext (  ) , child, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , nonconditionalExpr, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( newExpressionRoot, state.sideEffects )  )  {^197^^^^^182^212^if  ( isExpressionTreeUnsafe ( functionExpression, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( left, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getFirstChild (  ) , child, state ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getFirstChild (  ) , child, parent ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( parent, needResult )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != nonconditionalExpr )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( replacement.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( nonconditionalExpr.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( replacement.getFirstChild (  ) , null, state ) ;^182^^^^^162^184^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = subExpression.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( subExpression )  ) ;^178^^^^^162^184^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != left )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( type >= Token.GETELEM )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( subExpression )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPoint.getFirstChild (  ) , null, state ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( replacement.getFirstChild (  ) , null, state ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( type == Token.this )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = nonconditionalExpr.getFirstChild (  ) ;^175^^^^^160^190^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = nonconditionalExpr.getType (  ) ;^176^^^^^161^191^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( nonconditionalExpr, state.sideEffects )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = newExpressionRoot.getFirstChild (  ) ;^175^^^^^160^190^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = injectionPointParent.getType (  ) ;^176^^^^^161^191^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getFirstChild (  ) , null, state ) ;^182^^^^^167^197^decomposeSubExpressions ( left.getFirstChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( replacement != child )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != subExpression )  {^177^^^^^162^184^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getLastChild (  ) , null, state ) ;^180^^^^^162^184^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = injectionPointParent.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node left = newExpressionRoot.getFirstChild (  ) ;^175^^^^^162^184^Node left = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = newExpressionRoot.getType (  ) ;^176^^^^^162^184^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( replacement != child )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != parent )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( left >= child )  {^177^^^^^162^192^if  ( left != child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( type == Token.0 )  {^179^^^^^164^194^if  ( type == Token.GETELEM )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( nonconditionalExpr.getLastChild (  ) , null, state ) ;^180^^^^^165^195^decomposeSubExpressions ( left.getLastChild (  ) , null, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^} else if  ( injectionPointParentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^} else if  ( parentType != Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^185^186^^^^170^200^} else if  ( parentType == Token.CALL && NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( parent.getFirstChild (  ) , nonconditionalExpr, state ) ;^209^210^^^^185^211^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( subExpression.getFirstChild (  )  )  )  {^189^^^^^185^211^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( functionExpression.getNext (  ) , injectionPointParent, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( replacement, state ) ;^203^^^^^185^211^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPointParent.getNext (  ) , child, state ) ;^194^195^^^^189^207^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = injectionPoint;^205^^^^^190^220^parent = replacement;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int injectionPointType = parent.getType (  ) ;^158^^^^^143^173^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int nonconditionalExprType = parent.getType (  ) ;^158^^^^^143^173^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( !isConditionalOp ( newExpressionRoot )  || child == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( !isConditionalOp ( parent )  || newExpressionRoot == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Preconditions.checkState ( !isConditionalOp ( child )  || parent == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( !isConditionalOp ( parent )  && child == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( !isConditionalOp ( parent )  || child >= parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^!isConditionalOp ( left )  || child == parent.getFirstChild (  )  ) ;^160^^^^^145^175^!isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^!isConditionalOp ( injectionPointParent )  || child == parent.getFirstChild (  )  ) ;^160^^^^^145^175^!isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int type = injectionPoint.getType (  ) ;^176^^^^^161^191^int type = left.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isGet ( replacement )  ) ;^178^^^^^163^193^Preconditions.checkState ( NodeUtil.isGet ( left )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( injectionPointParent.getFirstChild (  )  )  )  {^186^^^^^171^201^&& NodeUtil.isGet ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( !maybeExternMethod ( injectionPointParent.getFirstChild (  )  )  )  {^189^^^^^174^204^if  ( !maybeExternMethod ( parent.getFirstChild (  )  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacement = rewriteCallExpression ( injectionPointParent, state ) ;^203^^^^^188^218^Node replacement = rewriteCallExpression ( parent, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( injectionPoint.getFirstChild (  ) , child, state ) ;^209^210^^^^194^224^decomposeSubExpressions ( parent.getFirstChild (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = injectionPoint, parent = child.getParent (  )  )  {^157^^^^^142^172^child = parent, parent = child.getParent (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node subExpression = nonconditionalExpr, parent = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int injectionPointParentType = parent.getType (  ) ;^158^^^^^143^173^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionExpression = replacement.getFirstChild (  ) ;^193^^^^^178^208^Node functionExpression = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node left = nonconditionalExpr, parent = child.getParent (  ) ;^155^^^^^140^170^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = parent, parent = injectionPointParent.getParent (  )  )  {^157^^^^^142^172^child = parent, parent = child.getParent (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( !isConditionalOp ( left )  || child == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( !isConditionalOp ( parent )  || nonconditionalExpr == parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( !isConditionalOp ( parent )  || child != parent.getFirstChild (  )  ) ;^159^160^^^^144^174^Preconditions.checkState ( !isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^!isConditionalOp ( injectionPoint )  || child == parent.getFirstChild (  )  ) ;^160^^^^^145^175^!isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^!isConditionalOp ( nonconditionalExpr )  || child == parent.getFirstChild (  )  ) ;^160^^^^^145^175^!isConditionalOp ( parent )  || child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isSafeAssign ( state.sideEffects, parent )  )  {^162^^^^^147^177^if  ( isSafeAssign ( parent, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( left.getNext (  ) , child, state ) ;^194^195^^^^179^209^decomposeSubExpressions ( functionExpression.getNext (  ) , child, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( injectionPoint == subExpression )  {^219^^^^^204^234^if  ( nonconditionalExpr == subExpression )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( nonconditionalExpr == injectionPoint )  {^219^^^^^204^234^if  ( nonconditionalExpr == subExpression )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( subExpression == nonconditionalExpr )  {^219^^^^^204^234^if  ( nonconditionalExpr == subExpression )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( nonconditionalExpr < subExpression )  {^219^^^^^204^234^if  ( nonconditionalExpr == subExpression )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = injectionPoint.getParent (  ) ;^225^^^^^219^229^Node parent = nonconditionalExpr.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean needResult = newExpressionRoot.getType (  )  != Token.EXPR_RESULT;^226^^^^^219^229^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^boolean needResult = parent.getType (  )  > Token.EXPR_RESULT;^226^^^^^219^229^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( subExpression, exprInjectionPoint, needResult ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( nonconditionalExpr, left, needResult ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, sideEffects ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node extractedConditional = extractConditional ( needResult, exprInjectionPoint, nonconditionalExpr ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node extractedConditional = extractConditional ( exprInjectionPoint, nonconditionalExpr, needResult ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean needResult = injectionPoint.getType (  )  != Token.EXPR_RESULT;^226^^^^^219^229^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( nonconditionalExpr, injectionPointParent, needResult ) ;^227^228^^^^219^229^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = subExpression.getParent (  ) ;^225^^^^^210^240^Node parent = nonconditionalExpr.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean needResult = injectionPointParent.getType (  )  != Token.EXPR_RESULT;^226^^^^^211^241^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^boolean needResult = parent.getType (  )  == Token.EXPR_RESULT;^226^^^^^211^241^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( left, exprInjectionPoint, needResult ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, sideEffects ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node extractedConditional = extractConditional ( exprInjectionPoint, nonconditionalExpr, needResult ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node extractedConditional = extractConditional ( needResult, exprInjectionPoint, nonconditionalExpr ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean needResult = left.getType (  )  != Token.EXPR_RESULT;^226^^^^^211^241^boolean needResult = parent.getType (  )  != Token.EXPR_RESULT;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node extractedConditional = extractConditional ( nonconditionalExpr, nonconditionalExpr, needResult ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node extractedConditional = extractConditional ( nonconditionalExpr, needResult, exprInjectionPoint ) ;^227^228^^^^212^242^Node extractedConditional = extractConditional ( nonconditionalExpr, exprInjectionPoint, needResult ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] exposeExpression [RETURN_TYPE] void   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^return false;^237^^^^^235^238^return true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] maybeExternMethod [RETURN_TYPE] boolean   Node node [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node result = injectionPointParent;^246^^^^^244^261^Node result = subExpression;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isConditionalOp ( left )  )  {^251^^^^^244^261^if  ( isConditionalOp ( parent )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( replacement != parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != replacement.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( parent != child.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( child <= parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^result = subExpression;^255^^^^^244^261^result = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^result = left;^255^^^^^244^261^result = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != subExpression.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( subExpression != parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != node.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( child >= parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node child = left, parent = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node node = subExpression, parent = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node child = subExpression, replacement = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^for  ( Node child = parent, subExpression = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isConditionalOp ( node )  )  {^251^^^^^244^261^if  ( isConditionalOp ( parent )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left != parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^result = newExpressionRoot;^255^^^^^244^261^result = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^result = injectionPointParent;^255^^^^^244^261^result = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != injectionPointParent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != left.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( child > parent.getFirstChild (  )  )  {^254^^^^^244^261^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isConditionalOp ( injectionPointParent )  )  {^251^^^^^244^261^if  ( isConditionalOp ( parent )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = left, parent = child.getParent (  )  )  {^250^^^^^244^261^child = parent, parent = child.getParent (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = parent, parent = subExpression.getParent (  )  )  {^250^^^^^244^261^child = parent, parent = child.getParent (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node child = nonconditionalExpr, parent = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node subExpression = subExpression, parent = child.getParent (  ) ;^248^^^^^244^261^for  ( Node child = subExpression, parent = child.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = parent, parent = left.getParent (  )  )  {^250^^^^^244^261^child = parent, parent = child.getParent (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isConditionalOp ( replacement )  )  {^251^^^^^244^261^if  ( isConditionalOp ( parent )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return newExpressionRoot;^260^^^^^244^261^return result;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findNonconditionalParent [RETURN_TYPE] Node   Node subExpression Node expressionRoot [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  subExpression  Supplier  safeNameIdSupplier  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( n == null || n == left )  {^280^^^^^277^300^if  ( n == null || n == stopNode )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( stopNode == null || n == n )  {^280^^^^^277^300^if  ( n == null || n == stopNode )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n == null && n == stopNode )  {^280^^^^^277^300^if  ( n == null || n == stopNode )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n != null || n == stopNode )  {^280^^^^^277^300^if  ( n == null || n == stopNode )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n == null || n != stopNode )  {^280^^^^^277^300^if  ( n == null || n == stopNode )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( newExpressionRoot.getNext (  ) , stopNode, state ) ;^288^289^^^^277^300^decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^decomposeSubExpressions ( n.getNext (  ) , subExpression, state ) ;^288^289^^^^277^300^decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( state.getNext (  ) , stopNode, n ) ;^288^289^^^^277^300^decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( stopNode.getNext (  ) , n, state ) ;^288^289^^^^277^300^decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^decomposeSubExpressions ( n.getNext (  ) , state, stopNode ) ;^288^289^^^^277^300^decomposeSubExpressions ( n.getNext (  ) , stopNode, state ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( subExpression, state.sideEffects )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( n, sideEffects )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^state.sideEffects = false;^296^^^^^277^300^state.sideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = extractExpression ( left, state.extractBeforeStatement ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = extractExpression ( n, newExpressionRoot ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement.extractBeforeStatement ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^state.extractBeforeStatement = extractExpression ( state, n.extractBeforeStatement ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^state.extractBeforeStatement = extractExpression ( state.extractBeforeStatement, n ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = extractExpression ( newExpressionRoot, state.extractBeforeStatement ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = extractExpression ( n, nonconditionalExpr ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^state.extractBeforeStatement = extractExpression ( n, state ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, state.sideEffects )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state.sideEffects, n )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( state, n.sideEffects )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( n, state )  )  {^293^^^^^277^300^if  ( isExpressionTreeUnsafe ( n, state.sideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = extractExpression ( replacement, state.extractBeforeStatement ) ;^297^298^^^^277^300^state.extractBeforeStatement = extractExpression ( n, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] decomposeSubExpressions [RETURN_TYPE] void   Node n Node stopNode DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  functionExpression  injectionPoint  injectionPointParent  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  result  stopNode  subExpression  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = last.getParent (  ) ;^313^^^^^298^328^Node parent = expr.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = n.getFirstChild (  ) ;^317^^^^^302^332^Node first = expr.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = node.getFirstChild (  ) ;^317^^^^^302^332^Node first = expr.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node second = newExpressionRoot.getNext (  ) ;^318^^^^^303^333^Node second = first.getNext (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node last = node.getLastChild (  ) ;^319^^^^^304^334^Node last = expr.getLastChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node last = n.getLastChild (  ) ;^319^^^^^304^334^Node last = expr.getLastChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = parent;^331^^^^^316^346^cond = first;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( node, needResult, tempName ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( first, sideEffects, tempName ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( first, needResult, tempNamePrefix ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( needResult, first, tempName ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( first, tempName, needResult ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( nonconditionalExpr, needResult, tempName ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( first, sideEffects, tempName ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( needResult, first, tempName ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( first, tempName, needResult ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( injectionPointParent, needResult, tempName )  )  ) ;^332^333^^^^317^347^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, sideEffects, tempName )  )  ) ;^332^333^^^^317^347^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempNamePrefix )  )  ) ;^332^333^^^^317^347^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( tempName, needResult, second )  )  ) ;^332^333^^^^317^347^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, tempName, needResult )  )  ) ;^332^333^^^^317^347^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, sideEffects, tempName )  )  ) ;^334^335^^^^319^349^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^334^335^^^^319^349^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, tempName, needResult )  )  ) ;^334^335^^^^319^349^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( node, needResult, tempName )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( needResult, last, tempName )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( tempName, needResult, last )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, sideEffects, tempName )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, tempName, needResult )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( tempName, needResult, last )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^switch  ( left.getType (  )  )  {^328^^^^^313^343^switch  ( expr.getType (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( n, needResult, tempName )  )  ) ;^333^^^^^318^348^buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( second, sideEffects, tempName )  )  ) ;^333^^^^^318^348^buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( second, needResult, tempNamePrefix )  )  ) ;^333^^^^^318^348^buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( needResult, second, tempName )  )  ) ;^333^^^^^318^348^buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( tempName, needResult, second )  )  ) ;^333^^^^^318^348^buildResultExpression ( second, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( node, needResult, tempName )  )  ) ;^334^335^^^^319^349^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( tempName, needResult, last )  )  ) ;^334^335^^^^319^349^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( left, needResult, tempName )  )  ) ;^335^^^^^320^350^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^335^^^^^320^350^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( tempName, needResult, last )  )  ) ;^335^^^^^320^350^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( needResult, last, tempName )  )  ) ;^335^^^^^320^350^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( last, tempName, needResult )  )  ) ;^335^^^^^320^350^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( newExpressionRoot, needResult, tempName ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( tempName, needResult, first ) ;^339^^^^^324^354^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( injectionPointParent, needResult, tempName )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, sideEffects, tempName )  )  ) ;^340^341^^^^325^355^trueExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( last, sideEffects, tempName )  )  ) ;^341^^^^^326^356^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^341^^^^^326^356^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( needResult, last, tempName )  )  ) ;^341^^^^^326^356^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( last, tempName, needResult )  )  ) ;^341^^^^^326^356^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^cond = buildResultExpression ( first, needResult, tempNamePrefix ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^cond = buildResultExpression ( tempName, needResult, first ) ;^345^^^^^330^360^cond = buildResultExpression ( first, needResult, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( injectionPointParent, needResult, tempName )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( needResult, last, tempName )  )  ) ;^346^347^^^^331^361^falseExpr.addChildToFront ( new Node ( Token.EXPR_RESULT, buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( injectionPointParent, needResult, tempName )  )  ) ;^347^^^^^332^362^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( last, sideEffects, tempName )  )  ) ;^347^^^^^332^362^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^buildResultExpression ( last, needResult, tempNamePrefix )  )  ) ;^347^^^^^332^362^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( tempName, needResult, last )  )  ) ;^347^^^^^332^362^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^buildResultExpression ( last, tempName, needResult )  )  ) ;^347^^^^^332^362^buildResultExpression ( last, needResult, tempName )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left.hasChildren (  )  )  {^355^^^^^340^370^if  ( falseExpr.hasChildren (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, n, trueExpr ) ;^358^^^^^355^359^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, last ) ;^358^^^^^355^359^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^ifNode = new Node ( Token.IF, trueExpr, cond ) ;^358^^^^^355^359^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, left, trueExpr ) ;^358^^^^^355^359^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, n, trueExpr, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, last, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^ifNode = new Node ( Token.IF, falseExpr, trueExpr, cond ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^ifNode = new Node ( Token.IF, cond, falseExpr, trueExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, parent, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, trueExpr, second ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^ifNode = new Node ( Token.IF, trueExpr, cond, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, last, trueExpr, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, left, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, trueExpr, stopNode ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, last, trueExpr ) ;^358^^^^^343^373^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^ifNode = new Node ( Token.IF, trueExpr, cond ) ;^358^^^^^343^373^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, newExpressionRoot, trueExpr, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, newExpressionRoot, falseExpr ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, cond, trueExpr, replacementValueNode ) ;^356^^^^^341^371^ifNode = new Node ( Token.IF, cond, trueExpr, falseExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^ifNode = new Node ( Token.IF, node, trueExpr ) ;^358^^^^^343^373^ifNode = new Node ( Token.IF, cond, trueExpr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( sideEffects )  {^361^^^^^346^376^if  ( needResult )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node gramps = node.getParent (  ) ;^375^^^^^361^377^Node gramps = parent.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( left.getType (  )  == Token.EXPR_RESULT ) ;^374^^^^^361^377^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( parent.getType (  )  != Token.EXPR_RESULT ) ;^374^^^^^361^377^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( injectionPointParent.getType (  )  == Token.EXPR_RESULT ) ;^374^^^^^361^377^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node gramps = last.getParent (  ) ;^375^^^^^361^377^Node gramps = parent.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^gramps.replaceChild ( n, ifNode ) ;^376^^^^^361^377^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^gramps.replaceChild ( parent, last ) ;^376^^^^^361^377^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^gramps.replaceChild ( ifNode, parent ) ;^376^^^^^361^377^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempNamePrefix )  ) ;^362^363^^^^347^377^Node tempVarNode = new Node ( Token.VAR, Node.newString ( Token.NAME, tempName )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node leftParent = injectionPoint.getParent (  ) ;^364^^^^^349^379^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacementValueNode = Node.newString ( Token.NAME, tempNamePrefix ) ;^369^^^^^354^384^Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node.newString ( Token.NAME, tempNamePrefix )  ) ;^363^^^^^348^378^Node.newString ( Token.NAME, tempName )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node lastParent = injectionPoint.getParent (  ) ;^364^^^^^349^379^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( left, injectionPoint ) ;^365^^^^^350^380^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( tempVarNode, n ) ;^365^^^^^350^380^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^injectionPointParent.addChildBefore ( injectionPoint, tempVarNode ) ;^365^^^^^350^380^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildAfter ( n, tempVarNode ) ;^366^^^^^351^381^injectionPointParent.addChildAfter ( ifNode, tempVarNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildAfter ( ifNode, left ) ;^366^^^^^351^381^injectionPointParent.addChildAfter ( ifNode, tempVarNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^injectionPointParent.addChildAfter ( tempVarNode, ifNode ) ;^366^^^^^351^381^injectionPointParent.addChildAfter ( ifNode, tempVarNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( last, replacementValueNode ) ;^370^^^^^355^385^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( expr, last ) ;^370^^^^^355^385^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^parent.replaceChild ( replacementValueNode, expr ) ;^370^^^^^355^385^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nParent = injectionPoint.getParent (  ) ;^364^^^^^349^379^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node gramps = left.getParent (  ) ;^375^^^^^360^390^Node gramps = parent.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( last, injectionPoint ) ;^365^^^^^350^380^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( tempVarNode, newExpressionRoot ) ;^365^^^^^350^380^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildAfter ( last, tempVarNode ) ;^366^^^^^351^381^injectionPointParent.addChildAfter ( ifNode, tempVarNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildAfter ( ifNode, last ) ;^366^^^^^351^381^injectionPointParent.addChildAfter ( ifNode, tempVarNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( left, replacementValueNode ) ;^370^^^^^355^385^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( left.getType (  )  == Token.EXPR_RESULT ) ;^374^^^^^359^389^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( parent.getType (  )  == Token.4 ) ;^374^^^^^359^389^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( parent.getType (  )  >= Token.EXPR_RESULT ) ;^374^^^^^359^389^Preconditions.checkArgument ( parent.getType (  )  == Token.EXPR_RESULT ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node gramps = trueExpr.getParent (  ) ;^375^^^^^360^390^Node gramps = parent.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^gramps.replaceChild ( last, ifNode ) ;^376^^^^^361^391^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^gramps.replaceChild ( parent, n ) ;^376^^^^^361^391^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^gramps.replaceChild ( ifNode, parent ) ;^376^^^^^361^391^gramps.replaceChild ( parent, ifNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return newExpressionRoot;^379^^^^^364^394^return ifNode;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractConditional [RETURN_TYPE] Node   Node expr Node injectionPoint boolean needResult [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( sideEffects )  {^393^^^^^391^400^if  ( needResult )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return n;^398^^^^^391^400^return expr;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempNamePrefix ) , expr ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , node ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , newExpressionRoot ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node.newString ( Token.NAME, tempNamePrefix ) , expr ) ;^395^396^^^^391^400^Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , replacementValueNode ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , parent ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, expr ) , tempName ) ;^394^395^396^^^391^400^return new Node ( Token.ASSIGN, Node.newString ( Token.NAME, tempName ) , expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] buildResultExpression [RETURN_TYPE] Node   Node expr boolean needResult String tempName [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = newExpressionRoot.getParent (  ) ;^409^^^^^408^426^Node parent = expr.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = left.getParent (  ) ;^409^^^^^408^426^Node parent = expr.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node replacementValueNode = Node.newString ( Token.NAME, tempNamePrefix ) ;^414^^^^^408^426^Node replacementValueNode = Node.newString ( Token.NAME, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( node, replacementValueNode ) ;^415^^^^^408^426^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent.replaceChild ( expr, node ) ;^415^^^^^408^426^parent.replaceChild ( expr, replacementValueNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node tempNamePrefixNode = Node.newString ( Token.NAME, tempName ) ;^418^^^^^408^426^Node tempNameNode = Node.newString ( Token.NAME, tempName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^tempNameNode.addChildrenToBack ( node ) ;^419^^^^^408^426^tempNameNode.addChildrenToBack ( expr ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node tempVarNode = new Node ( Token.VAR, n ) ;^420^^^^^408^426^Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node tempVarNode = new Node ( Token.VAR, parent ) ;^420^^^^^408^426^Node tempVarNode = new Node ( Token.VAR, tempNameNode ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nParent = injectionPoint.getParent (  ) ;^422^^^^^408^426^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node nonconditionalExprParent = injectionPoint.getParent (  ) ;^422^^^^^408^426^Node injectionPointParent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPointParent.addChildBefore ( tempVarNode, left ) ;^423^^^^^408^426^injectionPointParent.addChildBefore ( tempVarNode, injectionPoint ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return n;^425^^^^^408^426^return tempVarNode;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] extractExpression [RETURN_TYPE] Node   Node expr Node injectionPoint [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( last.getType (  )  == Token.CALL ) ;^439^^^^^424^454^Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkArgument ( call.getType (  )  > Token.CALL ) ;^439^^^^^424^454^Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( left.getType (  )  == Token.CALL ) ;^439^^^^^424^454^Preconditions.checkArgument ( call.getType (  )  == Token.CALL ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = n.getFirstChild (  ) ;^440^^^^^425^455^Node first = call.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = nonconditionalExpr.getFirstChild (  ) ;^440^^^^^425^455^Node first = call.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( NodeUtil.isGet ( n )  ) ;^441^^^^^426^456^Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( NodeUtil.isGet ( last )  ) ;^441^^^^^426^456^Preconditions.checkArgument ( NodeUtil.isGet ( first )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getVarNode = extractExpression ( newCall, state.extractBeforeStatement ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getVarNode = extractExpression ( first, left ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node getVarNode = extractExpression ( state.extractBeforeStatement, first ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node getVarNode = extractExpression ( first, state.extractBeforeStatement.extractBeforeStatement ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getVarNode = extractExpression ( newExpressionRoot, state.extractBeforeStatement ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node getVarNode = extractExpression ( first, state ) ;^445^446^^^^430^460^Node getVarNode = extractExpression ( first, state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = left;^447^^^^^432^462^state.extractBeforeStatement = getVarNode;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getExprNode = n.getFirstChild (  ) .getFirstChild (  ) ;^451^^^^^436^466^Node getExprNode = getVarNode.getFirstChild (  ) .getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getExprNode = replacement.getFirstChild (  ) .getFirstChild (  ) ;^451^^^^^436^466^Node getExprNode = getVarNode.getFirstChild (  ) .getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node getExprNode = newCall.getFirstChild (  ) .getFirstChild (  ) ;^451^^^^^436^466^Node getExprNode = getVarNode.getFirstChild (  ) .getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkArgument ( NodeUtil.isGet ( node )  ) ;^452^^^^^437^467^Preconditions.checkArgument ( NodeUtil.isGet ( getExprNode )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node thisVarNode = extractExpression ( last.getFirstChild (  ) , state.extractBeforeStatement ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , injectionPointParent ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node thisVarNode = extractExpression ( state.extractBeforeStatement.getFirstChild (  ) , getExprNode ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement.extractBeforeStatement ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node thisVarNode = extractExpression ( n.getFirstChild (  ) , state.extractBeforeStatement ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , newExpressionRoot ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Node thisVarNode = extractExpression ( state.getFirstChild (  ) , getExprNode.extractBeforeStatement ) ;^453^454^^^^438^468^Node thisVarNode = extractExpression ( getExprNode.getFirstChild (  ) , state.extractBeforeStatement ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^state.extractBeforeStatement = injectionPointParent;^455^^^^^440^470^state.extractBeforeStatement = thisVarNode;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node thisNameNode = injectionPointParent.getFirstChild (  ) ;^458^^^^^443^473^Node thisNameNode = thisVarNode.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node functionNameNode = newExpressionRoot.getFirstChild (  ) ;^459^^^^^444^474^Node functionNameNode = getVarNode.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node newCall = new Node ( Token.CALL, new Node ( Token.GETPROP, last.cloneNode (  ) , Node.newString ( "call" )  ) ,^469^470^471^472^^454^484^Node newCall = new Node ( Token.CALL, new Node ( Token.GETPROP, functionNameNode.cloneNode (  ) , Node.newString ( "call" )  ) ,^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^new Node ( Token.GETPROP, n.cloneNode (  ) , Node.newString ( "call" )  ) , thisNameNode.cloneNode (  ) , call.getLineno (  ) , call.getCharno (  )  ) ;^470^471^472^473^^455^485^new Node ( Token.GETPROP, functionNameNode.cloneNode (  ) , Node.newString ( "call" )  ) , thisNameNode.cloneNode (  ) , call.getLineno (  ) , call.getCharno (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^thisNameNode.cloneNode (  ) , last.getLineno (  ) , call.getCharno (  )  ) ;^473^^^^^458^488^thisNameNode.cloneNode (  ) , call.getLineno (  ) , call.getCharno (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^thisNameNode.cloneNode (  ) , left.getLineno (  ) , call.getCharno (  )  ) ;^473^^^^^458^488^thisNameNode.cloneNode (  ) , call.getLineno (  ) , call.getCharno (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( last.hasChildren (  )  )  {^477^^^^^462^492^if  ( call.hasChildren (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^newCall.addChildrenToBack ( last.removeChildren (  )  ) ;^479^^^^^464^494^newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^newCall.addChildrenToBack ( newCall.removeChildren (  )  ) ;^479^^^^^464^494^newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^newCall.addChildrenToBack ( n.removeChildren (  )  ) ;^479^^^^^464^494^newCall.addChildrenToBack ( call.removeChildren (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node newExpressionRootParent = call.getParent (  ) ;^483^^^^^468^498^Node callParent = call.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^callParent.replaceChild ( left, newCall ) ;^484^^^^^469^499^callParent.replaceChild ( call, newCall ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^callParent.replaceChild ( call, node ) ;^484^^^^^469^499^callParent.replaceChild ( call, newCall ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^callParent.replaceChild ( newCall, call ) ;^484^^^^^469^499^callParent.replaceChild ( call, newCall ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return parent;^486^^^^^471^501^return newCall;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] rewriteCallExpression [RETURN_TYPE] Node   Node call DecompositionState state [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  DecompositionState  state  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^this.tempNamePrefix = tempName;^496^^^^^495^497^this.tempNamePrefix = tempNamePrefix;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] setTempNamePrefix [RETURN_TYPE] void   String tempNamePrefix [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return tempName + safeNameIdSupplier.get (  ) ;^503^^^^^502^504^return tempNamePrefix + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return safeNameIdSupplier + tempNamePrefix.get (  ) ;^503^^^^^502^504^return tempNamePrefix + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^return tempNamePrefix + safeNameIdSupplier.get (  ^  ) ;^503^^^^^502^504^return tempNamePrefix + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^String sName = tempName + "const_" + safeNameIdSupplier.get (  ) ;^510^^^^^509^513^String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^String sName = safeNameIdSupplier + "const_" + tempNamePrefix.get (  ) ;^510^^^^^509^513^String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  >=  ) ;^510^^^^^509^513^String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^String sName = tempNamePrefix  &&  "const_" + safeNameIdSupplier.get (  ) ;^510^^^^^509^513^String sName = tempNamePrefix + "const_" + safeNameIdSupplier.get (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^this.knownConstants.add ( tempNamePrefix ) ;^511^^^^^509^513^this.knownConstants.add ( sName ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return tempNamePrefix;^512^^^^^509^513^return sName;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] getTempConstantValueName [RETURN_TYPE] String   [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node expressionRoot = findExpressionRoot ( newExpressionRoot ) ;^520^^^^^519^534^Node expressionRoot = findExpressionRoot ( subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node expressionRoot = findExpressionRoot ( last ) ;^520^^^^^519^534^Node expressionRoot = findExpressionRoot ( subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkNotNull ( n ) ;^521^^^^^519^534^Preconditions.checkNotNull ( expressionRoot ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node injectionPoint = n;^523^^^^^519^534^Node injectionPoint = expressionRoot;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = node.getParent (  ) ;^525^^^^^519^534^Node parent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node parent = left.getParent (  ) ;^525^^^^^519^534^Node parent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^while  ( parent.getType (  )  >= Token.LABEL )  {^526^^^^^519^534^while  ( parent.getType (  )  == Token.LABEL )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^injectionPoint = last;^527^^^^^519^534^injectionPoint = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = last.getParent (  ) ;^528^^^^^519^534^parent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^parent = n.getParent (  ) ;^528^^^^^519^534^parent = injectionPoint.getParent (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^while  ( node.getType (  )  == Token.LABEL )  {^526^^^^^519^534^while  ( parent.getType (  )  == Token.LABEL )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( NodeUtil.isStatementBlock ( newExpressionRoot.getParent (  )  )  ) ;^531^532^^^^519^534^Preconditions.checkState ( NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^NodeUtil.isStatementBlock ( left.getParent (  )  )  ) ;^532^^^^^519^534^NodeUtil.isStatementBlock ( injectionPoint.getParent (  )  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return node;^533^^^^^519^534^return injectionPoint;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findInjectionPoint [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^return false;^544^^^^^539^548^return true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isConditionalOp [RETURN_TYPE] boolean   Node n [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^return true;^546^^^^^539^548^return false;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isConditionalOp [RETURN_TYPE] boolean   Node n [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^switch ( last.getType (  )  )  {^540^^^^^539^548^switch ( n.getType (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isConditionalOp [RETURN_TYPE] boolean   Node n [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node child = last;^556^^^^^555^583^Node child = subExpression;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int leftType = parent.getType (  ) ;^558^^^^^555^583^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node parent : node.getAncestors (  )  )  {^557^^^^^555^583^for  ( Node parent : child.getAncestors (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int lastType = parent.getType (  ) ;^558^^^^^555^583^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( last == parent.getFirstChild (  )  ) ;^569^^^^^555^583^Preconditions.checkState ( child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( child == stopNode.getFirstChild (  )  ) ;^569^^^^^555^583^Preconditions.checkState ( child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^Preconditions.checkState ( parent == child.getFirstChild (  )  ) ;^569^^^^^555^583^Preconditions.checkState ( child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^Preconditions.checkState ( child <= parent.getFirstChild (  )  ) ;^569^^^^^555^583^Preconditions.checkState ( child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Preconditions.checkState ( child == nonconditionalExpr.getFirstChild (  )  ) ;^569^^^^^555^583^Preconditions.checkState ( child == parent.getFirstChild (  )  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] findExpressionRoot [RETURN_TYPE] Node   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node expressionRoot = findExpressionRoot ( n ) ;^611^^^^^610^616^Node expressionRoot = findExpressionRoot ( subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( n != null )  {^612^^^^^610^616^if  ( expressionRoot != null )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( expressionRoot == null )  {^612^^^^^610^616^if  ( expressionRoot != null )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( last, subExpression ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( expressionRoot, n ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return isSubexpressionMovable ( subExpression, expressionRoot ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( nonconditionalExpr, subExpression ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( expressionRoot, left ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( left, subExpression ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return isSubexpressionMovable ( expressionRoot, last ) ;^613^^^^^610^616^return isSubexpressionMovable ( expressionRoot, subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] canExposeExpression [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^boolean requiresDecomposition = true;^646^^^^^631^661^boolean requiresDecomposition = false;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( left ) ;^647^^^^^632^662^boolean seenSideEffects = NodeUtil.mayHaveSideEffects ( subExpression ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node child = last;^649^^^^^634^664^Node child = subExpression;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( last == expressionRoot )  {^651^^^^^636^666^if  ( parent == expressionRoot )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( parent == replacement )  {^651^^^^^636^666^if  ( parent == expressionRoot )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( expressionRoot == parent )  {^651^^^^^636^666^if  ( parent == expressionRoot )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( parent < expressionRoot )  {^651^^^^^636^666^if  ( parent == expressionRoot )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return seenSideEffects ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^639^669^return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return requiresDecomposition ? DecompositionType.UNDECOMPOSABLE : DecompositionType.MOVABLE;^654^655^656^^^639^669^return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isConditionalOp ( injectionPointParent )  )  {^661^^^^^646^676^if  ( isConditionalOp ( parent )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( node, seenSideEffects )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( parent, sideEffects )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( parent == child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( n == node )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( child == n )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n != child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( newExpressionRoot, seenSideEffects )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( n, requiresDecomposition )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isExpressionTreeUnsafe ( seenSideEffects, n )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^seenSideEffects = false;^697^^^^^695^699^seenSideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^requiresDecomposition = false;^698^^^^^695^699^requiresDecomposition = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( seenSideEffects && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( last )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( requiresDecomposition && first.getType (  )  == Token.CALL && NodeUtil.isGet ( parent )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( requiresDecomposition || parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( requiresDecomposition && parent.getType (  )  != Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( newCall )  )  {^721^^^^^718^726^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( newExpressionRoot )  )  {^721^^^^^706^736^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^seenSideEffects = false;^697^^^^^682^712^seenSideEffects = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^requiresDecomposition = false;^698^^^^^683^713^requiresDecomposition = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = last.getFirstChild (  ) ;^717^^^^^702^732^Node first = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( newCall, seenSideEffects )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( n, sideEffects )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = left.getFirstChild (  ) ;^717^^^^^702^732^Node first = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& injectionPointParent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^719^720^^^^704^734^&& parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( last )  )  {^720^^^^^705^735^&& NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( last )  )  {^721^^^^^706^736^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( left == child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( n == parent )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n > child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( last, seenSideEffects )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( sideEffects && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( requiresDecomposition && injectionPointParent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( left )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( requiresDecomposition && parent.getType (  )  >= Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( left )  )  {^721^^^^^718^726^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = newExpressionRoot.getFirstChild (  ) ;^717^^^^^702^732^Node first = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( left, seenSideEffects )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( parent, requiresDecomposition )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( isSafeAssign ( seenSideEffects, parent )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node n : last.children (  )  )  {^688^^^^^673^703^for  ( Node n : parent.children (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& nonconditionalExpr.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^719^720^^^^704^734^&& parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( newCall )  )  {^721^^^^^706^736^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( last != parent.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != left.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( parent != child.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( child == parent.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^requiresDecomposition = false;^665^^^^^650^680^requiresDecomposition = true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != node.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != last.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssign ( newExpressionRoot, seenSideEffects )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isSafeAssignewExpressionRoot ( parent, seenSideEffects )  )  {^675^^^^^660^690^if  ( isSafeAssign ( parent, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( newCall == child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( n == newExpressionRoot )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( requiresDecomposition && last.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( n )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^if  ( first && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( requiresDecomposition )  )  {^718^719^720^^^703^733^if  ( requiresDecomposition && parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( last )  )  {^721^^^^^718^726^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( n )  )  {^721^^^^^718^726^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node n : left.children (  )  )  {^688^^^^^673^703^for  ( Node n : parent.children (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( isExpressionTreeUnsafe ( nonconditionalExpr, seenSideEffects )  )  {^695^696^^^^680^710^if  ( isExpressionTreeUnsafe ( n, seenSideEffects )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = injectionPointParent.getFirstChild (  ) ;^717^^^^^702^732^Node first = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& left.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^719^720^^^^704^734^&& parent.getType (  )  == Token.CALL && NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( n )  )  {^720^^^^^705^735^&& NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( left )  )  {^721^^^^^706^736^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( nonconditionalExpr == child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n <= child )  {^689^^^^^674^704^if  ( n == child )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( newExpressionRoot )  )  {^721^^^^^718^726^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^child = injectionPointParent;^730^^^^^715^745^child = parent;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^int nodeType = parent.getType (  ) ;^659^^^^^644^674^int parentType = parent.getType (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node parent : newCall.getAncestors (  )  )  {^650^^^^^635^665^for  ( Node parent : child.getAncestors (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( child != result.getFirstChild (  )  )  {^664^^^^^649^679^if  ( child != parent.getFirstChild (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^for  ( Node n : newExpressionRoot.children (  )  )  {^688^^^^^673^703^for  ( Node n : parent.children (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node first = n.getFirstChild (  ) ;^717^^^^^702^732^Node first = parent.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& NodeUtil.isGet ( replacementValueNode )  )  {^720^^^^^705^735^&& NodeUtil.isGet ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( maybeExternMethod ( nonconditionalExpr )  )  {^721^^^^^706^736^if  ( maybeExternMethod ( first )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSubexpressionMovable [RETURN_TYPE] ExpressionDecomposer$DecompositionType   Node expressionRoot Node subExpression [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^if  ( injectionPointParent.getType (  )  == Token.ASSIGN )  {^759^^^^^758^772^if  ( n.getType (  )  == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^if  ( n.getType (  )  > Token.ASSIGN )  {^759^^^^^758^772^if  ( n.getType (  )  == Token.ASSIGN )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^return false;^763^^^^^758^772^return true;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( left.getFirstChild (  ) , seenSideEffects ) ;^765^^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , sideEffects ) ;^765^^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return !isExpressionTreeUnsafe ( seenSideEffects.getFirstChild (  ) , lhs ) ;^765^^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( injectionPointParent.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , sideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return !isExpressionTreeUnsafe ( seenSideEffects.getFirstChild (  ) , lhs ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Operator]^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) || !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node lhs = newExpressionRoot.getFirstChild (  ) ;^760^^^^^758^772^Node lhs = n.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node lhs = injectionPointParent.getFirstChild (  ) ;^760^^^^^758^772^Node lhs = n.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^switch  ( last.getType (  )  )  {^761^^^^^758^772^switch  ( lhs.getType (  )  )  {^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( stopNode.getFirstChild (  ) , seenSideEffects ) ;^765^^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( last.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( left.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& !isExpressionTreeUnsafe ( n.getLastChild (  ) , seenSideEffects ) ;^768^^^^^758^772^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , requiresDecomposition ) ;^768^^^^^758^772^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^&& !isExpressionTreeUnsafe ( seenSideEffects.getLastChild (  ) , lhs ) ;^768^^^^^758^772^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& !isExpressionTreeUnsafe ( left.getLastChild (  ) , seenSideEffects ) ;^768^^^^^758^772^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( last.getFirstChild (  ) , seenSideEffects ) ;^765^^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( node.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^Node lhs = stopNode.getFirstChild (  ) ;^760^^^^^758^772^Node lhs = n.getFirstChild (  ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return !isExpressionTreeUnsafe ( newExpressionRoot.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^767^768^^^^758^772^return !isExpressionTreeUnsafe ( lhs.getFirstChild (  ) , seenSideEffects ) && !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , sideEffects ) ;^768^^^^^758^772^&& !isExpressionTreeUnsafe ( lhs.getLastChild (  ) , seenSideEffects ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Wrong_Literal]^return true;^771^^^^^758^772^return false;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isSafeAssign [RETURN_TYPE] boolean   Node n boolean seenSideEffects [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.mayHaveSideEffects ( injectionPointParent ) ;^789^^^^^778^791^return NodeUtil.mayHaveSideEffects ( n ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.mayHaveSideEffects ( replacement ) ;^789^^^^^778^791^return NodeUtil.mayHaveSideEffects ( n ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.canBeSideEffected ( left, this.knownConstants ) ;^785^^^^^778^791^return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Argument_Swapping]^return NodeUtil.canBeSideEffected ( this.knownConstants, n ) ;^785^^^^^778^791^return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.canBeSideEffected ( injectionPointParent, this.knownConstants ) ;^785^^^^^778^791^return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.canBeSideEffected ( node, this.knownConstants ) ;^785^^^^^778^791^return NodeUtil.canBeSideEffected ( n, this.knownConstants ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
[BugLab_Variable_Misuse]^return NodeUtil.mayHaveSideEffects ( last ) ;^789^^^^^778^791^return NodeUtil.mayHaveSideEffects ( n ) ;^[CLASS] ExpressionDecomposer DecompositionType DecompositionState  [METHOD] isExpressionTreeUnsafe [RETURN_TYPE] boolean   Node n boolean followingSideEffectsExist [VARIABLES] DecompositionType  DECOMPOSABLE  MOVABLE  UNDECOMPOSABLE  AbstractCompiler  compiler  Set  constNames  knownConstants  boolean  followingSideEffectsExist  hasFollowingSideEffects  needResult  requiresDecomposition  seenSideEffects  sideEffects  Node  call  callParent  child  cond  expr  exprInjectionPoint  expression  expressionParent  expressionRoot  extractBeforeStatement  extractedConditional  falseExpr  first  functionExpression  functionNameNode  getExprNode  getVarNode  gramps  ifNode  injectionPoint  injectionPointParent  last  left  lhs  n  newCall  newExpressionRoot  node  nonconditionalExpr  parent  replacement  replacementValueNode  result  second  stopNode  subExpression  tempNameNode  tempVarNode  thisNameNode  thisVarNode  trueExpr  Supplier  safeNameIdSupplier  String  resultName  sName  tempName  tempNamePrefix  int  MAX_INTERATIONS  i  parentType  type  
