[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, this ) ;^48^^^^^47^49^NodeTraversal.traverse ( compiler, root, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Node  externs  root  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( root, compiler, this ) ;^48^^^^^47^49^NodeTraversal.traverse ( compiler, root, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] AbstractCompiler  compiler  Node  externs  root  boolean  
[BugLab_Wrong_Literal]^return false;^53^^^^^52^54^return true;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] shouldTraverse [RETURN_TYPE] boolean   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^maybeCollapseIntoForStatements ( parent, n ) ;^58^^^^^57^59^maybeCollapseIntoForStatements ( n, parent ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^if  ( oldInitializer == null || !NodeUtil.isStatementBlock ( parent )  )  {^68^^^^^53^83^if  ( parent == null || !NodeUtil.isStatementBlock ( parent )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( parent == null && !NodeUtil.isStatementBlock ( parent )  )  {^68^^^^^53^83^if  ( parent == null || !NodeUtil.isStatementBlock ( parent )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( parent != null || !NodeUtil.isStatementBlock ( parent )  )  {^68^^^^^53^83^if  ( parent == null || !NodeUtil.isStatementBlock ( parent )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isExpressionNode ( oldInitializer )  && !NodeUtil.isVar ( n )  )  {^73^^^^^58^88^if  ( !NodeUtil.isExpressionNode ( n )  && !NodeUtil.isVar ( n )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( !NodeUtil.isExpressionNode ( n )  || !NodeUtil.isVar ( n )  )  {^73^^^^^58^88^if  ( !NodeUtil.isExpressionNode ( n )  && !NodeUtil.isVar ( n )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( !NodeUtil.isExpressionNode ( parent )  && !NodeUtil.isVar ( n )  )  {^73^^^^^58^88^if  ( !NodeUtil.isExpressionNode ( n )  && !NodeUtil.isVar ( n )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Node parentextSibling = n.getNext (  ) ;^78^^^^^63^93^Node nextSibling = n.getNext (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Node oldInitializerextSibling = n.getNext (  ) ;^78^^^^^63^93^Node nextSibling = n.getNext (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( parent != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^79^80^81^82^^64^94^if  ( nextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( parentextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^79^80^81^82^^64^94^if  ( nextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( nextSibling != null || nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^79^80^81^82^^64^94^if  ( nextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( nextSibling == null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^79^80^81^82^^64^94^if  ( nextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Wrong_Operator]^if  ( nextSibling != null && nextSibling.getType (  )  != Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^79^80^81^82^^64^94^if  ( nextSibling != null && nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( NodeUtil.containsType ( parent, Token.IN )  )  {^89^^^^^74^104^if  ( NodeUtil.containsType ( n, Token.IN )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^if  ( NodeUtil.isVar ( parent )  )  {^99^^^^^84^114^if  ( NodeUtil.isVar ( n )  )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^newInitializer = parent.getFirstChild (  ) ;^104^^^^^99^106^newInitializer = n.getFirstChild (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^n.removeChild ( parentewInitializer ) ;^105^^^^^99^106^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^105^^^^^99^106^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Argument_Swapping]^n.removeChild ( newInitializerewInitializer ) ;^105^^^^^99^106^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Argument_Swapping]^n.removeChild ( n ) ;^105^^^^^99^106^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^newInitializer = parent;^100^^^^^85^115^newInitializer = n;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^newInitializer = parent.getFirstChild (  ) ;^104^^^^^89^119^newInitializer = n.getFirstChild (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Node forNode = parent;^94^^^^^79^109^Node forNode = nextSibling;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Node oldInitializer = parent.getFirstChild (  ) ;^95^^^^^80^110^Node oldInitializer = forNode.getFirstChild (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Node oldInitializer = oldInitializer.getFirstChild (  ) ;^95^^^^^80^110^Node oldInitializer = forNode.getFirstChild (  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^parent.removeChild ( oldInitializer ) ;^96^^^^^81^111^parent.removeChild ( n ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Preconditions.checkState ( parent.hasOneChild (  )  ) ;^103^^^^^88^118^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^n.removeChild ( parentewInitializer ) ;^105^^^^^90^120^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^n.removeChild ( parent ) ;^105^^^^^90^120^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Argument_Swapping]^n.removeChild ( newInitializerewInitializer ) ;^105^^^^^90^120^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Argument_Swapping]^n.removeChild ( n ) ;^105^^^^^90^120^n.removeChild ( newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^forNode.replaceChild ( parent, newInitializer ) ;^108^^^^^93^123^forNode.replaceChild ( oldInitializer, newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^forNode.replaceChild ( oldInitializer, parent ) ;^108^^^^^93^123^forNode.replaceChild ( oldInitializer, newInitializer ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Preconditions.checkState ( parent.hasOneChild (  )  ) ;^103^^^^^99^106^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^&& parent.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^80^81^82^^^65^95^&& nextSibling.getType (  )  == Token.FOR && !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^&& !NodeUtil.isForIn ( parent ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^81^82^^^^66^96^&& !NodeUtil.isForIn ( nextSibling ) && nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^&& oldInitializer.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^82^^^^^67^97^&& nextSibling.getFirstChild (  ) .getType (  )  == Token.EMPTY )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^Preconditions.checkState ( oldInitializer.hasOneChild (  )  ) ;^103^^^^^88^118^Preconditions.checkState ( n.hasOneChild (  )  ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] maybeCollapseIntoForStatements [RETURN_TYPE] void   Node n Node parent [VARIABLES] AbstractCompiler  compiler  Node  forNode  n  newInitializer  nextSibling  oldInitializer  parent  boolean  
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, js, this ) ;^125^^^^^124^127^NodeTraversal.traverse ( compiler, externs, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( externs, compiler, this ) ;^125^^^^^124^127^NodeTraversal.traverse ( compiler, externs, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, this ) ;^126^^^^^124^127^NodeTraversal.traverse ( compiler, js, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( js, compiler, this ) ;^126^^^^^124^127^NodeTraversal.traverse ( compiler, js, this ) ;^[CLASS] Denormalize StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Wrong_Operator]^if  ( node.getType (  )  == Token.NAME && node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Wrong_Operator]^if  ( node.getType (  )  != Token.NAME || node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] Denormalize StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, js, this ) ;^125^^^^^124^127^NodeTraversal.traverse ( compiler, externs, this ) ;^[CLASS] StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( externs, compiler, this ) ;^125^^^^^124^127^NodeTraversal.traverse ( compiler, externs, this ) ;^[CLASS] StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Variable_Misuse]^NodeTraversal.traverse ( compiler, externs, this ) ;^126^^^^^124^127^NodeTraversal.traverse ( compiler, js, this ) ;^[CLASS] StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( js, compiler, this ) ;^126^^^^^124^127^NodeTraversal.traverse ( compiler, js, this ) ;^[CLASS] StripConstantAnnotations  [METHOD] process [RETURN_TYPE] void   Node externs Node js [VARIABLES] AbstractCompiler  compiler  Node  externs  js  boolean  
[BugLab_Variable_Misuse]^if  ( parent.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Wrong_Operator]^if  ( node.getType (  )  == Token.NAME && node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Wrong_Operator]^if  ( node.getType (  )  > Token.NAME || node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
[BugLab_Wrong_Operator]^if  ( node.getType (  )  != Token.NAME || node.getType (  )  == Token.STRING )  {^131^^^^^130^134^if  ( node.getType (  )  == Token.NAME || node.getType (  )  == Token.STRING )  {^[CLASS] StripConstantAnnotations  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node node Node parent [VARIABLES] AbstractCompiler  compiler  boolean  NodeTraversal  t  Node  node  parent  
