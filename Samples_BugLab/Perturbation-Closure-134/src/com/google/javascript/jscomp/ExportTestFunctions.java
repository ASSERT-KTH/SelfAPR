[BugLab_Variable_Misuse]^if  ( n != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^if  ( parent != parentull && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^if  ( n != parentull && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^if  ( parent != null || parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^if  ( parent == null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^if  ( parent != null && parent.getType (  )  != Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^if  ( isTestFunction ( parent, functionName )  && t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^if  ( isTestFunction ( n, exportSymbolFunction )  && t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^if  ( isTestFunction ( n, t )  && functionName.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Wrong_Operator]^if  ( isTestFunction ( n, functionName )  || t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^exportTestFunction ( exportSymbolFunction, n, parent ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^exportTestFunction ( parent, n, functionName ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^exportTestFunction ( functionName, parent, n ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^String functionName = NodeUtil.getFunctionName ( parent, parent ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^String functionName = NodeUtil.getFunctionName ( n, n ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^String functionName = NodeUtil.getFunctionName ( parent, n ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^if  ( isTestFunction ( functionName, n )  && t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^exportTestFunction ( functionName, n, n ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Variable_Misuse]^exportTestFunction ( functionName, parent, parent ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  NodeTraversal  t  Node  n  parent  
[BugLab_Argument_Swapping]^NodeTraversal.traverse ( root, compiler, new ExportTestFunctionsNodes (  )  ) ;^66^^^^^65^67^NodeTraversal.traverse ( compiler, root, new ExportTestFunctionsNodes (  )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] process [RETURN_TYPE] void   Node externs Node root [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  boolean  Node  externs  root  
[BugLab_Variable_Misuse]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, functionName )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( functionName, node, testFunctionName )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Argument_Swapping]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( node, exportSymbolFunction, testFunctionName )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Argument_Swapping]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( testFunctionName, node, exportSymbolFunction )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, scriptNode, testFunctionName )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( testFunctionName, node, testFunctionName )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Argument_Swapping]^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, testFunctionName, node )  ) ;^73^74^^^^70^83^Node call = new Node ( Token.CALL, NodeUtil.newQualifiedNameNode ( exportSymbolFunction, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^call.addChildToBack ( Node.newString ( functionName )  ) ;^75^^^^^70^83^call.addChildToBack ( Node.newString ( testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( functionName, node, testFunctionName )  ) ;^76^77^^^^70^83^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( testFunctionName, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Argument_Swapping]^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( node, testFunctionName, testFunctionName )  ) ;^76^77^^^^70^83^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( testFunctionName, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( testFunctionName, scriptNode, testFunctionName )  ) ;^76^77^^^^70^83^call.addChildToBack ( NodeUtil.newQualifiedNameNode ( testFunctionName, node, testFunctionName )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^Node expression = new Node ( Token.EXPR_RESULT, scriptNode ) ;^79^^^^^70^83^Node expression = new Node ( Token.EXPR_RESULT, call ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^scriptNode.addChildAfter ( node, node ) ;^81^^^^^70^83^scriptNode.addChildAfter ( expression, node ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^scriptNode.addChildAfter ( expression, expression ) ;^81^^^^^70^83^scriptNode.addChildAfter ( expression, node ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] exportTestFunction [RETURN_TYPE] void   String testFunctionName Node node Node scriptNode [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  call  expression  node  scriptNode  
[BugLab_Variable_Misuse]^return ! ( testFunctionName == null || !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^95^96^^^^94^97^return ! ( functionName == null || !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] isTestFunction [RETURN_TYPE] boolean   Node n String functionName [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  n  
[BugLab_Wrong_Operator]^return ! ( functionName == null && !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^95^96^^^^94^97^return ! ( functionName == null || !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] isTestFunction [RETURN_TYPE] boolean   Node n String functionName [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  n  
[BugLab_Wrong_Operator]^return ! ( functionName != null || !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^95^96^^^^94^97^return ! ( functionName == null || !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] isTestFunction [RETURN_TYPE] boolean   Node n String functionName [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  n  
[BugLab_Variable_Misuse]^|| !TEST_FUNCTIONS_NAME_PATTERN.matcher ( testFunctionName ) .matches (  )  ) ;^96^^^^^94^97^|| !TEST_FUNCTIONS_NAME_PATTERN.matcher ( functionName ) .matches (  )  ) ;^[CLASS] ExportTestFunctions ExportTestFunctionsNodes  [METHOD] isTestFunction [RETURN_TYPE] boolean   Node n String functionName [VARIABLES] Pattern  TEST_FUNCTIONS_NAME_PATTERN  AbstractCompiler  compiler  String  exportSymbolFunction  functionName  testFunctionName  boolean  Node  n  
[BugLab_Variable_Misuse]^if  ( n != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^if  ( parent != parentull && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^if  ( n != parentull && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Wrong_Operator]^if  ( parent != null || parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Wrong_Operator]^if  ( parent == null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Wrong_Operator]^if  ( parent != null && parent.getType (  )  != Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^55^56^^^^54^62^if  ( parent != null && parent.getType (  )  == Token.SCRIPT && n.getType (  )  == Token.FUNCTION )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^if  ( isTestFunction ( functionName, n )  && t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^if  ( isTestFunction ( t, functionName )  && n.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Wrong_Operator]^if  ( isTestFunction ( n, functionName )  || t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^exportTestFunction ( n, functionName, parent ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^exportTestFunction ( functionName, parent, n ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^String functionName = NodeUtil.getFunctionName ( parent, parent ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^String functionName = NodeUtil.getFunctionName ( n, n ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^String functionName = NodeUtil.getFunctionName ( parent, n ) ;^57^^^^^54^62^String functionName = NodeUtil.getFunctionName ( n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^if  ( isTestFunction ( parent, functionName )  && t.inGlobalScope (  )  )  {^58^^^^^54^62^if  ( isTestFunction ( n, functionName )  && t.inGlobalScope (  )  )  {^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^exportTestFunction ( functionName, parent, parent ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Variable_Misuse]^exportTestFunction ( functionName, n, n ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
[BugLab_Argument_Swapping]^exportTestFunction ( parent, n, functionName ) ;^59^^^^^54^62^exportTestFunction ( functionName, n, parent ) ;^[CLASS] ExportTestFunctionsNodes  [METHOD] visit [RETURN_TYPE] void   NodeTraversal t Node n Node parent [VARIABLES] boolean  NodeTraversal  t  Node  n  parent  String  functionName  
